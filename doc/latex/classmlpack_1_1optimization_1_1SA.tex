\section{mlpack\+:\+:optimization\+:\+:SA$<$ Function\+Type, Cooling\+Schedule\+Type $>$ Class Template Reference}
\label{classmlpack_1_1optimization_1_1SA}\index{mlpack\+::optimization\+::\+S\+A$<$ Function\+Type, Cooling\+Schedule\+Type $>$@{mlpack\+::optimization\+::\+S\+A$<$ Function\+Type, Cooling\+Schedule\+Type $>$}}


Simulated Annealing is an stochastic optimization algorithm which is able to deliver near-\/optimal results quickly without knowing the gradient of the function being optimized.  


\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf SA} (Function\+Type \&{\bf function}, Cooling\+Schedule\+Type \&{\bf cooling\+Schedule}, const size\+\_\+t {\bf max\+Iterations}=1000000, const double initT=10000., const size\+\_\+t {\bf init\+Moves}=1000, const size\+\_\+t {\bf move\+Ctrl\+Sweep}=100, const double {\bf tolerance}=1e-\/5, const size\+\_\+t max\+Tolerance\+Sweep=3, const double max\+Move\+Coef=20, const double init\+Move\+Coef=0.\+3, const double gain=0.\+3)
\begin{DoxyCompactList}\small\item\em Construct the \doxyref{SA}{p.}{classmlpack_1_1optimization_1_1SA} optimizer with the given function and parameters. \end{DoxyCompactList}\item 
const Function\+Type \& {\bf Function} () const 
\begin{DoxyCompactList}\small\item\em Get the instantiated function to be optimized. \end{DoxyCompactList}\item 
Function\+Type \& {\bf Function} ()
\begin{DoxyCompactList}\small\item\em Modify the instantiated function. \end{DoxyCompactList}\item 
double {\bf Gain} () const 
\begin{DoxyCompactList}\small\item\em Get the gain. \end{DoxyCompactList}\item 
double \& {\bf Gain} ()
\begin{DoxyCompactList}\small\item\em Modify the gain. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Init\+Moves} () const 
\begin{DoxyCompactList}\small\item\em Get the initial moves. \end{DoxyCompactList}\item 
size\+\_\+t \& {\bf Init\+Moves} ()
\begin{DoxyCompactList}\small\item\em Modify the initial moves. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Max\+Iterations} () const 
\begin{DoxyCompactList}\small\item\em Get the maximum number of iterations. \end{DoxyCompactList}\item 
size\+\_\+t \& {\bf Max\+Iterations} ()
\begin{DoxyCompactList}\small\item\em Modify the maximum number of iterations. \end{DoxyCompactList}\item 
arma\+::mat {\bf Max\+Move} () const 
\begin{DoxyCompactList}\small\item\em Get the maximum move size of each parameter. \end{DoxyCompactList}\item 
arma\+::mat \& {\bf Max\+Move} ()
\begin{DoxyCompactList}\small\item\em Modify the maximum move size of each parameter. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Max\+Tolerance\+Sweep} () const 
\begin{DoxyCompactList}\small\item\em Get the max\+Tolerance\+Sweep. \end{DoxyCompactList}\item 
size\+\_\+t \& {\bf Max\+Tolerance\+Sweep} ()
\begin{DoxyCompactList}\small\item\em Modify the max\+Tolerance\+Sweep. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Move\+Ctrl\+Sweep} () const 
\begin{DoxyCompactList}\small\item\em Get sweeps per move control. \end{DoxyCompactList}\item 
size\+\_\+t \& {\bf Move\+Ctrl\+Sweep} ()
\begin{DoxyCompactList}\small\item\em Modify sweeps per move control. \end{DoxyCompactList}\item 
arma\+::mat {\bf Move\+Size} () const 
\begin{DoxyCompactList}\small\item\em Get move size of each parameter. \end{DoxyCompactList}\item 
arma\+::mat \& {\bf Move\+Size} ()
\begin{DoxyCompactList}\small\item\em Modify move size of each parameter. \end{DoxyCompactList}\item 
double {\bf Optimize} (arma\+::mat \&iterate)
\begin{DoxyCompactList}\small\item\em Optimize the given function using simulated annealing. \end{DoxyCompactList}\item 
double {\bf Temperature} () const 
\begin{DoxyCompactList}\small\item\em Get the temperature. \end{DoxyCompactList}\item 
double \& {\bf Temperature} ()
\begin{DoxyCompactList}\small\item\em Modify the temperature. \end{DoxyCompactList}\item 
double {\bf Tolerance} () const 
\begin{DoxyCompactList}\small\item\em Get the tolerance. \end{DoxyCompactList}\item 
double \& {\bf Tolerance} ()
\begin{DoxyCompactList}\small\item\em Modify the tolerance. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void {\bf Generate\+Move} (arma\+::mat \&iterate, arma\+::mat \&accept, double \&energy, size\+\_\+t \&idx, size\+\_\+t \&sweep\+Counter)
\begin{DoxyCompactList}\small\item\em Generate\+Move proposes a move on element iterate(idx), and determines if that move is acceptable or not according to the Metropolis criterion. \end{DoxyCompactList}\item 
void {\bf Move\+Control} (const size\+\_\+t n\+Moves, arma\+::mat \&accept)
\begin{DoxyCompactList}\small\item\em \doxyref{Move\+Control()}{p.}{classmlpack_1_1optimization_1_1SA_ae5a4321e8048dc36ecbc173de5a54a11} uses a proportional feedback control to determine the size parameter to pass to the move generation distribution. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
Cooling\+Schedule\+Type \& {\bf cooling\+Schedule}
\begin{DoxyCompactList}\small\item\em The cooling schedule being used. \end{DoxyCompactList}\item 
Function\+Type \& {\bf function}
\begin{DoxyCompactList}\small\item\em The function to be optimized. \end{DoxyCompactList}\item 
double {\bf gain}
\begin{DoxyCompactList}\small\item\em Proportional control in feedback move control. \end{DoxyCompactList}\item 
size\+\_\+t {\bf init\+Moves}
\begin{DoxyCompactList}\small\item\em The number of initial moves before reducing the temperature. \end{DoxyCompactList}\item 
size\+\_\+t {\bf max\+Iterations}
\begin{DoxyCompactList}\small\item\em The maximum number of iterations. \end{DoxyCompactList}\item 
arma\+::mat {\bf max\+Move}
\begin{DoxyCompactList}\small\item\em Maximum move size of each parameter. \end{DoxyCompactList}\item 
size\+\_\+t {\bf max\+Tolerance\+Sweep}
\begin{DoxyCompactList}\small\item\em Number of sweeps in tolerance before system is considered frozen. \end{DoxyCompactList}\item 
size\+\_\+t {\bf move\+Ctrl\+Sweep}
\begin{DoxyCompactList}\small\item\em The number of sweeps before a \doxyref{Move\+Control()}{p.}{classmlpack_1_1optimization_1_1SA_ae5a4321e8048dc36ecbc173de5a54a11} call. \end{DoxyCompactList}\item 
arma\+::mat {\bf move\+Size}
\begin{DoxyCompactList}\small\item\em Move size of each parameter. \end{DoxyCompactList}\item 
double {\bf temperature}
\begin{DoxyCompactList}\small\item\em The current temperature. \end{DoxyCompactList}\item 
double {\bf tolerance}
\begin{DoxyCompactList}\small\item\em Tolerance for convergence. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename Function\+Type, typename Cooling\+Schedule\+Type = Exponential\+Schedule$>$\\*
class mlpack\+::optimization\+::\+S\+A$<$ Function\+Type, Cooling\+Schedule\+Type $>$}

Simulated Annealing is an stochastic optimization algorithm which is able to deliver near-\/optimal results quickly without knowing the gradient of the function being optimized. 

It has unique hill climbing capability that makes it less vulnerable to local minima. This implementation uses exponential cooling schedule and feedback move control by default, but the cooling schedule can be changed via a template parameter.

The algorithm keeps the temperature at initial temperature for init\+Move steps to get rid of the dependency on the initial condition. After that, it cools every step until the system is considered frozen or max\+Iterations is reached.

At each step, \doxyref{SA}{p.}{classmlpack_1_1optimization_1_1SA} only perturbs one parameter at a time. When \doxyref{SA}{p.}{classmlpack_1_1optimization_1_1SA} has perturbed all parameters in a problem, a sweep has been completed. Every move\+Ctrl\+Sweep sweeps, the algorithm does feedback move control to change the average move size depending on the responsiveness of each parameter. Parameter gain controls the proportion of the feedback control.

The system is considered \char`\"{}frozen\char`\"{} when its score fails to change more then tolerance for max\+Tolerance\+Sweep consecutive sweeps.

For \doxyref{SA}{p.}{classmlpack_1_1optimization_1_1SA} to work, the Function\+Type parameter must implement the following two methods\+:

double Evaluate(const arma\+::mat\& coordinates); arma\+::mat\& Get\+Initial\+Point();

and the Cooling\+Schedule\+Type parameter must implement the following method\+:

double Next\+Temperature(const double current\+Temperature, const double current\+Value);

which returns the next temperature given current temperature and the value of the function being optimized.


\begin{DoxyTemplParams}{Template Parameters}
{\em Function\+Type} & objective function type to be minimized. \\
\hline
{\em Cooling\+Schedule\+Type} & type for cooling schedule \\
\hline
\end{DoxyTemplParams}


Definition at line 65 of file sa.\+hpp.



\subsection{Constructor \& Destructor Documentation}
\index{mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}!SA@{SA}}
\index{SA@{SA}!mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}}
\subsubsection[{S\+A(\+Function\+Type \&function, Cooling\+Schedule\+Type \&cooling\+Schedule, const size\+\_\+t max\+Iterations=1000000, const double init\+T=10000., const size\+\_\+t init\+Moves=1000, const size\+\_\+t move\+Ctrl\+Sweep=100, const double tolerance=1e-\/5, const size\+\_\+t max\+Tolerance\+Sweep=3, const double max\+Move\+Coef=20, const double init\+Move\+Coef=0.\+3, const double gain=0.\+3)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Function\+Type , typename Cooling\+Schedule\+Type  = Exponential\+Schedule$>$ {\bf mlpack\+::optimization\+::\+SA}$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::{\bf SA} (
\begin{DoxyParamCaption}
\item[{Function\+Type \&}]{function, }
\item[{Cooling\+Schedule\+Type \&}]{cooling\+Schedule, }
\item[{const size\+\_\+t}]{max\+Iterations = {\ttfamily 1000000}, }
\item[{const double}]{initT = {\ttfamily 10000.}, }
\item[{const size\+\_\+t}]{init\+Moves = {\ttfamily 1000}, }
\item[{const size\+\_\+t}]{move\+Ctrl\+Sweep = {\ttfamily 100}, }
\item[{const double}]{tolerance = {\ttfamily 1e-\/5}, }
\item[{const size\+\_\+t}]{max\+Tolerance\+Sweep = {\ttfamily 3}, }
\item[{const double}]{max\+Move\+Coef = {\ttfamily 20}, }
\item[{const double}]{init\+Move\+Coef = {\ttfamily 0.3}, }
\item[{const double}]{gain = {\ttfamily 0.3}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1optimization_1_1SA_a2ca61632969fb1051ccf9d488aec3f41}


Construct the \doxyref{SA}{p.}{classmlpack_1_1optimization_1_1SA} optimizer with the given function and parameters. 


\begin{DoxyParams}{Parameters}
{\em function} & Function to be minimized. \\
\hline
{\em cooling\+Schedule} & Instantiated cooling schedule. \\
\hline
{\em max\+Iterations} & Maximum number of iterations allowed (0 indicates no limit). \\
\hline
{\em initT} & Initial temperature. \\
\hline
{\em init\+Moves} & Number of initial iterations without changing temperature. \\
\hline
{\em move\+Ctrl\+Sweep} & Sweeps per feedback move control. \\
\hline
{\em tolerance} & Tolerance to consider system frozen. \\
\hline
{\em max\+Tolerance\+Sweep} & Maximum sweeps below tolerance to consider system frozen. \\
\hline
{\em max\+Move\+Coef} & Maximum move size. \\
\hline
{\em init\+Move\+Coef} & Initial move size. \\
\hline
{\em gain} & Proportional control in feedback move control. \\
\hline
\end{DoxyParams}


\subsection{Member Function Documentation}
\index{mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}!Function@{Function}}
\index{Function@{Function}!mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}}
\subsubsection[{Function() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Function\+Type , typename Cooling\+Schedule\+Type  = Exponential\+Schedule$>$ const Function\+Type\& {\bf mlpack\+::optimization\+::\+SA}$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::Function (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1optimization_1_1SA_ae12e0bbacda10e3053623091f8cb1854}


Get the instantiated function to be optimized. 



Definition at line 107 of file sa.\+hpp.

\index{mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}!Function@{Function}}
\index{Function@{Function}!mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}}
\subsubsection[{Function()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Function\+Type , typename Cooling\+Schedule\+Type  = Exponential\+Schedule$>$ Function\+Type\& {\bf mlpack\+::optimization\+::\+SA}$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::Function (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1optimization_1_1SA_a40c103988fc59a1edce6362cf354f651}


Modify the instantiated function. 



Definition at line 109 of file sa.\+hpp.

\index{mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}!Gain@{Gain}}
\index{Gain@{Gain}!mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}}
\subsubsection[{Gain() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Function\+Type , typename Cooling\+Schedule\+Type  = Exponential\+Schedule$>$ double {\bf mlpack\+::optimization\+::\+SA}$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::Gain (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1optimization_1_1SA_a5d6f61a4cbb87f1dd18e55d7ea9a3127}


Get the gain. 



Definition at line 137 of file sa.\+hpp.



References mlpack\+::optimization\+::\+S\+A$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::gain.

\index{mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}!Gain@{Gain}}
\index{Gain@{Gain}!mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}}
\subsubsection[{Gain()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Function\+Type , typename Cooling\+Schedule\+Type  = Exponential\+Schedule$>$ double\& {\bf mlpack\+::optimization\+::\+SA}$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::Gain (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1optimization_1_1SA_ad33516557c8fd42cb684cfb8a032232f}


Modify the gain. 



Definition at line 139 of file sa.\+hpp.



References mlpack\+::optimization\+::\+S\+A$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::gain.

\index{mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}!Generate\+Move@{Generate\+Move}}
\index{Generate\+Move@{Generate\+Move}!mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}}
\subsubsection[{Generate\+Move(arma\+::mat \&iterate, arma\+::mat \&accept, double \&energy, size\+\_\+t \&idx, size\+\_\+t \&sweep\+Counter)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Function\+Type , typename Cooling\+Schedule\+Type  = Exponential\+Schedule$>$ void {\bf mlpack\+::optimization\+::\+SA}$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::Generate\+Move (
\begin{DoxyParamCaption}
\item[{arma\+::mat \&}]{iterate, }
\item[{arma\+::mat \&}]{accept, }
\item[{double \&}]{energy, }
\item[{size\+\_\+t \&}]{idx, }
\item[{size\+\_\+t \&}]{sweep\+Counter}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1optimization_1_1SA_aa775231810898c9e26d04a6645bda66d}


Generate\+Move proposes a move on element iterate(idx), and determines if that move is acceptable or not according to the Metropolis criterion. 

After that it increments idx so the next call will make a move on next parameters. When all elements of the state have been moved (a sweep), it resets idx and increments sweep\+Counter. When sweep\+Counter reaches move\+Ctrl\+Sweep, it performs \doxyref{Move\+Control()}{p.}{classmlpack_1_1optimization_1_1SA_ae5a4321e8048dc36ecbc173de5a54a11} and resets sweep\+Counter.


\begin{DoxyParams}{Parameters}
{\em iterate} & Current optimization position. \\
\hline
{\em accept} & Matrix representing which parameters have had accepted moves. \\
\hline
{\em energy} & Current energy of the system. \\
\hline
{\em idx} & Current parameter to modify. \\
\hline
{\em sweep\+Counter} & Current counter representing how many sweeps have been completed. \\
\hline
\end{DoxyParams}
\index{mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}!Init\+Moves@{Init\+Moves}}
\index{Init\+Moves@{Init\+Moves}!mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}}
\subsubsection[{Init\+Moves() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Function\+Type , typename Cooling\+Schedule\+Type  = Exponential\+Schedule$>$ size\+\_\+t {\bf mlpack\+::optimization\+::\+SA}$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::Init\+Moves (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1optimization_1_1SA_a34476b8d0f8eeb2392642e9140f266b5}


Get the initial moves. 



Definition at line 117 of file sa.\+hpp.



References mlpack\+::optimization\+::\+S\+A$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::init\+Moves.

\index{mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}!Init\+Moves@{Init\+Moves}}
\index{Init\+Moves@{Init\+Moves}!mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}}
\subsubsection[{Init\+Moves()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Function\+Type , typename Cooling\+Schedule\+Type  = Exponential\+Schedule$>$ size\+\_\+t\& {\bf mlpack\+::optimization\+::\+SA}$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::Init\+Moves (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1optimization_1_1SA_ac42b4a324aac463aaecd9d3003ffe97c}


Modify the initial moves. 



Definition at line 119 of file sa.\+hpp.



References mlpack\+::optimization\+::\+S\+A$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::init\+Moves.

\index{mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}!Max\+Iterations@{Max\+Iterations}}
\index{Max\+Iterations@{Max\+Iterations}!mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}}
\subsubsection[{Max\+Iterations() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Function\+Type , typename Cooling\+Schedule\+Type  = Exponential\+Schedule$>$ size\+\_\+t {\bf mlpack\+::optimization\+::\+SA}$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::Max\+Iterations (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1optimization_1_1SA_af0db130af9740a8d6e7f11b2693888fc}


Get the maximum number of iterations. 



Definition at line 142 of file sa.\+hpp.



References mlpack\+::optimization\+::\+S\+A$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::max\+Iterations.

\index{mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}!Max\+Iterations@{Max\+Iterations}}
\index{Max\+Iterations@{Max\+Iterations}!mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}}
\subsubsection[{Max\+Iterations()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Function\+Type , typename Cooling\+Schedule\+Type  = Exponential\+Schedule$>$ size\+\_\+t\& {\bf mlpack\+::optimization\+::\+SA}$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::Max\+Iterations (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1optimization_1_1SA_aba854b79ce23e8ca848e0059f07baea2}


Modify the maximum number of iterations. 



Definition at line 144 of file sa.\+hpp.



References mlpack\+::optimization\+::\+S\+A$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::max\+Iterations.

\index{mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}!Max\+Move@{Max\+Move}}
\index{Max\+Move@{Max\+Move}!mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}}
\subsubsection[{Max\+Move() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Function\+Type , typename Cooling\+Schedule\+Type  = Exponential\+Schedule$>$ arma\+::mat {\bf mlpack\+::optimization\+::\+SA}$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::Max\+Move (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1optimization_1_1SA_a3296ad3e7ae1cadac0f3460b9c376f9f}


Get the maximum move size of each parameter. 



Definition at line 147 of file sa.\+hpp.



References mlpack\+::optimization\+::\+S\+A$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::max\+Move.

\index{mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}!Max\+Move@{Max\+Move}}
\index{Max\+Move@{Max\+Move}!mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}}
\subsubsection[{Max\+Move()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Function\+Type , typename Cooling\+Schedule\+Type  = Exponential\+Schedule$>$ arma\+::mat\& {\bf mlpack\+::optimization\+::\+SA}$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::Max\+Move (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1optimization_1_1SA_a83b0d63c4940b266f7a629c36533d7a6}


Modify the maximum move size of each parameter. 



Definition at line 149 of file sa.\+hpp.



References mlpack\+::optimization\+::\+S\+A$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::max\+Move.

\index{mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}!Max\+Tolerance\+Sweep@{Max\+Tolerance\+Sweep}}
\index{Max\+Tolerance\+Sweep@{Max\+Tolerance\+Sweep}!mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}}
\subsubsection[{Max\+Tolerance\+Sweep() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Function\+Type , typename Cooling\+Schedule\+Type  = Exponential\+Schedule$>$ size\+\_\+t {\bf mlpack\+::optimization\+::\+SA}$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::Max\+Tolerance\+Sweep (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1optimization_1_1SA_a41371fc54ac1dcd9162a3bd99000fbb5}


Get the max\+Tolerance\+Sweep. 



Definition at line 132 of file sa.\+hpp.



References mlpack\+::optimization\+::\+S\+A$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::max\+Tolerance\+Sweep.

\index{mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}!Max\+Tolerance\+Sweep@{Max\+Tolerance\+Sweep}}
\index{Max\+Tolerance\+Sweep@{Max\+Tolerance\+Sweep}!mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}}
\subsubsection[{Max\+Tolerance\+Sweep()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Function\+Type , typename Cooling\+Schedule\+Type  = Exponential\+Schedule$>$ size\+\_\+t\& {\bf mlpack\+::optimization\+::\+SA}$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::Max\+Tolerance\+Sweep (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1optimization_1_1SA_af0f04c9db4ef72fa884dbd8bb3287091}


Modify the max\+Tolerance\+Sweep. 



Definition at line 134 of file sa.\+hpp.



References mlpack\+::optimization\+::\+S\+A$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::max\+Tolerance\+Sweep.

\index{mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}!Move\+Control@{Move\+Control}}
\index{Move\+Control@{Move\+Control}!mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}}
\subsubsection[{Move\+Control(const size\+\_\+t n\+Moves, arma\+::mat \&accept)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Function\+Type , typename Cooling\+Schedule\+Type  = Exponential\+Schedule$>$ void {\bf mlpack\+::optimization\+::\+SA}$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::Move\+Control (
\begin{DoxyParamCaption}
\item[{const size\+\_\+t}]{n\+Moves, }
\item[{arma\+::mat \&}]{accept}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1optimization_1_1SA_ae5a4321e8048dc36ecbc173de5a54a11}


\doxyref{Move\+Control()}{p.}{classmlpack_1_1optimization_1_1SA_ae5a4321e8048dc36ecbc173de5a54a11} uses a proportional feedback control to determine the size parameter to pass to the move generation distribution. 

The target of such move control is to make the acceptance ratio, accept/n\+Moves, be as close to 0.\+44 as possible. Generally speaking, the larger the move size is, the larger the function value change of the move will be, and less likely such move will be accepted by the Metropolis criterion. Thus, the move size is controlled by

log(move\+Size) = log(move\+Size) + gain $\ast$ (accept/n\+Moves -\/ target)

For more theory and the mysterious 0.\+44 value, see Jimmy K.-\/C. Lam and Jean-\/\+Marc Delosme. `\+An efficient simulated annealing schedule\+: derivation\textquotesingle{}. Technical Report 8816, Yale University, 1988.


\begin{DoxyParams}{Parameters}
{\em n\+Moves} & Number of moves since last call. \\
\hline
{\em accept} & Matrix representing which parameters have had accepted moves. \\
\hline
\end{DoxyParams}
\index{mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}!Move\+Ctrl\+Sweep@{Move\+Ctrl\+Sweep}}
\index{Move\+Ctrl\+Sweep@{Move\+Ctrl\+Sweep}!mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}}
\subsubsection[{Move\+Ctrl\+Sweep() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Function\+Type , typename Cooling\+Schedule\+Type  = Exponential\+Schedule$>$ size\+\_\+t {\bf mlpack\+::optimization\+::\+SA}$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::Move\+Ctrl\+Sweep (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1optimization_1_1SA_ab0b9c35eaab0c3de53bd72cd5ba428b8}


Get sweeps per move control. 



Definition at line 122 of file sa.\+hpp.



References mlpack\+::optimization\+::\+S\+A$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::move\+Ctrl\+Sweep.

\index{mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}!Move\+Ctrl\+Sweep@{Move\+Ctrl\+Sweep}}
\index{Move\+Ctrl\+Sweep@{Move\+Ctrl\+Sweep}!mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}}
\subsubsection[{Move\+Ctrl\+Sweep()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Function\+Type , typename Cooling\+Schedule\+Type  = Exponential\+Schedule$>$ size\+\_\+t\& {\bf mlpack\+::optimization\+::\+SA}$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::Move\+Ctrl\+Sweep (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1optimization_1_1SA_a6127a6347a81512148f48ac765fbad37}


Modify sweeps per move control. 



Definition at line 124 of file sa.\+hpp.



References mlpack\+::optimization\+::\+S\+A$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::move\+Ctrl\+Sweep.

\index{mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}!Move\+Size@{Move\+Size}}
\index{Move\+Size@{Move\+Size}!mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}}
\subsubsection[{Move\+Size() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Function\+Type , typename Cooling\+Schedule\+Type  = Exponential\+Schedule$>$ arma\+::mat {\bf mlpack\+::optimization\+::\+SA}$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::Move\+Size (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1optimization_1_1SA_ac503f379aa1037e0fd0ce31da5d4ec45}


Get move size of each parameter. 



Definition at line 152 of file sa.\+hpp.



References mlpack\+::optimization\+::\+S\+A$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::move\+Size.

\index{mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}!Move\+Size@{Move\+Size}}
\index{Move\+Size@{Move\+Size}!mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}}
\subsubsection[{Move\+Size()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Function\+Type , typename Cooling\+Schedule\+Type  = Exponential\+Schedule$>$ arma\+::mat\& {\bf mlpack\+::optimization\+::\+SA}$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::Move\+Size (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1optimization_1_1SA_a82c2d5c36d2dea7aa249c2cb754beff0}


Modify move size of each parameter. 



Definition at line 154 of file sa.\+hpp.



References mlpack\+::optimization\+::\+S\+A$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::move\+Size.

\index{mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}!Optimize@{Optimize}}
\index{Optimize@{Optimize}!mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}}
\subsubsection[{Optimize(arma\+::mat \&iterate)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Function\+Type , typename Cooling\+Schedule\+Type  = Exponential\+Schedule$>$ double {\bf mlpack\+::optimization\+::\+SA}$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::Optimize (
\begin{DoxyParamCaption}
\item[{arma\+::mat \&}]{iterate}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1optimization_1_1SA_a07611d66e8b7539c381fc1009af0d429}


Optimize the given function using simulated annealing. 

The given starting point will be modified to store the finishing point of the algorithm, and the final objective value is returned.


\begin{DoxyParams}{Parameters}
{\em iterate} & Starting point (will be modified). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Objective value of the final point. 
\end{DoxyReturn}
\index{mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}!Temperature@{Temperature}}
\index{Temperature@{Temperature}!mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}}
\subsubsection[{Temperature() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Function\+Type , typename Cooling\+Schedule\+Type  = Exponential\+Schedule$>$ double {\bf mlpack\+::optimization\+::\+SA}$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::Temperature (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1optimization_1_1SA_a9ed3b9c3a5790ca696f18c1a60cec130}


Get the temperature. 



Definition at line 112 of file sa.\+hpp.



References mlpack\+::optimization\+::\+S\+A$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::temperature.

\index{mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}!Temperature@{Temperature}}
\index{Temperature@{Temperature}!mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}}
\subsubsection[{Temperature()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Function\+Type , typename Cooling\+Schedule\+Type  = Exponential\+Schedule$>$ double\& {\bf mlpack\+::optimization\+::\+SA}$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::Temperature (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1optimization_1_1SA_a80ab0c7b3b0906fcc5ab074065e838a3}


Modify the temperature. 



Definition at line 114 of file sa.\+hpp.



References mlpack\+::optimization\+::\+S\+A$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::temperature.

\index{mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}!Tolerance@{Tolerance}}
\index{Tolerance@{Tolerance}!mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}}
\subsubsection[{Tolerance() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Function\+Type , typename Cooling\+Schedule\+Type  = Exponential\+Schedule$>$ double {\bf mlpack\+::optimization\+::\+SA}$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::Tolerance (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1optimization_1_1SA_a359d47d27aee0ffd4a668d02c2613ae4}


Get the tolerance. 



Definition at line 127 of file sa.\+hpp.



References mlpack\+::optimization\+::\+S\+A$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::tolerance.

\index{mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}!Tolerance@{Tolerance}}
\index{Tolerance@{Tolerance}!mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}}
\subsubsection[{Tolerance()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Function\+Type , typename Cooling\+Schedule\+Type  = Exponential\+Schedule$>$ double\& {\bf mlpack\+::optimization\+::\+SA}$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::Tolerance (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1optimization_1_1SA_a924d5dd42245401769b2d6e3e797b721}


Modify the tolerance. 



Definition at line 129 of file sa.\+hpp.



References mlpack\+::optimization\+::\+S\+A$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::tolerance.



\subsection{Member Data Documentation}
\index{mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}!cooling\+Schedule@{cooling\+Schedule}}
\index{cooling\+Schedule@{cooling\+Schedule}!mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}}
\subsubsection[{cooling\+Schedule}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Function\+Type , typename Cooling\+Schedule\+Type  = Exponential\+Schedule$>$ Cooling\+Schedule\+Type\& {\bf mlpack\+::optimization\+::\+SA}$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::cooling\+Schedule\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1optimization_1_1SA_a5720990dca1f66e518ed68d81faca18e}


The cooling schedule being used. 



Definition at line 160 of file sa.\+hpp.

\index{mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}!function@{function}}
\index{function@{function}!mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}}
\subsubsection[{function}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Function\+Type , typename Cooling\+Schedule\+Type  = Exponential\+Schedule$>$ Function\+Type\& {\bf mlpack\+::optimization\+::\+SA}$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::function\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1optimization_1_1SA_a63e3c83351af4bc9e7b53c45f0f26fb7}


The function to be optimized. 



Definition at line 158 of file sa.\+hpp.

\index{mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}!gain@{gain}}
\index{gain@{gain}!mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}}
\subsubsection[{gain}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Function\+Type , typename Cooling\+Schedule\+Type  = Exponential\+Schedule$>$ double {\bf mlpack\+::optimization\+::\+SA}$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::gain\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1optimization_1_1SA_ae42e1095aa711a40246f7650a731b5fd}


Proportional control in feedback move control. 



Definition at line 174 of file sa.\+hpp.



Referenced by mlpack\+::optimization\+::\+S\+A$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::\+Gain().

\index{mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}!init\+Moves@{init\+Moves}}
\index{init\+Moves@{init\+Moves}!mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}}
\subsubsection[{init\+Moves}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Function\+Type , typename Cooling\+Schedule\+Type  = Exponential\+Schedule$>$ size\+\_\+t {\bf mlpack\+::optimization\+::\+SA}$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::init\+Moves\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1optimization_1_1SA_a671c770cf908bcbc6a965e80c4c7d667}


The number of initial moves before reducing the temperature. 



Definition at line 166 of file sa.\+hpp.



Referenced by mlpack\+::optimization\+::\+S\+A$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::\+Init\+Moves().

\index{mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}!max\+Iterations@{max\+Iterations}}
\index{max\+Iterations@{max\+Iterations}!mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}}
\subsubsection[{max\+Iterations}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Function\+Type , typename Cooling\+Schedule\+Type  = Exponential\+Schedule$>$ size\+\_\+t {\bf mlpack\+::optimization\+::\+SA}$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::max\+Iterations\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1optimization_1_1SA_a169f1210650ef941c1365278612a4b61}


The maximum number of iterations. 



Definition at line 162 of file sa.\+hpp.



Referenced by mlpack\+::optimization\+::\+S\+A$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::\+Max\+Iterations().

\index{mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}!max\+Move@{max\+Move}}
\index{max\+Move@{max\+Move}!mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}}
\subsubsection[{max\+Move}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Function\+Type , typename Cooling\+Schedule\+Type  = Exponential\+Schedule$>$ arma\+::mat {\bf mlpack\+::optimization\+::\+SA}$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::max\+Move\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1optimization_1_1SA_ab01cb1116e883d40eda68c968740a9be}


Maximum move size of each parameter. 



Definition at line 177 of file sa.\+hpp.



Referenced by mlpack\+::optimization\+::\+S\+A$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::\+Max\+Move().

\index{mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}!max\+Tolerance\+Sweep@{max\+Tolerance\+Sweep}}
\index{max\+Tolerance\+Sweep@{max\+Tolerance\+Sweep}!mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}}
\subsubsection[{max\+Tolerance\+Sweep}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Function\+Type , typename Cooling\+Schedule\+Type  = Exponential\+Schedule$>$ size\+\_\+t {\bf mlpack\+::optimization\+::\+SA}$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::max\+Tolerance\+Sweep\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1optimization_1_1SA_afa4dd0d6bfc54e5075c5a08cf41a4312}


Number of sweeps in tolerance before system is considered frozen. 



Definition at line 172 of file sa.\+hpp.



Referenced by mlpack\+::optimization\+::\+S\+A$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::\+Max\+Tolerance\+Sweep().

\index{mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}!move\+Ctrl\+Sweep@{move\+Ctrl\+Sweep}}
\index{move\+Ctrl\+Sweep@{move\+Ctrl\+Sweep}!mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}}
\subsubsection[{move\+Ctrl\+Sweep}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Function\+Type , typename Cooling\+Schedule\+Type  = Exponential\+Schedule$>$ size\+\_\+t {\bf mlpack\+::optimization\+::\+SA}$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::move\+Ctrl\+Sweep\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1optimization_1_1SA_a78a4dbd2f0d93e5ebdf65c2cf9006ab9}


The number of sweeps before a \doxyref{Move\+Control()}{p.}{classmlpack_1_1optimization_1_1SA_ae5a4321e8048dc36ecbc173de5a54a11} call. 



Definition at line 168 of file sa.\+hpp.



Referenced by mlpack\+::optimization\+::\+S\+A$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::\+Move\+Ctrl\+Sweep().

\index{mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}!move\+Size@{move\+Size}}
\index{move\+Size@{move\+Size}!mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}}
\subsubsection[{move\+Size}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Function\+Type , typename Cooling\+Schedule\+Type  = Exponential\+Schedule$>$ arma\+::mat {\bf mlpack\+::optimization\+::\+SA}$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::move\+Size\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1optimization_1_1SA_a93f6721d1e636414a6f9602d4ebf6741}


Move size of each parameter. 



Definition at line 179 of file sa.\+hpp.



Referenced by mlpack\+::optimization\+::\+S\+A$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::\+Move\+Size().

\index{mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}!temperature@{temperature}}
\index{temperature@{temperature}!mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}}
\subsubsection[{temperature}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Function\+Type , typename Cooling\+Schedule\+Type  = Exponential\+Schedule$>$ double {\bf mlpack\+::optimization\+::\+SA}$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::temperature\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1optimization_1_1SA_a1295a33ebdeebedc19f58850822204a5}


The current temperature. 



Definition at line 164 of file sa.\+hpp.



Referenced by mlpack\+::optimization\+::\+S\+A$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::\+Temperature().

\index{mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}!tolerance@{tolerance}}
\index{tolerance@{tolerance}!mlpack\+::optimization\+::\+SA@{mlpack\+::optimization\+::\+SA}}
\subsubsection[{tolerance}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Function\+Type , typename Cooling\+Schedule\+Type  = Exponential\+Schedule$>$ double {\bf mlpack\+::optimization\+::\+SA}$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::tolerance\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1optimization_1_1SA_a9f7142c175ad3c2fc37ecf89ba339cad}


Tolerance for convergence. 



Definition at line 170 of file sa.\+hpp.



Referenced by mlpack\+::optimization\+::\+S\+A$<$ Function\+Type, Cooling\+Schedule\+Type $>$\+::\+Tolerance().



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/mlpack/core/optimizers/sa/{\bf sa.\+hpp}\end{DoxyCompactItemize}
