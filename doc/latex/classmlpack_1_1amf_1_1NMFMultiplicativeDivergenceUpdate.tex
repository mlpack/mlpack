\section{mlpack\+:\+:amf\+:\+:N\+M\+F\+Multiplicative\+Divergence\+Update Class Reference}
\label{classmlpack_1_1amf_1_1NMFMultiplicativeDivergenceUpdate}\index{mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Divergence\+Update@{mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Divergence\+Update}}


This follows a method described in the paper \textquotesingle{}Algorithms for Non-\/negative.  


\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf N\+M\+F\+Multiplicative\+Divergence\+Update} ()
\item 
{\footnotesize template$<$typename Mat\+Type $>$ }\\void {\bf Initialize} (const Mat\+Type \&, const size\+\_\+t)
\begin{DoxyCompactList}\small\item\em Initialize the factorization. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Archive $>$ }\\void {\bf Serialize} (Archive \&, const unsigned int)
\begin{DoxyCompactList}\small\item\em Serialize the object (in this case, there is nothing to serialize). \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename Mat\+Type $>$ }\\static void {\bf H\+Update} (const Mat\+Type \&V, const arma\+::mat \&W, arma\+::mat \&H)
\begin{DoxyCompactList}\small\item\em The update rule for the encoding matrix H. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Mat\+Type $>$ }\\static void {\bf W\+Update} (const Mat\+Type \&V, arma\+::mat \&W, const arma\+::mat \&H)
\begin{DoxyCompactList}\small\item\em The update rule for the basis matrix W. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
This follows a method described in the paper \textquotesingle{}Algorithms for Non-\/negative. 


\begin{DoxyCode}
@inproceedings\{lee2001algorithms,
  title=\{Algorithms \textcolor{keywordflow}{for} non-negative matrix factorization\},
  author=\{Lee, D.D. and Seung, H.S.\},
  booktitle=\{Advances in Neural Information Processing Systems 13
      (NIPS 2000)\},
  pages=\{556--562\},
  year=\{2001\}
\}
\end{DoxyCode}


This is a multiplicative rule that ensures that the Kullbackâ€“\+Leibler divergence

\[ \sum_i \sum_j (V_{ij} \log\frac{V_{ij}}{(W H)_{ij}} - V_{ij} + (W H)_{ij}) \]

is non-\/increasing between subsequent iterations. Both of the update rules for W and H are defined in this file.

This set of update rules is not meant to work with sparse matrices. Using sparse matrices often causes Na\+Ns in the output, so other choices of update rules are better in that situation. 

Definition at line 48 of file nmf\+\_\+mult\+\_\+div.\+hpp.



\subsection{Constructor \& Destructor Documentation}
\index{mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Divergence\+Update@{mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Divergence\+Update}!N\+M\+F\+Multiplicative\+Divergence\+Update@{N\+M\+F\+Multiplicative\+Divergence\+Update}}
\index{N\+M\+F\+Multiplicative\+Divergence\+Update@{N\+M\+F\+Multiplicative\+Divergence\+Update}!mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Divergence\+Update@{mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Divergence\+Update}}
\subsubsection[{N\+M\+F\+Multiplicative\+Divergence\+Update()}]{\setlength{\rightskip}{0pt plus 5cm}mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Divergence\+Update\+::\+N\+M\+F\+Multiplicative\+Divergence\+Update (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1amf_1_1NMFMultiplicativeDivergenceUpdate_a989aecc76d2b526557e030c7e63506ff}


Definition at line 52 of file nmf\+\_\+mult\+\_\+div.\+hpp.



\subsection{Member Function Documentation}
\index{mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Divergence\+Update@{mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Divergence\+Update}!H\+Update@{H\+Update}}
\index{H\+Update@{H\+Update}!mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Divergence\+Update@{mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Divergence\+Update}}
\subsubsection[{H\+Update(const Mat\+Type \&\+V, const arma\+::mat \&\+W, arma\+::mat \&\+H)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Mat\+Type $>$ static void mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Divergence\+Update\+::\+H\+Update (
\begin{DoxyParamCaption}
\item[{const Mat\+Type \&}]{V, }
\item[{const arma\+::mat \&}]{W, }
\item[{arma\+::mat \&}]{H}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\label{classmlpack_1_1amf_1_1NMFMultiplicativeDivergenceUpdate_a4d74e4fe86c3eacf1567be69950fd616}


The update rule for the encoding matrix H. 

The formula used is

\[ H_{a\mu} \leftarrow H_{a\mu} \frac{\sum_{i} W_{ia} V_{i\mu}/(WH)_{i\mu}} {\sum_{k} H_{ka}} \]

The function takes in all the matrices and only changes the value of the H matrix.


\begin{DoxyParams}{Parameters}
{\em V} & Input matrix to be factorized. \\
\hline
{\em W} & Basis matrix. \\
\hline
{\em H} & Encoding matrix to updated. \\
\hline
\end{DoxyParams}


Definition at line 124 of file nmf\+\_\+mult\+\_\+div.\+hpp.

\index{mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Divergence\+Update@{mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Divergence\+Update}!Initialize@{Initialize}}
\index{Initialize@{Initialize}!mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Divergence\+Update@{mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Divergence\+Update}}
\subsubsection[{Initialize(const Mat\+Type \&, const size\+\_\+t)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Mat\+Type $>$ void mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Divergence\+Update\+::\+Initialize (
\begin{DoxyParamCaption}
\item[{const Mat\+Type \&}]{, }
\item[{const size\+\_\+t}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1amf_1_1NMFMultiplicativeDivergenceUpdate_af81296ec72a027427fec6c48dd51ae60}


Initialize the factorization. 

These rules don\textquotesingle{}t store any state, so the input values are ignore. 

Definition at line 59 of file nmf\+\_\+mult\+\_\+div.\+hpp.

\index{mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Divergence\+Update@{mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Divergence\+Update}!Serialize@{Serialize}}
\index{Serialize@{Serialize}!mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Divergence\+Update@{mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Divergence\+Update}}
\subsubsection[{Serialize(\+Archive \&, const unsigned int)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Archive $>$ void mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Divergence\+Update\+::\+Serialize (
\begin{DoxyParamCaption}
\item[{Archive \&}]{, }
\item[{const unsigned}]{int}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1amf_1_1NMFMultiplicativeDivergenceUpdate_ad9da2750641b65e8c534edb0eb6323b8}


Serialize the object (in this case, there is nothing to serialize). 



Definition at line 154 of file nmf\+\_\+mult\+\_\+div.\+hpp.

\index{mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Divergence\+Update@{mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Divergence\+Update}!W\+Update@{W\+Update}}
\index{W\+Update@{W\+Update}!mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Divergence\+Update@{mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Divergence\+Update}}
\subsubsection[{W\+Update(const Mat\+Type \&\+V, arma\+::mat \&\+W, const arma\+::mat \&\+H)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Mat\+Type $>$ static void mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Divergence\+Update\+::\+W\+Update (
\begin{DoxyParamCaption}
\item[{const Mat\+Type \&}]{V, }
\item[{arma\+::mat \&}]{W, }
\item[{const arma\+::mat \&}]{H}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\label{classmlpack_1_1amf_1_1NMFMultiplicativeDivergenceUpdate_a9d17481f4277050bc0cfe4d2fddb54d8}


The update rule for the basis matrix W. 

The formula used is

\[ W_{ia} \leftarrow W_{ia} \frac{\sum_{\mu} H_{a\mu} V_{i\mu} / (W H)_{i\mu}} {\sum_{\nu} H_{a\nu}} \]

The function takes in all the matrices and only changes the value of the W matrix.


\begin{DoxyParams}{Parameters}
{\em V} & Input matrix to be factorized. \\
\hline
{\em W} & Basis matrix to be updated. \\
\hline
{\em H} & Encoding matrix. \\
\hline
\end{DoxyParams}


Definition at line 80 of file nmf\+\_\+mult\+\_\+div.\+hpp.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/mlpack/methods/amf/update\+\_\+rules/{\bf nmf\+\_\+mult\+\_\+div.\+hpp}\end{DoxyCompactItemize}
