
.. _program_listing_file__home_aakash_mlpack_src_mlpack_core_util_sfinae_utility.hpp:

Program Listing for File sfinae_utility.hpp
===========================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_aakash_mlpack_src_mlpack_core_util_sfinae_utility.hpp>` (``/home/aakash/mlpack/src/mlpack/core/util/sfinae_utility.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   
   #ifndef MLPACK_CORE_SFINAE_UTILITY
   #define MLPACK_CORE_SFINAE_UTILITY
   
   #include <type_traits>
   #include <cstring>
   
   namespace mlpack {
   namespace sfinae {
   
   /*
    * MethodFormDetector is a tool that helps to find out whether a given class has
    * a method of the requested form. For that purpose MethodFormDetector defines
    * an operator() that accepts a class member pointer for the given class. If the
    * operator()(&Class::Method) call can be compiled, then the given class has a
    * method of the requested form. For any provided AdditionalArgsCount, the check
    * succeeds only if the given class has exactly one method of the requested form
    * with AdditionalArgsCount additional arguments.
    *
    * The tool is dedicated to be used in type functions (structs) generated by the
    * macro HAS_METHOD_FORM.
    *
    * @tparam MethodForm A template class member pointer type to a method of the
    *   form to look for.
    * @tparam Class A class in which a method of the requested form should be
    *   looked for.
    * @tparam AdditionalArgsCount A number of additional arguments.
    */
   template<typename Class,
            template<typename...> class MethodForm,
            size_t AdditionalArgsCount>
   struct MethodFormDetector;
   
   template<typename Class, template<typename...> class MethodForm>
   struct MethodFormDetector<Class, MethodForm, 0>
   {
     void operator()(MethodForm<Class>);
   };
   
   template<typename Class, template<typename...> class MethodForm>
   struct MethodFormDetector<Class, MethodForm, 1>
   {
     template<class T1>
     void operator()(MethodForm<Class, T1>);
   };
   
   template<typename Class, template<typename...> class MethodForm>
   struct MethodFormDetector<Class, MethodForm, 2>
   {
     template<class T1, class T2>
     void operator()(MethodForm<Class, T1, T2>);
   };
   
   template<typename Class, template<typename...> class MethodForm>
   struct MethodFormDetector<Class, MethodForm, 3>
   {
     template<class T1, class T2, class T3>
     void operator()(MethodForm<Class, T1, T2, T3>);
   };
   
   template<typename Class, template<typename...> class MethodForm>
   struct MethodFormDetector<Class, MethodForm, 4>
   {
     template<class T1, class T2, class T3, class T4>
     void operator()(MethodForm<Class, T1, T2, T3, T4>);
   };
   
   template<typename Class, template<typename...> class MethodForm>
   struct MethodFormDetector<Class, MethodForm, 5>
   {
     template<class T1, class T2, class T3, class T4, class T5>
     void operator()(MethodForm<Class, T1, T2, T3, T4, T5>);
   };
   
   template<typename Class, template<typename...> class MethodForm>
   struct MethodFormDetector<Class, MethodForm, 6>
   {
     template<class T1, class T2, class T3, class T4, class T5, class T6>
     void operator()(MethodForm<Class, T1, T2, T3, T4, T5, T6>);
   };
   
   template<typename Class, template<typename...> class MethodForm>
   struct MethodFormDetector<Class, MethodForm, 7>
   {
     template<class T1, class T2, class T3, class T4, class T5, class T6, class T7>
     void operator()(MethodForm<Class, T1, T2, T3, T4, T5, T6, T7>);
   };
   
   template<typename U, U> struct SigCheck : std::true_type {};
   
   } // namespace sfinae
   } // namespace mlpack
   
   
   
   /*
    * Constructs a template supporting the SFINAE pattern.
    *
    * This macro generates a template struct that is useful for enabling/disabling
    * a method if the template class passed in contains a member function matching
    * a given signature with a specified name.
    *
    * The generated struct should be used in conjunction with std::enable_if_t.
    *
    * For general references, see:
    * http://stackoverflow.com/a/264088/391618
    *
    * For an mlpack specific use case, see /mlpack/core/util/prefixedoutstream.hpp
    * and /mlpack/core/util/prefixedoutstream_impl.hpp
    *
    * @param NAME the name of the struct to construct. For example: HasToString
    * @param FUNC the name of the function to check for. For example: ToString
    */
   #define HAS_MEM_FUNC(FUNC, NAME)                                               \
   template<typename T, typename sig, typename = std::true_type>                  \
   struct NAME : std::false_type {};                                              \
                                                                                  \
   template<typename T, typename sig>                                             \
   struct NAME                                                                    \
   <                                                                              \
     T,                                                                           \
     sig,                                                                         \
     std::integral_constant<bool, mlpack::sfinae::SigCheck<sig, &T::FUNC>::value> \
   > : std::true_type {};
   
   #define HAS_METHOD_FORM_BASE(METHOD, NAME, MAXN)                               \
   template<typename Class,                                                       \
            template<typename...> class MF /* MethodForm */,                      \
            size_t MinN = 0 /* MinNumberOfAdditionalArgs */>                      \
   struct NAME                                                                    \
   {                                                                              \
     /* Making a short alias for MethodFormDetector */                            \
     template<typename C, template<typename...> class MethodForm, int N>          \
     using MFD = mlpack::sfinae::MethodFormDetector<C, MethodForm, N>;            \
                                                                                  \
     template<size_t N>                                                           \
     struct WithNAdditionalArgs                                                   \
     {                                                                            \
       using yes = char[1];                                                       \
       using no = char[2];                                                        \
                                                                                  \
       template<typename T, typename ResultType>                                  \
       using EnableIfVoid =                                                       \
           typename std::enable_if<std::is_void<T>::value, ResultType>::type;     \
                                                                                  \
       template<typename C>                                                       \
       static EnableIfVoid<decltype(MFD<C, MF, N>()(&C::METHOD)), yes&> chk(int); \
       template<typename>                                                         \
       static no& chk(...);                                                       \
                                                                                  \
       static const bool value = sizeof(chk<Class>(0)) == sizeof(yes);            \
     };                                                                           \
                                                                                  \
     template<size_t N>                                                           \
     struct WithGreaterOrEqualNumberOfAdditionalArgs                              \
     {                                                                            \
       using type = typename std::conditional<                                    \
           WithNAdditionalArgs<N>::value,                                         \
           std::true_type,                                                        \
           typename std::conditional<                                             \
               N < MAXN,                                                          \
               WithGreaterOrEqualNumberOfAdditionalArgs<N + 1>,                   \
               std::false_type>::type>::type;                                     \
       static const bool value = type::value;                                     \
     };                                                                           \
                                                                                  \
     static const bool value =                                                    \
         WithGreaterOrEqualNumberOfAdditionalArgs<MinN>::value;                   \
   };
   
   #define HAS_ANY_METHOD_FORM(FUNC, NAME)                                      \
   template <typename T>                                                        \
   struct NAME                                                                  \
   {                                                                            \
     template <typename Q = T>                                                  \
     static typename                                                            \
     std::enable_if<std::is_member_function_pointer<decltype(&Q::FUNC)>::value, \
                    int>::type                                                  \
     f(int) { return 1;}                                                      \
                                                                                \
     template <typename Q = T>                                                  \
     static char f(char) { return 0; }                                        \
                                                                                \
     static const bool value = sizeof(f<T>(0)) != sizeof(char);                 \
   };
   /*
    * A macro that can be used for passing arguments containing commas to other
    * macros.
    */
   #define SINGLE_ARG(...) __VA_ARGS__
   
   #define HAS_METHOD_FORM(METHOD, NAME) \
       HAS_METHOD_FORM_BASE(SINGLE_ARG(METHOD), SINGLE_ARG(NAME), 7)
   
   #define HAS_EXACT_METHOD_FORM(METHOD, NAME) \
       HAS_METHOD_FORM_BASE(SINGLE_ARG(METHOD), SINGLE_ARG(NAME), 0)
   
   #endif
