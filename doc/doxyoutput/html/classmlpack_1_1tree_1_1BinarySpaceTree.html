<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>mlpack: BinarySpaceTree&lt; MetricType, StatisticType, MatType, BoundType, SplitType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra-stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">mlpack
   &#160;<span id="projectnumber">3.4.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlpack.html">mlpack</a></li><li class="navelem"><a class="el" href="namespacemlpack_1_1tree.html">tree</a></li><li class="navelem"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classmlpack_1_1tree_1_1BinarySpaceTree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">BinarySpaceTree&lt; MetricType, StatisticType, MatType, BoundType, SplitType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A binary space partitioning tree, such as a KD-tree or a ball tree.  
 <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree_1_1BreadthFirstDualTreeTraverser.html">BreadthFirstDualTreeTraverser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree_1_1DualTreeTraverser.html">DualTreeTraverser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dual-tree traverser for binary space trees; see dual_tree_traverser.hpp.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree_1_1DualTreeTraverser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree_1_1SingleTreeTraverser.html">SingleTreeTraverser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single-tree traverser for binary space trees; see single_tree_traverser.hpp for implementation.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree_1_1SingleTreeTraverser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a227d0c7e23e98fcd6c81ecab357a791f"><td class="memItemLeft" align="right" valign="top">typedef MatType::elem_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a></td></tr>
<tr class="memdesc:a227d0c7e23e98fcd6c81ecab357a791f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of element held in MatType.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a227d0c7e23e98fcd6c81ecab357a791f">More...</a><br /></td></tr>
<tr class="separator:a227d0c7e23e98fcd6c81ecab357a791f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57758caa2e58c3fe05d1284eeabae523"><td class="memItemLeft" align="right" valign="top">typedef MatType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a57758caa2e58c3fe05d1284eeabae523">Mat</a></td></tr>
<tr class="memdesc:a57758caa2e58c3fe05d1284eeabae523"><td class="mdescLeft">&#160;</td><td class="mdescRight">So other classes can use TreeType::Mat.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a57758caa2e58c3fe05d1284eeabae523">More...</a><br /></td></tr>
<tr class="separator:a57758caa2e58c3fe05d1284eeabae523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fbe69d8cb6be0a0735b5df955708ade"><td class="memItemLeft" align="right" valign="top">typedef SplitType&lt; BoundType&lt; MetricType &gt;, MatType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a2fbe69d8cb6be0a0735b5df955708ade">Split</a></td></tr>
<tr class="separator:a2fbe69d8cb6be0a0735b5df955708ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7f027dcf721e6e54ad0b5b63504cf057"><td class="memTemplParams" colspan="2">template&lt;typename Archive &gt; </td></tr>
<tr class="memitem:a7f027dcf721e6e54ad0b5b63504cf057"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a7f027dcf721e6e54ad0b5b63504cf057">BinarySpaceTree</a> (Archive &amp;ar, const typename <a class="el" href="namespacestd.html#a93e9cb7fadbcfaa2afb5b94058b8e34c">std::enable_if_t</a>&lt; <a class="el" href="namespacecereal.html#ad79f9b690399d7e8aad9e7fc9ef3b797">cereal::is_loading</a>&lt; Archive &gt;()&gt; *=0)</td></tr>
<tr class="memdesc:a7f027dcf721e6e54ad0b5b63504cf057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the tree from a cereal archive.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a7f027dcf721e6e54ad0b5b63504cf057">More...</a><br /></td></tr>
<tr class="separator:a7f027dcf721e6e54ad0b5b63504cf057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50dd4753fb64883537125f80f5dfc273"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a50dd4753fb64883537125f80f5dfc273">BinarySpaceTree</a> (<a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a50dd4753fb64883537125f80f5dfc273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor for a <a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html" title="A binary space partitioning tree, such as a KD-tree or a ball tree.">BinarySpaceTree</a>; possess all the members of the given tree.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a50dd4753fb64883537125f80f5dfc273">More...</a><br /></td></tr>
<tr class="separator:a50dd4753fb64883537125f80f5dfc273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a820092388341845e2a8927478215e476"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a820092388341845e2a8927478215e476">BinarySpaceTree</a> (<a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a> *parent, const size_t begin, const size_t count, SplitType&lt; BoundType&lt; MetricType &gt;, MatType &gt; &amp;splitter, const size_t maxLeafSize=20)</td></tr>
<tr class="memdesc:a820092388341845e2a8927478215e476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct this node as a child of the given parent, starting at column begin and using count points.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a820092388341845e2a8927478215e476">More...</a><br /></td></tr>
<tr class="separator:a820092388341845e2a8927478215e476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79c1b69a1dc4ac4d654c43e0d1a1981"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#ae79c1b69a1dc4ac4d654c43e0d1a1981">BinarySpaceTree</a> (<a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a> *parent, const size_t begin, const size_t count, std::vector&lt; size_t &gt; &amp;oldFromNew, SplitType&lt; BoundType&lt; MetricType &gt;, MatType &gt; &amp;splitter, const size_t maxLeafSize=20)</td></tr>
<tr class="memdesc:ae79c1b69a1dc4ac4d654c43e0d1a1981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct this node as a child of the given parent, starting at column begin and using count points.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#ae79c1b69a1dc4ac4d654c43e0d1a1981">More...</a><br /></td></tr>
<tr class="separator:ae79c1b69a1dc4ac4d654c43e0d1a1981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae1fbad0d2639fb7bd63aac6b6a998f1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#aae1fbad0d2639fb7bd63aac6b6a998f1">BinarySpaceTree</a> (<a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a> *parent, const size_t begin, const size_t count, std::vector&lt; size_t &gt; &amp;oldFromNew, std::vector&lt; size_t &gt; &amp;newFromOld, SplitType&lt; BoundType&lt; MetricType &gt;, MatType &gt; &amp;splitter, const size_t maxLeafSize=20)</td></tr>
<tr class="memdesc:aae1fbad0d2639fb7bd63aac6b6a998f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct this node as a child of the given parent, starting at column begin and using count points.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#aae1fbad0d2639fb7bd63aac6b6a998f1">More...</a><br /></td></tr>
<tr class="separator:aae1fbad0d2639fb7bd63aac6b6a998f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32dee7101946c7d2393cc13c8d65899f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a32dee7101946c7d2393cc13c8d65899f">BinarySpaceTree</a> (const <a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a> &amp;other)</td></tr>
<tr class="memdesc:a32dee7101946c7d2393cc13c8d65899f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a binary space tree by copying the other tree.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a32dee7101946c7d2393cc13c8d65899f">More...</a><br /></td></tr>
<tr class="separator:a32dee7101946c7d2393cc13c8d65899f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a360d6a8e92c66e9c2d985b528071e93e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a360d6a8e92c66e9c2d985b528071e93e">BinarySpaceTree</a> (const MatType &amp;data, const size_t maxLeafSize=20)</td></tr>
<tr class="memdesc:a360d6a8e92c66e9c2d985b528071e93e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct this as the root node of a binary space tree using the given dataset.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a360d6a8e92c66e9c2d985b528071e93e">More...</a><br /></td></tr>
<tr class="separator:a360d6a8e92c66e9c2d985b528071e93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38fc3cb2dd94cbd130f0444b3b06355b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a38fc3cb2dd94cbd130f0444b3b06355b">BinarySpaceTree</a> (const MatType &amp;data, std::vector&lt; size_t &gt; &amp;oldFromNew, const size_t maxLeafSize=20)</td></tr>
<tr class="memdesc:a38fc3cb2dd94cbd130f0444b3b06355b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct this as the root node of a binary space tree using the given dataset.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a38fc3cb2dd94cbd130f0444b3b06355b">More...</a><br /></td></tr>
<tr class="separator:a38fc3cb2dd94cbd130f0444b3b06355b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842ae235a817cfb9c7a5a456e7d78292"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a842ae235a817cfb9c7a5a456e7d78292">BinarySpaceTree</a> (const MatType &amp;data, std::vector&lt; size_t &gt; &amp;oldFromNew, std::vector&lt; size_t &gt; &amp;newFromOld, const size_t maxLeafSize=20)</td></tr>
<tr class="memdesc:a842ae235a817cfb9c7a5a456e7d78292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct this as the root node of a binary space tree using the given dataset.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a842ae235a817cfb9c7a5a456e7d78292">More...</a><br /></td></tr>
<tr class="separator:a842ae235a817cfb9c7a5a456e7d78292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ee8af5482a265fe2b7edc8bb3efdce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a49ee8af5482a265fe2b7edc8bb3efdce">BinarySpaceTree</a> (MatType &amp;&amp;data, const size_t maxLeafSize=20)</td></tr>
<tr class="memdesc:a49ee8af5482a265fe2b7edc8bb3efdce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct this as the root node of a binary space tree using the given dataset.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a49ee8af5482a265fe2b7edc8bb3efdce">More...</a><br /></td></tr>
<tr class="separator:a49ee8af5482a265fe2b7edc8bb3efdce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3753895793f9161d2793fd7b326b821d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a3753895793f9161d2793fd7b326b821d">BinarySpaceTree</a> (MatType &amp;&amp;data, std::vector&lt; size_t &gt; &amp;oldFromNew, const size_t maxLeafSize=20)</td></tr>
<tr class="memdesc:a3753895793f9161d2793fd7b326b821d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct this as the root node of a binary space tree using the given dataset.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a3753895793f9161d2793fd7b326b821d">More...</a><br /></td></tr>
<tr class="separator:a3753895793f9161d2793fd7b326b821d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb64c00419354018fa1cd0ceb4f2eee5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#abb64c00419354018fa1cd0ceb4f2eee5">BinarySpaceTree</a> (MatType &amp;&amp;data, std::vector&lt; size_t &gt; &amp;oldFromNew, std::vector&lt; size_t &gt; &amp;newFromOld, const size_t maxLeafSize=20)</td></tr>
<tr class="memdesc:abb64c00419354018fa1cd0ceb4f2eee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct this as the root node of a binary space tree using the given dataset.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#abb64c00419354018fa1cd0ceb4f2eee5">More...</a><br /></td></tr>
<tr class="separator:abb64c00419354018fa1cd0ceb4f2eee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07a273ce37bd373995e13b3ef276265"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#ae07a273ce37bd373995e13b3ef276265">~BinarySpaceTree</a> ()</td></tr>
<tr class="memdesc:ae07a273ce37bd373995e13b3ef276265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes this node, deallocating the memory for the children and calling their destructors in turn.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#ae07a273ce37bd373995e13b3ef276265">More...</a><br /></td></tr>
<tr class="separator:ae07a273ce37bd373995e13b3ef276265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49cdbf8b1b2899522cd80f4cbff40b69"><td class="memItemLeft" align="right" valign="top">size_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a49cdbf8b1b2899522cd80f4cbff40b69">Begin</a> ()</td></tr>
<tr class="memdesc:a49cdbf8b1b2899522cd80f4cbff40b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the index of the beginning point of this subset.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a49cdbf8b1b2899522cd80f4cbff40b69">More...</a><br /></td></tr>
<tr class="separator:a49cdbf8b1b2899522cd80f4cbff40b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50a3a009687e641fd8249e011f628d4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#ac50a3a009687e641fd8249e011f628d4">Begin</a> () const</td></tr>
<tr class="memdesc:ac50a3a009687e641fd8249e011f628d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of the beginning point of this subset.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#ac50a3a009687e641fd8249e011f628d4">More...</a><br /></td></tr>
<tr class="separator:ac50a3a009687e641fd8249e011f628d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1023b24dcb81cc1769a8698d0ac8b7ed"><td class="memItemLeft" align="right" valign="top">BoundType&lt; MetricType &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a1023b24dcb81cc1769a8698d0ac8b7ed">Bound</a> ()</td></tr>
<tr class="memdesc:a1023b24dcb81cc1769a8698d0ac8b7ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bound object for this node.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a1023b24dcb81cc1769a8698d0ac8b7ed">More...</a><br /></td></tr>
<tr class="separator:a1023b24dcb81cc1769a8698d0ac8b7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae995f23d597849b8b3fa165765921914"><td class="memItemLeft" align="right" valign="top">const BoundType&lt; MetricType &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#ae995f23d597849b8b3fa165765921914">Bound</a> () const</td></tr>
<tr class="memdesc:ae995f23d597849b8b3fa165765921914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bound object for this node.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#ae995f23d597849b8b3fa165765921914">More...</a><br /></td></tr>
<tr class="separator:ae995f23d597849b8b3fa165765921914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa800439660375c0253008cafa648da78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#aa800439660375c0253008cafa648da78">Center</a> (arma::vec &amp;center) const</td></tr>
<tr class="memdesc:aa800439660375c0253008cafa648da78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the center of the bounding region in the given vector.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#aa800439660375c0253008cafa648da78">More...</a><br /></td></tr>
<tr class="separator:aa800439660375c0253008cafa648da78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf9f074d6e3c683213f5f17acfbc6f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a2cf9f074d6e3c683213f5f17acfbc6f7">Child</a> (const size_t child) const</td></tr>
<tr class="memdesc:a2cf9f074d6e3c683213f5f17acfbc6f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified child (0 will be left, 1 will be right).  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a2cf9f074d6e3c683213f5f17acfbc6f7">More...</a><br /></td></tr>
<tr class="separator:a2cf9f074d6e3c683213f5f17acfbc6f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb373eeb13db5a753ec52ea56ec5a9cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a> *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#acb373eeb13db5a753ec52ea56ec5a9cd">ChildPtr</a> (const size_t child)</td></tr>
<tr class="separator:acb373eeb13db5a753ec52ea56ec5a9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a132e068ab206a014b986ff71c3442d"><td class="memItemLeft" align="right" valign="top">size_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a5a132e068ab206a014b986ff71c3442d">Count</a> ()</td></tr>
<tr class="memdesc:a5a132e068ab206a014b986ff71c3442d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the number of points in this subset.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a5a132e068ab206a014b986ff71c3442d">More...</a><br /></td></tr>
<tr class="separator:a5a132e068ab206a014b986ff71c3442d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30fd361b8bee994ff8ed9fbb6fae845"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#ab30fd361b8bee994ff8ed9fbb6fae845">Count</a> () const</td></tr>
<tr class="memdesc:ab30fd361b8bee994ff8ed9fbb6fae845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of points in this subset.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#ab30fd361b8bee994ff8ed9fbb6fae845">More...</a><br /></td></tr>
<tr class="separator:ab30fd361b8bee994ff8ed9fbb6fae845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb34576c3ddb31987f1dda9c33e6476f"><td class="memItemLeft" align="right" valign="top">MatType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#abb34576c3ddb31987f1dda9c33e6476f">Dataset</a> ()</td></tr>
<tr class="memdesc:abb34576c3ddb31987f1dda9c33e6476f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the dataset which the tree is built on. Be careful!  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#abb34576c3ddb31987f1dda9c33e6476f">More...</a><br /></td></tr>
<tr class="separator:abb34576c3ddb31987f1dda9c33e6476f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c3764c98d5804083a9ec2c867eb9366"><td class="memItemLeft" align="right" valign="top">const MatType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a4c3764c98d5804083a9ec2c867eb9366">Dataset</a> () const</td></tr>
<tr class="memdesc:a4c3764c98d5804083a9ec2c867eb9366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dataset which the tree is built on.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a4c3764c98d5804083a9ec2c867eb9366">More...</a><br /></td></tr>
<tr class="separator:a4c3764c98d5804083a9ec2c867eb9366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa732ea3eeb38529c549fd4d15d8655be"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#aa732ea3eeb38529c549fd4d15d8655be">Descendant</a> (const size_t index) const</td></tr>
<tr class="memdesc:aa732ea3eeb38529c549fd4d15d8655be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index (with reference to the dataset) of a particular descendant of this node.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#aa732ea3eeb38529c549fd4d15d8655be">More...</a><br /></td></tr>
<tr class="separator:aa732ea3eeb38529c549fd4d15d8655be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc597088eadfcfa3060336d0484ab573"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#adc597088eadfcfa3060336d0484ab573">FurthestDescendantDistance</a> () const</td></tr>
<tr class="memdesc:adc597088eadfcfa3060336d0484ab573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the furthest possible descendant distance.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#adc597088eadfcfa3060336d0484ab573">More...</a><br /></td></tr>
<tr class="separator:adc597088eadfcfa3060336d0484ab573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe82a6439f71405b5801ca7d941cbfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#acbe82a6439f71405b5801ca7d941cbfb">FurthestPointDistance</a> () const</td></tr>
<tr class="memdesc:acbe82a6439f71405b5801ca7d941cbfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the furthest distance to a point held in this node.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#acbe82a6439f71405b5801ca7d941cbfb">More...</a><br /></td></tr>
<tr class="separator:acbe82a6439f71405b5801ca7d941cbfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c2b878b5dd46d80b333542f97bd86d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a03c2b878b5dd46d80b333542f97bd86d">GetFurthestChild</a> (const <a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a> &amp;queryNode)</td></tr>
<tr class="memdesc:a03c2b878b5dd46d80b333542f97bd86d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of the furthest child node to the given query node.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a03c2b878b5dd46d80b333542f97bd86d">More...</a><br /></td></tr>
<tr class="separator:a03c2b878b5dd46d80b333542f97bd86d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0257281722537c7916db7763623f67f7"><td class="memTemplParams" colspan="2">template&lt;typename VecType &gt; </td></tr>
<tr class="memitem:a0257281722537c7916db7763623f67f7"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a0257281722537c7916db7763623f67f7">GetFurthestChild</a> (const VecType &amp;point, typename <a class="el" href="namespacestd.html#a93e9cb7fadbcfaa2afb5b94058b8e34c">std::enable_if_t</a>&lt; <a class="el" href="structIsVector.html">IsVector</a>&lt; VecType &gt;::value &gt; *=0)</td></tr>
<tr class="memdesc:a0257281722537c7916db7763623f67f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of the furthest child node to the given query point.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a0257281722537c7916db7763623f67f7">More...</a><br /></td></tr>
<tr class="separator:a0257281722537c7916db7763623f67f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f18fdc176329c127d97aa7d08d4b7a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a45f18fdc176329c127d97aa7d08d4b7a">GetNearestChild</a> (const <a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a> &amp;queryNode)</td></tr>
<tr class="memdesc:a45f18fdc176329c127d97aa7d08d4b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of the nearest child node to the given query node.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a45f18fdc176329c127d97aa7d08d4b7a">More...</a><br /></td></tr>
<tr class="separator:a45f18fdc176329c127d97aa7d08d4b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b9a5fd41d8e192b62effb1445bd410"><td class="memTemplParams" colspan="2">template&lt;typename VecType &gt; </td></tr>
<tr class="memitem:a19b9a5fd41d8e192b62effb1445bd410"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a19b9a5fd41d8e192b62effb1445bd410">GetNearestChild</a> (const VecType &amp;point, typename <a class="el" href="namespacestd.html#a93e9cb7fadbcfaa2afb5b94058b8e34c">std::enable_if_t</a>&lt; <a class="el" href="structIsVector.html">IsVector</a>&lt; VecType &gt;::value &gt; *=0)</td></tr>
<tr class="memdesc:a19b9a5fd41d8e192b62effb1445bd410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of the nearest child node to the given query point.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a19b9a5fd41d8e192b62effb1445bd410">More...</a><br /></td></tr>
<tr class="separator:a19b9a5fd41d8e192b62effb1445bd410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f4813924e6cdee43b45050bb947abe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#aa0f4813924e6cdee43b45050bb947abe">IsLeaf</a> () const</td></tr>
<tr class="memdesc:aa0f4813924e6cdee43b45050bb947abe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether or not this node is a leaf (true if it has no children).  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#aa0f4813924e6cdee43b45050bb947abe">More...</a><br /></td></tr>
<tr class="separator:aa0f4813924e6cdee43b45050bb947abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ddd6024d9d85e1e0d7e59b8533897a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a> *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a5ddd6024d9d85e1e0d7e59b8533897a7">Left</a> ()</td></tr>
<tr class="memdesc:a5ddd6024d9d85e1e0d7e59b8533897a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the left child of this node.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a5ddd6024d9d85e1e0d7e59b8533897a7">More...</a><br /></td></tr>
<tr class="separator:a5ddd6024d9d85e1e0d7e59b8533897a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3085061e078694745cf2f59a77f982c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a3085061e078694745cf2f59a77f982c3">Left</a> () const</td></tr>
<tr class="memdesc:a3085061e078694745cf2f59a77f982c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the left child of this node.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a3085061e078694745cf2f59a77f982c3">More...</a><br /></td></tr>
<tr class="separator:a3085061e078694745cf2f59a77f982c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d3f7fc53a6113f14949dc05d747992"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a29d3f7fc53a6113f14949dc05d747992">MaxDistance</a> (const <a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a> &amp;other) const</td></tr>
<tr class="memdesc:a29d3f7fc53a6113f14949dc05d747992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum distance to another node.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a29d3f7fc53a6113f14949dc05d747992">More...</a><br /></td></tr>
<tr class="separator:a29d3f7fc53a6113f14949dc05d747992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae764d88483236cc470f5abe0273df4c5"><td class="memTemplParams" colspan="2">template&lt;typename VecType &gt; </td></tr>
<tr class="memitem:ae764d88483236cc470f5abe0273df4c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#ae764d88483236cc470f5abe0273df4c5">MaxDistance</a> (const VecType &amp;point, typename <a class="el" href="namespacestd.html#a93e9cb7fadbcfaa2afb5b94058b8e34c">std::enable_if_t</a>&lt; <a class="el" href="structIsVector.html">IsVector</a>&lt; VecType &gt;::value &gt; *=0) const</td></tr>
<tr class="memdesc:ae764d88483236cc470f5abe0273df4c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum distance to another point.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#ae764d88483236cc470f5abe0273df4c5">More...</a><br /></td></tr>
<tr class="separator:ae764d88483236cc470f5abe0273df4c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7cdd810a507e4a0aa262ea0fa8a322c"><td class="memItemLeft" align="right" valign="top">MetricType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#ab7cdd810a507e4a0aa262ea0fa8a322c">Metric</a> () const</td></tr>
<tr class="memdesc:ab7cdd810a507e4a0aa262ea0fa8a322c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the metric that the tree uses.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#ab7cdd810a507e4a0aa262ea0fa8a322c">More...</a><br /></td></tr>
<tr class="separator:ab7cdd810a507e4a0aa262ea0fa8a322c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a080f6b6c8d4336ff1ead4f0d0f6a0cb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a080f6b6c8d4336ff1ead4f0d0f6a0cb5">MinDistance</a> (const <a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a> &amp;other) const</td></tr>
<tr class="memdesc:a080f6b6c8d4336ff1ead4f0d0f6a0cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum distance to another node.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a080f6b6c8d4336ff1ead4f0d0f6a0cb5">More...</a><br /></td></tr>
<tr class="separator:a080f6b6c8d4336ff1ead4f0d0f6a0cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73bf99a433e88a31d98b46bf4c0da147"><td class="memTemplParams" colspan="2">template&lt;typename VecType &gt; </td></tr>
<tr class="memitem:a73bf99a433e88a31d98b46bf4c0da147"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a73bf99a433e88a31d98b46bf4c0da147">MinDistance</a> (const VecType &amp;point, typename <a class="el" href="namespacestd.html#a93e9cb7fadbcfaa2afb5b94058b8e34c">std::enable_if_t</a>&lt; <a class="el" href="structIsVector.html">IsVector</a>&lt; VecType &gt;::value &gt; *=0) const</td></tr>
<tr class="memdesc:a73bf99a433e88a31d98b46bf4c0da147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum distance to another point.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a73bf99a433e88a31d98b46bf4c0da147">More...</a><br /></td></tr>
<tr class="separator:a73bf99a433e88a31d98b46bf4c0da147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a4e92da6066eb335a576b7f9cd0415"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a20a4e92da6066eb335a576b7f9cd0415">MinimumBoundDistance</a> () const</td></tr>
<tr class="memdesc:a20a4e92da6066eb335a576b7f9cd0415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum distance from the center of the node to any bound edge.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a20a4e92da6066eb335a576b7f9cd0415">More...</a><br /></td></tr>
<tr class="separator:a20a4e92da6066eb335a576b7f9cd0415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7ec083be66d58a3e02e12956bf005e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a1f7ec083be66d58a3e02e12956bf005e">NumChildren</a> () const</td></tr>
<tr class="memdesc:a1f7ec083be66d58a3e02e12956bf005e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of children in this node.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a1f7ec083be66d58a3e02e12956bf005e">More...</a><br /></td></tr>
<tr class="separator:a1f7ec083be66d58a3e02e12956bf005e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a85eb34222f1fc073940e8c89274e81"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a2a85eb34222f1fc073940e8c89274e81">NumDescendants</a> () const</td></tr>
<tr class="memdesc:a2a85eb34222f1fc073940e8c89274e81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of descendants of this node.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a2a85eb34222f1fc073940e8c89274e81">More...</a><br /></td></tr>
<tr class="separator:a2a85eb34222f1fc073940e8c89274e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352077c26368da0ee570c0b7f062b1e3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a352077c26368da0ee570c0b7f062b1e3">NumPoints</a> () const</td></tr>
<tr class="memdesc:a352077c26368da0ee570c0b7f062b1e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of points in this node (0 if not a leaf).  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a352077c26368da0ee570c0b7f062b1e3">More...</a><br /></td></tr>
<tr class="separator:a352077c26368da0ee570c0b7f062b1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace087a2c1ab4214c229b36edd4444ea7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#ace087a2c1ab4214c229b36edd4444ea7">operator=</a> (<a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:ace087a2c1ab4214c229b36edd4444ea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take ownership of the given <a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html" title="A binary space partitioning tree, such as a KD-tree or a ball tree.">BinarySpaceTree</a>.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#ace087a2c1ab4214c229b36edd4444ea7">More...</a><br /></td></tr>
<tr class="separator:ace087a2c1ab4214c229b36edd4444ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d6befceee3f4a7cda868bfeb3bf8f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a11d6befceee3f4a7cda868bfeb3bf8f9">operator=</a> (const <a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a> &amp;other)</td></tr>
<tr class="memdesc:a11d6befceee3f4a7cda868bfeb3bf8f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the given BinarySaceTree.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a11d6befceee3f4a7cda868bfeb3bf8f9">More...</a><br /></td></tr>
<tr class="separator:a11d6befceee3f4a7cda868bfeb3bf8f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a632e02a7a7f3eda4fe6d4fa5bc69b832"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a> *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a632e02a7a7f3eda4fe6d4fa5bc69b832">Parent</a> ()</td></tr>
<tr class="memdesc:a632e02a7a7f3eda4fe6d4fa5bc69b832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the parent of this node.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a632e02a7a7f3eda4fe6d4fa5bc69b832">More...</a><br /></td></tr>
<tr class="separator:a632e02a7a7f3eda4fe6d4fa5bc69b832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe2ac60bc77d318c2dba58b43f18a245"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#abe2ac60bc77d318c2dba58b43f18a245">Parent</a> () const</td></tr>
<tr class="memdesc:abe2ac60bc77d318c2dba58b43f18a245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the parent of this node.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#abe2ac60bc77d318c2dba58b43f18a245">More...</a><br /></td></tr>
<tr class="separator:abe2ac60bc77d318c2dba58b43f18a245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22ead21ac809efb970b90ec014dc318"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#aa22ead21ac809efb970b90ec014dc318">ParentDistance</a> ()</td></tr>
<tr class="memdesc:aa22ead21ac809efb970b90ec014dc318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the distance from the center of this node to the center of the parent node.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#aa22ead21ac809efb970b90ec014dc318">More...</a><br /></td></tr>
<tr class="separator:aa22ead21ac809efb970b90ec014dc318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44ed4e7bfea088689caed082da67e17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#af44ed4e7bfea088689caed082da67e17">ParentDistance</a> () const</td></tr>
<tr class="memdesc:af44ed4e7bfea088689caed082da67e17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the distance from the center of this node to the center of the parent node.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#af44ed4e7bfea088689caed082da67e17">More...</a><br /></td></tr>
<tr class="separator:af44ed4e7bfea088689caed082da67e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559eede5ea60f68634f8e7e72c3c68d2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a559eede5ea60f68634f8e7e72c3c68d2">Point</a> (const size_t index) const</td></tr>
<tr class="memdesc:a559eede5ea60f68634f8e7e72c3c68d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index (with reference to the dataset) of a particular point in this node.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a559eede5ea60f68634f8e7e72c3c68d2">More...</a><br /></td></tr>
<tr class="separator:a559eede5ea60f68634f8e7e72c3c68d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a186a488e372175c6f8499115c9add8b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1math_1_1RangeType.html">math::RangeType</a>&lt; <a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a186a488e372175c6f8499115c9add8b4">RangeDistance</a> (const <a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a> &amp;other) const</td></tr>
<tr class="memdesc:a186a488e372175c6f8499115c9add8b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum and maximum distance to another node.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a186a488e372175c6f8499115c9add8b4">More...</a><br /></td></tr>
<tr class="separator:a186a488e372175c6f8499115c9add8b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a550bf46aa1d7b858134ce41fd5a3a"><td class="memTemplParams" colspan="2">template&lt;typename VecType &gt; </td></tr>
<tr class="memitem:a60a550bf46aa1d7b858134ce41fd5a3a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1math_1_1RangeType.html">math::RangeType</a>&lt; <a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a60a550bf46aa1d7b858134ce41fd5a3a">RangeDistance</a> (const VecType &amp;point, typename <a class="el" href="namespacestd.html#a93e9cb7fadbcfaa2afb5b94058b8e34c">std::enable_if_t</a>&lt; <a class="el" href="structIsVector.html">IsVector</a>&lt; VecType &gt;::value &gt; *=0) const</td></tr>
<tr class="memdesc:a60a550bf46aa1d7b858134ce41fd5a3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum and maximum distance to another point.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a60a550bf46aa1d7b858134ce41fd5a3a">More...</a><br /></td></tr>
<tr class="separator:a60a550bf46aa1d7b858134ce41fd5a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c50c4ae4876df5d346da693c37ae02f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a> *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a6c50c4ae4876df5d346da693c37ae02f">Right</a> ()</td></tr>
<tr class="memdesc:a6c50c4ae4876df5d346da693c37ae02f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the right child of this node.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a6c50c4ae4876df5d346da693c37ae02f">More...</a><br /></td></tr>
<tr class="separator:a6c50c4ae4876df5d346da693c37ae02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa38cf098e44114fc6e70da0f9ef57e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#aaa38cf098e44114fc6e70da0f9ef57e0">Right</a> () const</td></tr>
<tr class="memdesc:aaa38cf098e44114fc6e70da0f9ef57e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the right child of this node.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#aaa38cf098e44114fc6e70da0f9ef57e0">More...</a><br /></td></tr>
<tr class="separator:aaa38cf098e44114fc6e70da0f9ef57e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d63b74c8166dff8e1a9006905ad9ca"><td class="memTemplParams" colspan="2">template&lt;typename Archive &gt; </td></tr>
<tr class="memitem:a72d63b74c8166dff8e1a9006905ad9ca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a72d63b74c8166dff8e1a9006905ad9ca">serialize</a> (Archive &amp;ar, const uint32_t version)</td></tr>
<tr class="memdesc:a72d63b74c8166dff8e1a9006905ad9ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize the tree.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a72d63b74c8166dff8e1a9006905ad9ca">More...</a><br /></td></tr>
<tr class="separator:a72d63b74c8166dff8e1a9006905ad9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2d3c104b89109f3df4a9a8cad244da"><td class="memItemLeft" align="right" valign="top">StatisticType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#aac2d3c104b89109f3df4a9a8cad244da">Stat</a> ()</td></tr>
<tr class="memdesc:aac2d3c104b89109f3df4a9a8cad244da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the statistic object for this node.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#aac2d3c104b89109f3df4a9a8cad244da">More...</a><br /></td></tr>
<tr class="separator:aac2d3c104b89109f3df4a9a8cad244da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b29c84ac793742cd15834f9f4c4f31"><td class="memItemLeft" align="right" valign="top">const StatisticType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#ad8b29c84ac793742cd15834f9f4c4f31">Stat</a> () const</td></tr>
<tr class="memdesc:ad8b29c84ac793742cd15834f9f4c4f31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the statistic object for this node.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#ad8b29c84ac793742cd15834f9f4c4f31">More...</a><br /></td></tr>
<tr class="separator:ad8b29c84ac793742cd15834f9f4c4f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae287bd32ba0f337878b2d1b52e550281"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#ae287bd32ba0f337878b2d1b52e550281">BinarySpaceTree</a> ()</td></tr>
<tr class="memdesc:ae287bd32ba0f337878b2d1b52e550281"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default constructor.  <a href="classmlpack_1_1tree_1_1BinarySpaceTree.html#ae287bd32ba0f337878b2d1b52e550281">More...</a><br /></td></tr>
<tr class="separator:ae287bd32ba0f337878b2d1b52e550281"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename MetricType, typename StatisticType = EmptyStatistic, typename MatType = arma::mat, template&lt; typename BoundMetricType, typename... &gt; class BoundType = bound::HRectBound, template&lt; typename SplitBoundType, typename SplitMatType &gt; class SplitType = MidpointSplit&gt;<br />
class mlpack::tree::BinarySpaceTree&lt; MetricType, StatisticType, MatType, BoundType, SplitType &gt;</h3>

<p>A binary space partitioning tree, such as a KD-tree or a ball tree. </p>
<p>Once the bound and type of dataset is defined, the tree will construct itself. Call the constructor with the dataset to build the tree on, and the entire tree will be built.</p>
<p>This particular tree does not allow growth, so you cannot add or delete nodes from it. If you need to add or delete a node, the better procedure is to rebuild the tree entirely.</p>
<p>This tree does take one runtime parameter in the constructor, which is the max leaf size to be used.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MetricType</td><td>The metric used for tree-building. The BoundType may place restrictions on the metrics that can be used. </td></tr>
    <tr><td class="paramname">StatisticType</td><td>Extra data contained in the node. See <a class="el" href="statistic_8hpp.html" title="Definition of the policy type for the statistic class.">statistic.hpp</a> for the necessary skeleton interface. </td></tr>
    <tr><td class="paramname">MatType</td><td>The dataset class. </td></tr>
    <tr><td class="paramname">BoundType</td><td>The bound used for each node. HRectBound, the default, requires that an LMetric&lt;&gt; is used for MetricType (so, EuclideanDistance, ManhattanDistance, etc.). </td></tr>
    <tr><td class="paramname">SplitType</td><td>The class that partitions the dataset/points at a particular node into two parts. Its definition decides the way this split is done. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html#l00054">54</a> of file <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html">binary_space_tree.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a227d0c7e23e98fcd6c81ecab357a791f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227d0c7e23e98fcd6c81ecab357a791f">&#9670;&nbsp;</a></span>ElemType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef MatType::elem_type <a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of element held in MatType. </p>

<p class="definition">Definition at line <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html#l00060">60</a> of file <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html">binary_space_tree.hpp</a>.</p>

</div>
</div>
<a id="a57758caa2e58c3fe05d1284eeabae523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57758caa2e58c3fe05d1284eeabae523">&#9670;&nbsp;</a></span>Mat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef MatType <a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a57758caa2e58c3fe05d1284eeabae523">Mat</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>So other classes can use TreeType::Mat. </p>

<p class="definition">Definition at line <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html#l00058">58</a> of file <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html">binary_space_tree.hpp</a>.</p>

</div>
</div>
<a id="a2fbe69d8cb6be0a0735b5df955708ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fbe69d8cb6be0a0735b5df955708ade">&#9670;&nbsp;</a></span>Split</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef SplitType&lt;BoundType&lt;MetricType&gt;, MatType&gt; <a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a2fbe69d8cb6be0a0735b5df955708ade">Split</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html#l00062">62</a> of file <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html">binary_space_tree.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a360d6a8e92c66e9c2d985b528071e93e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a360d6a8e92c66e9c2d985b528071e93e">&#9670;&nbsp;</a></span>BinarySpaceTree() <span class="overload">[1/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a> </td>
          <td>(</td>
          <td class="paramtype">const MatType &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>maxLeafSize</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct this as the root node of a binary space tree using the given dataset. </p>
<p>This will copy the input matrix; if you don't want this, consider using the constructor that takes an rvalue reference and use std::move().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Dataset to create tree from. This will be copied! </td></tr>
    <tr><td class="paramname">maxLeafSize</td><td>Size of each leaf in the tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38fc3cb2dd94cbd130f0444b3b06355b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38fc3cb2dd94cbd130f0444b3b06355b">&#9670;&nbsp;</a></span>BinarySpaceTree() <span class="overload">[2/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a> </td>
          <td>(</td>
          <td class="paramtype">const MatType &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>oldFromNew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>maxLeafSize</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct this as the root node of a binary space tree using the given dataset. </p>
<p>This will copy the input matrix and modify its ordering; a mapping of the old point indices to the new point indices is filled. If you don't want the matrix to be copied, consider using the constructor that takes an rvalue reference and use std::move().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Dataset to create tree from. This will be copied! </td></tr>
    <tr><td class="paramname">oldFromNew</td><td>Vector which will be filled with the old positions for each new point. </td></tr>
    <tr><td class="paramname">maxLeafSize</td><td>Size of each leaf in the tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a842ae235a817cfb9c7a5a456e7d78292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a842ae235a817cfb9c7a5a456e7d78292">&#9670;&nbsp;</a></span>BinarySpaceTree() <span class="overload">[3/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a> </td>
          <td>(</td>
          <td class="paramtype">const MatType &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>oldFromNew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>newFromOld</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>maxLeafSize</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct this as the root node of a binary space tree using the given dataset. </p>
<p>This will copy the input matrix and modify its ordering; a mapping of the old point indices to the new point indices is filled, as well as a mapping of the new point indices to the old point indices. If you don't want the matrix to be copied, consider using the constructor that takes an rvalue reference and use std::move().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Dataset to create tree from. This will be copied! </td></tr>
    <tr><td class="paramname">oldFromNew</td><td>Vector which will be filled with the old positions for each new point. </td></tr>
    <tr><td class="paramname">newFromOld</td><td>Vector which will be filled with the new positions for each old point. </td></tr>
    <tr><td class="paramname">maxLeafSize</td><td>Size of each leaf in the tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49ee8af5482a265fe2b7edc8bb3efdce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49ee8af5482a265fe2b7edc8bb3efdce">&#9670;&nbsp;</a></span>BinarySpaceTree() <span class="overload">[4/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a> </td>
          <td>(</td>
          <td class="paramtype">MatType &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>maxLeafSize</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct this as the root node of a binary space tree using the given dataset. </p>
<p>This will take ownership of the data matrix; if you don't want this, consider using the constructor that takes a const reference to a dataset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Dataset to create tree from. </td></tr>
    <tr><td class="paramname">maxLeafSize</td><td>Size of each leaf in the tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3753895793f9161d2793fd7b326b821d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3753895793f9161d2793fd7b326b821d">&#9670;&nbsp;</a></span>BinarySpaceTree() <span class="overload">[5/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a> </td>
          <td>(</td>
          <td class="paramtype">MatType &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>oldFromNew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>maxLeafSize</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct this as the root node of a binary space tree using the given dataset. </p>
<p>This will take ownership of the data matrix; a mapping of the old point indices to the new point indices is filled. If you don't want the matrix to have its ownership taken, consider using the constructor that takes a const reference to a dataset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Dataset to create tree from. </td></tr>
    <tr><td class="paramname">oldFromNew</td><td>Vector which will be filled with the old positions for each new point. </td></tr>
    <tr><td class="paramname">maxLeafSize</td><td>Size of each leaf in the tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb64c00419354018fa1cd0ceb4f2eee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb64c00419354018fa1cd0ceb4f2eee5">&#9670;&nbsp;</a></span>BinarySpaceTree() <span class="overload">[6/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a> </td>
          <td>(</td>
          <td class="paramtype">MatType &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>oldFromNew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>newFromOld</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>maxLeafSize</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct this as the root node of a binary space tree using the given dataset. </p>
<p>This will take ownership of the data matrix; a mapping of the old point indices to the new point indices is filled, as well as a mapping of the new point indices to the old point indices. If you don't want the matrix to have its ownership taken, consider using the constructor that takes a const reference to a dataset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Dataset to create tree from. </td></tr>
    <tr><td class="paramname">oldFromNew</td><td>Vector which will be filled with the old positions for each new point. </td></tr>
    <tr><td class="paramname">newFromOld</td><td>Vector which will be filled with the new positions for each old point. </td></tr>
    <tr><td class="paramname">maxLeafSize</td><td>Size of each leaf in the tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a820092388341845e2a8927478215e476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a820092388341845e2a8927478215e476">&#9670;&nbsp;</a></span>BinarySpaceTree() <span class="overload">[7/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a>&lt; MetricType, StatisticType, MatType, BoundType, SplitType &gt; *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SplitType&lt; BoundType&lt; MetricType &gt;, MatType &gt; &amp;&#160;</td>
          <td class="paramname"><em>splitter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>maxLeafSize</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct this node as a child of the given parent, starting at column begin and using count points. </p>
<p>The ordering of that subset of points in the parent's data matrix will be modified! This is used for recursive tree-building by the other constructors which don't specify point indices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>Parent of this node. Its dataset will be modified! </td></tr>
    <tr><td class="paramname">begin</td><td>Index of point to start tree construction with. </td></tr>
    <tr><td class="paramname">count</td><td>Number of points to use to construct tree. </td></tr>
    <tr><td class="paramname">splitter</td><td>Instantiated node splitter object. </td></tr>
    <tr><td class="paramname">maxLeafSize</td><td>Size of each leaf in the tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae79c1b69a1dc4ac4d654c43e0d1a1981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae79c1b69a1dc4ac4d654c43e0d1a1981">&#9670;&nbsp;</a></span>BinarySpaceTree() <span class="overload">[8/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a>&lt; MetricType, StatisticType, MatType, BoundType, SplitType &gt; *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>oldFromNew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SplitType&lt; BoundType&lt; MetricType &gt;, MatType &gt; &amp;&#160;</td>
          <td class="paramname"><em>splitter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>maxLeafSize</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct this node as a child of the given parent, starting at column begin and using count points. </p>
<p>The ordering of that subset of points in the parent's data matrix will be modified! This is used for recursive tree-building by the other constructors which don't specify point indices.</p>
<p>A mapping of the old point indices to the new point indices is filled, but it is expected that the vector is already allocated with size greater than or equal to (begin + count), and if that is not true, invalid memory reads (and writes) will occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>Parent of this node. Its dataset will be modified! </td></tr>
    <tr><td class="paramname">begin</td><td>Index of point to start tree construction with. </td></tr>
    <tr><td class="paramname">count</td><td>Number of points to use to construct tree. </td></tr>
    <tr><td class="paramname">oldFromNew</td><td>Vector which will be filled with the old positions for each new point. </td></tr>
    <tr><td class="paramname">splitter</td><td>Instantiated node splitter object. </td></tr>
    <tr><td class="paramname">maxLeafSize</td><td>Size of each leaf in the tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae1fbad0d2639fb7bd63aac6b6a998f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae1fbad0d2639fb7bd63aac6b6a998f1">&#9670;&nbsp;</a></span>BinarySpaceTree() <span class="overload">[9/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a>&lt; MetricType, StatisticType, MatType, BoundType, SplitType &gt; *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>oldFromNew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>newFromOld</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SplitType&lt; BoundType&lt; MetricType &gt;, MatType &gt; &amp;&#160;</td>
          <td class="paramname"><em>splitter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>maxLeafSize</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct this node as a child of the given parent, starting at column begin and using count points. </p>
<p>The ordering of that subset of points in the parent's data matrix will be modified! This is used for recursive tree-building by the other constructors which don't specify point indices.</p>
<p>A mapping of the old point indices to the new point indices is filled, as well as a mapping of the new point indices to the old point indices. It is expected that the vector is already allocated with size greater than or equal to (begin_in + count_in), and if that is not true, invalid memory reads (and writes) will occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>Parent of this node. Its dataset will be modified! </td></tr>
    <tr><td class="paramname">begin</td><td>Index of point to start tree construction with. </td></tr>
    <tr><td class="paramname">count</td><td>Number of points to use to construct tree. </td></tr>
    <tr><td class="paramname">oldFromNew</td><td>Vector which will be filled with the old positions for each new point. </td></tr>
    <tr><td class="paramname">newFromOld</td><td>Vector which will be filled with the new positions for each old point. </td></tr>
    <tr><td class="paramname">splitter</td><td>Splitter matrix to use. </td></tr>
    <tr><td class="paramname">maxLeafSize</td><td>Size of each leaf in the tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32dee7101946c7d2393cc13c8d65899f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32dee7101946c7d2393cc13c8d65899f">&#9670;&nbsp;</a></span>BinarySpaceTree() <span class="overload">[10/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a>&lt; MetricType, StatisticType, MatType, BoundType, SplitType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a binary space tree by copying the other tree. </p>
<p>Be careful! This can take a long time and use a lot of memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Tree to be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50dd4753fb64883537125f80f5dfc273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50dd4753fb64883537125f80f5dfc273">&#9670;&nbsp;</a></span>BinarySpaceTree() <span class="overload">[11/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a>&lt; MetricType, StatisticType, MatType, BoundType, SplitType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move constructor for a <a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html" title="A binary space partitioning tree, such as a KD-tree or a ball tree.">BinarySpaceTree</a>; possess all the members of the given tree. </p>

</div>
</div>
<a id="a7f027dcf721e6e54ad0b5b63504cf057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f027dcf721e6e54ad0b5b63504cf057">&#9670;&nbsp;</a></span>BinarySpaceTree() <span class="overload">[12/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a> </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="namespacestd.html#a93e9cb7fadbcfaa2afb5b94058b8e34c">std::enable_if_t</a>&lt; <a class="el" href="namespacecereal.html#ad79f9b690399d7e8aad9e7fc9ef3b797">cereal::is_loading</a>&lt; Archive &gt;()&gt; *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the tree from a cereal archive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ar</td><td>Archive to load tree from. Must be an iarchive, not an oarchive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae07a273ce37bd373995e13b3ef276265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae07a273ce37bd373995e13b3ef276265">&#9670;&nbsp;</a></span>~BinarySpaceTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes this node, deallocating the memory for the children and calling their destructors in turn. </p>
<p>This will invalidate any pointers or references to any nodes which are children of this one. </p>

</div>
</div>
<a id="ae287bd32ba0f337878b2d1b52e550281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae287bd32ba0f337878b2d1b52e550281">&#9670;&nbsp;</a></span>BinarySpaceTree() <span class="overload">[13/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A default constructor. </p>
<p>This is meant to only be used with cereal, which is allowed with the friend declaration below. This does not return a valid tree! The method must be protected, so that the serialization shim can work with the default constructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a49cdbf8b1b2899522cd80f4cbff40b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49cdbf8b1b2899522cd80f4cbff40b69">&#9670;&nbsp;</a></span>Begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t&amp; Begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the index of the beginning point of this subset. </p>

<p class="definition">Definition at line <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html#l00500">500</a> of file <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html">binary_space_tree.hpp</a>.</p>

</div>
</div>
<a id="ac50a3a009687e641fd8249e011f628d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac50a3a009687e641fd8249e011f628d4">&#9670;&nbsp;</a></span>Begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the index of the beginning point of this subset. </p>

<p class="definition">Definition at line <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html#l00498">498</a> of file <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html">binary_space_tree.hpp</a>.</p>

</div>
</div>
<a id="a1023b24dcb81cc1769a8698d0ac8b7ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1023b24dcb81cc1769a8698d0ac8b7ed">&#9670;&nbsp;</a></span>Bound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BoundType&lt;MetricType&gt;&amp; Bound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the bound object for this node. </p>

<p class="definition">Definition at line <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html#l00321">321</a> of file <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html">binary_space_tree.hpp</a>.</p>

</div>
</div>
<a id="ae995f23d597849b8b3fa165765921914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae995f23d597849b8b3fa165765921914">&#9670;&nbsp;</a></span>Bound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const BoundType&lt;MetricType&gt;&amp; Bound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the bound object for this node. </p>

<p class="definition">Definition at line <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html#l00319">319</a> of file <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html">binary_space_tree.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html#l00459">BinarySpaceTree&lt; MetricType, StatisticType, MatType, BoundType, SplitType &gt;::MaxDistance()</a>, <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html#l00453">BinarySpaceTree&lt; MetricType, StatisticType, MatType, BoundType, SplitType &gt;::MinDistance()</a>, and <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html#l00465">BinarySpaceTree&lt; MetricType, StatisticType, MatType, BoundType, SplitType &gt;::RangeDistance()</a>.</p>

</div>
</div>
<a id="aa800439660375c0253008cafa648da78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa800439660375c0253008cafa648da78">&#9670;&nbsp;</a></span>Center()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Center </td>
          <td>(</td>
          <td class="paramtype">arma::vec &amp;&#160;</td>
          <td class="paramname"><em>center</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store the center of the bounding region in the given vector. </p>

<p class="definition">Definition at line <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html#l00508">508</a> of file <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html">binary_space_tree.hpp</a>.</p>

</div>
</div>
<a id="a2cf9f074d6e3c683213f5f17acfbc6f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cf9f074d6e3c683213f5f17acfbc6f7">&#9670;&nbsp;</a></span>Child()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a>&amp; Child </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the specified child (0 will be left, 1 will be right). </p>
<p>If the index is greater than 1, this will return the right child.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>Index of child to return. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb373eeb13db5a753ec52ea56ec5a9cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb373eeb13db5a753ec52ea56ec5a9cd">&#9670;&nbsp;</a></span>ChildPtr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a>*&amp; ChildPtr </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html#l00420">420</a> of file <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html">binary_space_tree.hpp</a>.</p>

</div>
</div>
<a id="a5a132e068ab206a014b986ff71c3442d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a132e068ab206a014b986ff71c3442d">&#9670;&nbsp;</a></span>Count() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t&amp; Count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the number of points in this subset. </p>

<p class="definition">Definition at line <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html#l00505">505</a> of file <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html">binary_space_tree.hpp</a>.</p>

</div>
</div>
<a id="ab30fd361b8bee994ff8ed9fbb6fae845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab30fd361b8bee994ff8ed9fbb6fae845">&#9670;&nbsp;</a></span>Count() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of points in this subset. </p>

<p class="definition">Definition at line <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html#l00503">503</a> of file <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html">binary_space_tree.hpp</a>.</p>

</div>
</div>
<a id="abb34576c3ddb31987f1dda9c33e6476f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb34576c3ddb31987f1dda9c33e6476f">&#9670;&nbsp;</a></span>Dataset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MatType&amp; Dataset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the dataset which the tree is built on. Be careful! </p>

<p class="definition">Definition at line <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html#l00349">349</a> of file <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html">binary_space_tree.hpp</a>.</p>

</div>
</div>
<a id="a4c3764c98d5804083a9ec2c867eb9366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c3764c98d5804083a9ec2c867eb9366">&#9670;&nbsp;</a></span>Dataset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const MatType&amp; Dataset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the dataset which the tree is built on. </p>

<p class="definition">Definition at line <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html#l00347">347</a> of file <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html">binary_space_tree.hpp</a>.</p>

</div>
</div>
<a id="aa732ea3eeb38529c549fd4d15d8655be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa732ea3eeb38529c549fd4d15d8655be">&#9670;&nbsp;</a></span>Descendant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Descendant </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the index (with reference to the dataset) of a particular descendant of this node. </p>
<p>The index should be greater than zero but less than the number of descendants.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the descendant. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc597088eadfcfa3060336d0484ab573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc597088eadfcfa3060336d0484ab573">&#9670;&nbsp;</a></span>FurthestDescendantDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> FurthestDescendantDistance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the furthest possible descendant distance. </p>
<p>This returns the maximum distance from the centroid to the edge of the bound and not the empirical quantity which is the actual furthest descendant distance. So the actual furthest descendant distance may be less than what this method returns (but it will never be greater than this). </p>

</div>
</div>
<a id="acbe82a6439f71405b5801ca7d941cbfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe82a6439f71405b5801ca7d941cbfb">&#9670;&nbsp;</a></span>FurthestPointDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> FurthestPointDistance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the furthest distance to a point held in this node. </p>
<p>If this is not a leaf node, then the distance is 0 because the node holds no points. </p>

</div>
</div>
<a id="a03c2b878b5dd46d80b333542f97bd86d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03c2b878b5dd46d80b333542f97bd86d">&#9670;&nbsp;</a></span>GetFurthestChild() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t GetFurthestChild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a>&lt; MetricType, StatisticType, MatType, BoundType, SplitType &gt; &amp;&#160;</td>
          <td class="paramname"><em>queryNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the index of the furthest child node to the given query node. </p>
<p>If it can't decide, it will return <a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a1f7ec083be66d58a3e02e12956bf005e" title="Return the number of children in this node.">NumChildren()</a> (invalid index). </p>

</div>
</div>
<a id="a0257281722537c7916db7763623f67f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0257281722537c7916db7763623f67f7">&#9670;&nbsp;</a></span>GetFurthestChild() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t GetFurthestChild </td>
          <td>(</td>
          <td class="paramtype">const VecType &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="namespacestd.html#a93e9cb7fadbcfaa2afb5b94058b8e34c">std::enable_if_t</a>&lt; <a class="el" href="structIsVector.html">IsVector</a>&lt; VecType &gt;::value &gt; *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the index of the furthest child node to the given query point. </p>
<p>If this is a leaf node, it will return <a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a1f7ec083be66d58a3e02e12956bf005e" title="Return the number of children in this node.">NumChildren()</a> (invalid index). </p>

</div>
</div>
<a id="a45f18fdc176329c127d97aa7d08d4b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f18fdc176329c127d97aa7d08d4b7a">&#9670;&nbsp;</a></span>GetNearestChild() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t GetNearestChild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a>&lt; MetricType, StatisticType, MatType, BoundType, SplitType &gt; &amp;&#160;</td>
          <td class="paramname"><em>queryNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the index of the nearest child node to the given query node. </p>
<p>If it can't decide, it will return <a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a1f7ec083be66d58a3e02e12956bf005e" title="Return the number of children in this node.">NumChildren()</a> (invalid index). </p>

</div>
</div>
<a id="a19b9a5fd41d8e192b62effb1445bd410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19b9a5fd41d8e192b62effb1445bd410">&#9670;&nbsp;</a></span>GetNearestChild() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t GetNearestChild </td>
          <td>(</td>
          <td class="paramtype">const VecType &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="namespacestd.html#a93e9cb7fadbcfaa2afb5b94058b8e34c">std::enable_if_t</a>&lt; <a class="el" href="structIsVector.html">IsVector</a>&lt; VecType &gt;::value &gt; *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the index of the nearest child node to the given query point. </p>
<p>If this is a leaf node, it will return <a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a1f7ec083be66d58a3e02e12956bf005e" title="Return the number of children in this node.">NumChildren()</a> (invalid index). </p>

</div>
</div>
<a id="aa0f4813924e6cdee43b45050bb947abe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0f4813924e6cdee43b45050bb947abe">&#9670;&nbsp;</a></span>IsLeaf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IsLeaf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return whether or not this node is a leaf (true if it has no children). </p>

</div>
</div>
<a id="a5ddd6024d9d85e1e0d7e59b8533897a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ddd6024d9d85e1e0d7e59b8533897a7">&#9670;&nbsp;</a></span>Left() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a>*&amp; Left </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the left child of this node. </p>

<p class="definition">Definition at line <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html#l00334">334</a> of file <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html">binary_space_tree.hpp</a>.</p>

</div>
</div>
<a id="a3085061e078694745cf2f59a77f982c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3085061e078694745cf2f59a77f982c3">&#9670;&nbsp;</a></span>Left() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a>* Left </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the left child of this node. </p>

<p class="definition">Definition at line <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html#l00332">332</a> of file <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html">binary_space_tree.hpp</a>.</p>

</div>
</div>
<a id="a29d3f7fc53a6113f14949dc05d747992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d3f7fc53a6113f14949dc05d747992">&#9670;&nbsp;</a></span>MaxDistance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> MaxDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a>&lt; MetricType, StatisticType, MatType, BoundType, SplitType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the maximum distance to another node. </p>

<p class="definition">Definition at line <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html#l00459">459</a> of file <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html">binary_space_tree.hpp</a>.</p>

<p class="reference">References <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html#l00319">BinarySpaceTree&lt; MetricType, StatisticType, MatType, BoundType, SplitType &gt;::Bound()</a>.</p>

</div>
</div>
<a id="ae764d88483236cc470f5abe0273df4c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae764d88483236cc470f5abe0273df4c5">&#9670;&nbsp;</a></span>MaxDistance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> MaxDistance </td>
          <td>(</td>
          <td class="paramtype">const VecType &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="namespacestd.html#a93e9cb7fadbcfaa2afb5b94058b8e34c">std::enable_if_t</a>&lt; <a class="el" href="structIsVector.html">IsVector</a>&lt; VecType &gt;::value &gt; *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the maximum distance to another point. </p>

<p class="definition">Definition at line <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html#l00481">481</a> of file <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html">binary_space_tree.hpp</a>.</p>

</div>
</div>
<a id="ab7cdd810a507e4a0aa262ea0fa8a322c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7cdd810a507e4a0aa262ea0fa8a322c">&#9670;&nbsp;</a></span>Metric()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MetricType Metric </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the metric that the tree uses. </p>

<p class="definition">Definition at line <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html#l00352">352</a> of file <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html">binary_space_tree.hpp</a>.</p>

</div>
</div>
<a id="a080f6b6c8d4336ff1ead4f0d0f6a0cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a080f6b6c8d4336ff1ead4f0d0f6a0cb5">&#9670;&nbsp;</a></span>MinDistance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> MinDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a>&lt; MetricType, StatisticType, MatType, BoundType, SplitType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the minimum distance to another node. </p>

<p class="definition">Definition at line <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html#l00453">453</a> of file <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html">binary_space_tree.hpp</a>.</p>

<p class="reference">References <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html#l00319">BinarySpaceTree&lt; MetricType, StatisticType, MatType, BoundType, SplitType &gt;::Bound()</a>.</p>

</div>
</div>
<a id="a73bf99a433e88a31d98b46bf4c0da147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73bf99a433e88a31d98b46bf4c0da147">&#9670;&nbsp;</a></span>MinDistance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> MinDistance </td>
          <td>(</td>
          <td class="paramtype">const VecType &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="namespacestd.html#a93e9cb7fadbcfaa2afb5b94058b8e34c">std::enable_if_t</a>&lt; <a class="el" href="structIsVector.html">IsVector</a>&lt; VecType &gt;::value &gt; *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the minimum distance to another point. </p>

<p class="definition">Definition at line <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html#l00472">472</a> of file <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html">binary_space_tree.hpp</a>.</p>

</div>
</div>
<a id="a20a4e92da6066eb335a576b7f9cd0415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20a4e92da6066eb335a576b7f9cd0415">&#9670;&nbsp;</a></span>MinimumBoundDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> MinimumBoundDistance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the minimum distance from the center of the node to any bound edge. </p>

</div>
</div>
<a id="a1f7ec083be66d58a3e02e12956bf005e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f7ec083be66d58a3e02e12956bf005e">&#9670;&nbsp;</a></span>NumChildren()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NumChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of children in this node. </p>

</div>
</div>
<a id="a2a85eb34222f1fc073940e8c89274e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a85eb34222f1fc073940e8c89274e81">&#9670;&nbsp;</a></span>NumDescendants()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NumDescendants </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of descendants of this node. </p>
<p>For a non-leaf in a binary space tree, this is the number of points at the descendant leaves. For a leaf, this is the number of points in the leaf. </p>

</div>
</div>
<a id="a352077c26368da0ee570c0b7f062b1e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a352077c26368da0ee570c0b7f062b1e3">&#9670;&nbsp;</a></span>NumPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NumPoints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of points in this node (0 if not a leaf). </p>

</div>
</div>
<a id="ace087a2c1ab4214c229b36edd4444ea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace087a2c1ab4214c229b36edd4444ea7">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a>&lt; MetricType, StatisticType, MatType, BoundType, SplitType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take ownership of the given <a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html" title="A binary space partitioning tree, such as a KD-tree or a ball tree.">BinarySpaceTree</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The tree to take ownership of. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11d6befceee3f4a7cda868bfeb3bf8f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11d6befceee3f4a7cda868bfeb3bf8f9">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a>&lt; MetricType, StatisticType, MatType, BoundType, SplitType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the given BinarySaceTree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The tree to be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a632e02a7a7f3eda4fe6d4fa5bc69b832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a632e02a7a7f3eda4fe6d4fa5bc69b832">&#9670;&nbsp;</a></span>Parent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a>*&amp; Parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the parent of this node. </p>

<p class="definition">Definition at line <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html#l00344">344</a> of file <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html">binary_space_tree.hpp</a>.</p>

</div>
</div>
<a id="abe2ac60bc77d318c2dba58b43f18a245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe2ac60bc77d318c2dba58b43f18a245">&#9670;&nbsp;</a></span>Parent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a>* Parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the parent of this node. </p>

<p class="definition">Definition at line <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html#l00342">342</a> of file <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html">binary_space_tree.hpp</a>.</p>

</div>
</div>
<a id="aa22ead21ac809efb970b90ec014dc318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa22ead21ac809efb970b90ec014dc318">&#9670;&nbsp;</a></span>ParentDistance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&amp; ParentDistance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the distance from the center of this node to the center of the parent node. </p>

<p class="definition">Definition at line <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html#l00410">410</a> of file <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html">binary_space_tree.hpp</a>.</p>

</div>
</div>
<a id="af44ed4e7bfea088689caed082da67e17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af44ed4e7bfea088689caed082da67e17">&#9670;&nbsp;</a></span>ParentDistance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> ParentDistance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the distance from the center of this node to the center of the parent node. </p>

<p class="definition">Definition at line <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html#l00407">407</a> of file <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html">binary_space_tree.hpp</a>.</p>

</div>
</div>
<a id="a559eede5ea60f68634f8e7e72c3c68d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a559eede5ea60f68634f8e7e72c3c68d2">&#9670;&nbsp;</a></span>Point()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Point </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the index (with reference to the dataset) of a particular point in this node. </p>
<p>This will happily return invalid indices if the given index is greater than the number of points in this node (obtained with <a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a352077c26368da0ee570c0b7f062b1e3" title="Return the number of points in this node (0 if not a leaf).">NumPoints()</a>) &ndash; be careful.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of point for which a dataset index is wanted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a186a488e372175c6f8499115c9add8b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a186a488e372175c6f8499115c9add8b4">&#9670;&nbsp;</a></span>RangeDistance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1math_1_1RangeType.html">math::RangeType</a>&lt;<a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&gt; RangeDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a>&lt; MetricType, StatisticType, MatType, BoundType, SplitType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the minimum and maximum distance to another node. </p>

<p class="definition">Definition at line <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html#l00465">465</a> of file <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html">binary_space_tree.hpp</a>.</p>

<p class="reference">References <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html#l00319">BinarySpaceTree&lt; MetricType, StatisticType, MatType, BoundType, SplitType &gt;::Bound()</a>.</p>

</div>
</div>
<a id="a60a550bf46aa1d7b858134ce41fd5a3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60a550bf46aa1d7b858134ce41fd5a3a">&#9670;&nbsp;</a></span>RangeDistance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1math_1_1RangeType.html">math::RangeType</a>&lt;<a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&gt; RangeDistance </td>
          <td>(</td>
          <td class="paramtype">const VecType &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="namespacestd.html#a93e9cb7fadbcfaa2afb5b94058b8e34c">std::enable_if_t</a>&lt; <a class="el" href="structIsVector.html">IsVector</a>&lt; VecType &gt;::value &gt; *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the minimum and maximum distance to another point. </p>

<p class="definition">Definition at line <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html#l00491">491</a> of file <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html">binary_space_tree.hpp</a>.</p>

</div>
</div>
<a id="a6c50c4ae4876df5d346da693c37ae02f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c50c4ae4876df5d346da693c37ae02f">&#9670;&nbsp;</a></span>Right() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a>*&amp; Right </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the right child of this node. </p>

<p class="definition">Definition at line <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html#l00339">339</a> of file <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html">binary_space_tree.hpp</a>.</p>

</div>
</div>
<a id="aaa38cf098e44114fc6e70da0f9ef57e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa38cf098e44114fc6e70da0f9ef57e0">&#9670;&nbsp;</a></span>Right() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html">BinarySpaceTree</a>* Right </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the right child of this node. </p>

<p class="definition">Definition at line <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html#l00337">337</a> of file <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html">binary_space_tree.hpp</a>.</p>

</div>
</div>
<a id="a72d63b74c8166dff8e1a9006905ad9ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72d63b74c8166dff8e1a9006905ad9ca">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize the tree. </p>

</div>
</div>
<a id="aac2d3c104b89109f3df4a9a8cad244da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac2d3c104b89109f3df4a9a8cad244da">&#9670;&nbsp;</a></span>Stat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StatisticType&amp; Stat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the statistic object for this node. </p>

<p class="definition">Definition at line <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html#l00326">326</a> of file <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html">binary_space_tree.hpp</a>.</p>

</div>
</div>
<a id="ad8b29c84ac793742cd15834f9f4c4f31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b29c84ac793742cd15834f9f4c4f31">&#9670;&nbsp;</a></span>Stat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const StatisticType&amp; Stat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the statistic object for this node. </p>

<p class="definition">Definition at line <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html#l00324">324</a> of file <a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html">binary_space_tree.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/aakash/mlpack/src/mlpack/core/tree/binary_space_tree/<a class="el" href="binary__space__tree_2binary__space__tree_8hpp_source.html">binary_space_tree.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.9.1
</small></address>
</body>
<script type="text/javascript">
var x = document.querySelectorAll("img.formulaDsp");
var i;
for (i = 0; i < x.length; i++)
{
  x[i].width = x[i].offsetWidth / 4;
}
</script>
</html>
