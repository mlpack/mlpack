<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>mlpack: mlpack::data Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra-stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">mlpack
   &#160;<span id="projectnumber">3.4.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlpack.html">mlpack</a></li><li class="navelem"><a class="el" href="namespacemlpack_1_1data.html">data</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mlpack::data Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Functions to load and save matrices and models.  
<a href="namespacemlpack_1_1data.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1data_1_1BagOfWordsEncodingPolicy.html">BagOfWordsEncodingPolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the <a class="el" href="classmlpack_1_1data_1_1BagOfWordsEncodingPolicy.html" title="Definition of the BagOfWordsEncodingPolicy class.">BagOfWordsEncodingPolicy</a> class.  <a href="classmlpack_1_1data_1_1BagOfWordsEncodingPolicy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1data_1_1CharExtract.html">CharExtract</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class is used to split a string into characters.  <a href="classmlpack_1_1data_1_1CharExtract.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1data_1_1CustomImputation.html">CustomImputation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple custom imputation class.  <a href="classmlpack_1_1data_1_1CustomImputation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1data_1_1DatasetMapper.html">DatasetMapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary information for a dataset, including mappings to/from strings (or other types) and the datatype of each dimension.  <a href="classmlpack_1_1data_1_1DatasetMapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1data_1_1DictionaryEncodingPolicy.html">DictionaryEncodingPolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">DicitonaryEnocdingPolicy is used as a helper class for <a class="el" href="classmlpack_1_1data_1_1StringEncoding.html" title="The class translates a set of strings into numbers using various encoding algorithms.">StringEncoding</a>.  <a href="classmlpack_1_1data_1_1DictionaryEncodingPolicy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlpack_1_1data_1_1HasSerialize.html">HasSerialize</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlpack_1_1data_1_1HasSerializeFunction.html">HasSerializeFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1data_1_1ImageInfo.html">ImageInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements meta-data of images required by <a class="el" href="namespacemlpack_1_1data.html#abbff2a667bf247e00b1fc09b7ca5f831" title="Loads a matrix from file, guessing the filetype from the extension.">data::Load</a> and <a class="el" href="namespacemlpack_1_1data.html#accd1605a1d160c09ee75c93a587dc313" title="Saves a matrix to file, guessing the filetype from the extension.">data::Save</a> for loading and saving images into arma::Mat.  <a href="classmlpack_1_1data_1_1ImageInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1data_1_1Imputer.html">Imputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a dataset of a particular datatype, replace user-specified missing value with a variable dependent on the StrategyType and MapperType.  <a href="classmlpack_1_1data_1_1Imputer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1data_1_1IncrementPolicy.html">IncrementPolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlpack_1_1data_1_1IncrementPolicy.html" title="IncrementPolicy is used as a helper class for DatasetMapper.">IncrementPolicy</a> is used as a helper class for <a class="el" href="classmlpack_1_1data_1_1DatasetMapper.html" title="Auxiliary information for a dataset, including mappings to/from strings (or other types) and the data...">DatasetMapper</a>.  <a href="classmlpack_1_1data_1_1IncrementPolicy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1data_1_1ListwiseDeletion.html">ListwiseDeletion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A complete-case analysis to remove the values containing mappedValue.  <a href="classmlpack_1_1data_1_1ListwiseDeletion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1data_1_1LoadCSV.html">LoadCSV</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the csv file.This class use boost::spirit to implement the parser, please refer to following link <a href="http://theboostcpplibraries.com/boost.spirit">http://theboostcpplibraries.com/boost.spirit</a> for quick review.  <a href="classmlpack_1_1data_1_1LoadCSV.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1data_1_1MaxAbsScaler.html">MaxAbsScaler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple MaxAbs Scaler class.  <a href="classmlpack_1_1data_1_1MaxAbsScaler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1data_1_1MeanImputation.html">MeanImputation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple mean imputation class.  <a href="classmlpack_1_1data_1_1MeanImputation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1data_1_1MeanNormalization.html">MeanNormalization</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple Mean Normalization class.  <a href="classmlpack_1_1data_1_1MeanNormalization.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1data_1_1MedianImputation.html">MedianImputation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a class implementation of simple median imputation.  <a href="classmlpack_1_1data_1_1MedianImputation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1data_1_1MinMaxScaler.html">MinMaxScaler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple MinMax Scaler class.  <a href="classmlpack_1_1data_1_1MinMaxScaler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1data_1_1MissingPolicy.html">MissingPolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlpack_1_1data_1_1MissingPolicy.html" title="MissingPolicy is used as a helper class for DatasetMapper.">MissingPolicy</a> is used as a helper class for <a class="el" href="classmlpack_1_1data_1_1DatasetMapper.html" title="Auxiliary information for a dataset, including mappings to/from strings (or other types) and the data...">DatasetMapper</a>.  <a href="classmlpack_1_1data_1_1MissingPolicy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1data_1_1PCAWhitening.html">PCAWhitening</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple <a class="el" href="classmlpack_1_1data_1_1PCAWhitening.html" title="A simple PCAWhitening class.">PCAWhitening</a> class.  <a href="classmlpack_1_1data_1_1PCAWhitening.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1data_1_1ScalingModel.html">ScalingModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The model to save to disk.  <a href="classmlpack_1_1data_1_1ScalingModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1data_1_1SplitByAnyOf.html">SplitByAnyOf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classmlpack_1_1data_1_1SplitByAnyOf.html" title="The SplitByAnyOf class tokenizes a string using a set of delimiters.">SplitByAnyOf</a> class tokenizes a string using a set of delimiters.  <a href="classmlpack_1_1data_1_1SplitByAnyOf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1data_1_1StandardScaler.html">StandardScaler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple Standard Scaler class.  <a href="classmlpack_1_1data_1_1StandardScaler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1data_1_1StringEncoding.html">StringEncoding</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class translates a set of strings into numbers using various encoding algorithms.  <a href="classmlpack_1_1data_1_1StringEncoding.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1data_1_1StringEncodingDictionary.html">StringEncodingDictionary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a dictionary interface for the purpose of string encoding.  <a href="classmlpack_1_1data_1_1StringEncodingDictionary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1data_1_1StringEncodingDictionary_3_01boost_1_1string__view_01_4.html">StringEncodingDictionary&lt; boost::string_view &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1data_1_1StringEncodingDictionary_3_01int_01_4.html">StringEncodingDictionary&lt; int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlpack_1_1data_1_1StringEncodingPolicyTraits.html">StringEncodingPolicyTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a template struct that provides some information about various encoding policies.  <a href="structmlpack_1_1data_1_1StringEncodingPolicyTraits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlpack_1_1data_1_1StringEncodingPolicyTraits_3_01DictionaryEncodingPolicy_01_4.html">StringEncodingPolicyTraits&lt; DictionaryEncodingPolicy &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The specialization provides some information about the dictionary encoding policy.  <a href="structmlpack_1_1data_1_1StringEncodingPolicyTraits_3_01DictionaryEncodingPolicy_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1data_1_1TfIdfEncodingPolicy.html">TfIdfEncodingPolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the <a class="el" href="classmlpack_1_1data_1_1TfIdfEncodingPolicy.html" title="Definition of the TfIdfEncodingPolicy class.">TfIdfEncodingPolicy</a> class.  <a href="classmlpack_1_1data_1_1TfIdfEncodingPolicy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1data_1_1ZCAWhitening.html">ZCAWhitening</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple <a class="el" href="classmlpack_1_1data_1_1ZCAWhitening.html" title="A simple ZCAWhitening class.">ZCAWhitening</a> class.  <a href="classmlpack_1_1data_1_1ZCAWhitening.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a728f5dac92331960e1e5822919dd2a41"><td class="memTemplParams" colspan="2">template&lt;typename TokenType &gt; </td></tr>
<tr class="memitem:a728f5dac92331960e1e5822919dd2a41"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a728f5dac92331960e1e5822919dd2a41">BagOfWordsEncoding</a> = <a class="el" href="classmlpack_1_1data_1_1StringEncoding.html">StringEncoding</a>&lt; <a class="el" href="classmlpack_1_1data_1_1BagOfWordsEncodingPolicy.html">BagOfWordsEncodingPolicy</a>, <a class="el" href="classmlpack_1_1data_1_1StringEncodingDictionary.html">StringEncodingDictionary</a>&lt; TokenType &gt; &gt;</td></tr>
<tr class="memdesc:a728f5dac92331960e1e5822919dd2a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenient alias for the <a class="el" href="classmlpack_1_1data_1_1StringEncoding.html" title="The class translates a set of strings into numbers using various encoding algorithms.">StringEncoding</a> class with <a class="el" href="classmlpack_1_1data_1_1BagOfWordsEncodingPolicy.html" title="Definition of the BagOfWordsEncodingPolicy class.">BagOfWordsEncodingPolicy</a> and the default dictionary for the given token type.  <a href="namespacemlpack_1_1data.html#a728f5dac92331960e1e5822919dd2a41">More...</a><br /></td></tr>
<tr class="separator:a728f5dac92331960e1e5822919dd2a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa243ad7e4d29363b858bbc92b732921d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#aa243ad7e4d29363b858bbc92b732921d">DatasetInfo</a> = <a class="el" href="classmlpack_1_1data_1_1DatasetMapper.html">DatasetMapper</a>&lt; <a class="el" href="classmlpack_1_1data_1_1IncrementPolicy.html">data::IncrementPolicy</a> &gt;</td></tr>
<tr class="separator:aa243ad7e4d29363b858bbc92b732921d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7ca4dc9e2a0d1189d7717b98c01933"><td class="memTemplParams" colspan="2">template&lt;typename TokenType &gt; </td></tr>
<tr class="memitem:aaa7ca4dc9e2a0d1189d7717b98c01933"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#aaa7ca4dc9e2a0d1189d7717b98c01933">DictionaryEncoding</a> = <a class="el" href="classmlpack_1_1data_1_1StringEncoding.html">StringEncoding</a>&lt; <a class="el" href="classmlpack_1_1data_1_1DictionaryEncodingPolicy.html">DictionaryEncodingPolicy</a>, <a class="el" href="classmlpack_1_1data_1_1StringEncodingDictionary.html">StringEncodingDictionary</a>&lt; TokenType &gt; &gt;</td></tr>
<tr class="memdesc:aaa7ca4dc9e2a0d1189d7717b98c01933"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenient alias for the <a class="el" href="classmlpack_1_1data_1_1StringEncoding.html" title="The class translates a set of strings into numbers using various encoding algorithms.">StringEncoding</a> class with <a class="el" href="classmlpack_1_1data_1_1DictionaryEncodingPolicy.html" title="DicitonaryEnocdingPolicy is used as a helper class for StringEncoding.">DictionaryEncodingPolicy</a> and the default dictionary for the given token type.  <a href="namespacemlpack_1_1data.html#aaa7ca4dc9e2a0d1189d7717b98c01933">More...</a><br /></td></tr>
<tr class="separator:aaa7ca4dc9e2a0d1189d7717b98c01933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc64c1431b690f470d4949729d31191f"><td class="memTemplParams" colspan="2">template&lt;typename TokenType &gt; </td></tr>
<tr class="memitem:adc64c1431b690f470d4949729d31191f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#adc64c1431b690f470d4949729d31191f">TfIdfEncoding</a> = <a class="el" href="classmlpack_1_1data_1_1StringEncoding.html">StringEncoding</a>&lt; <a class="el" href="classmlpack_1_1data_1_1TfIdfEncodingPolicy.html">TfIdfEncodingPolicy</a>, <a class="el" href="classmlpack_1_1data_1_1StringEncodingDictionary.html">StringEncodingDictionary</a>&lt; TokenType &gt; &gt;</td></tr>
<tr class="memdesc:adc64c1431b690f470d4949729d31191f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenient alias for the <a class="el" href="classmlpack_1_1data_1_1StringEncoding.html" title="The class translates a set of strings into numbers using various encoding algorithms.">StringEncoding</a> class with <a class="el" href="classmlpack_1_1data_1_1TfIdfEncodingPolicy.html" title="Definition of the TfIdfEncodingPolicy class.">TfIdfEncodingPolicy</a> and the default dictionary for the given token type.  <a href="namespacemlpack_1_1data.html#adc64c1431b690f470d4949729d31191f">More...</a><br /></td></tr>
<tr class="separator:adc64c1431b690f470d4949729d31191f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aa7714fa0b7efc7b31cbda21da607c5b6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#aa7714fa0b7efc7b31cbda21da607c5b6">Datatype</a> : bool { <br />
&#160;&#160;<a class="el" href="namespacemlpack_1_1data.html#aa7714fa0b7efc7b31cbda21da607c5b6a1b5484703e716389553255e6f11f12ec">numeric</a> = 0
, <br />
&#160;&#160;<a class="el" href="namespacemlpack_1_1data.html#aa7714fa0b7efc7b31cbda21da607c5b6a2992a7ab833605792145cd40762644c7">categorical</a> = 1
<br />
 }</td></tr>
<tr class="memdesc:aa7714fa0b7efc7b31cbda21da607c5b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Datatype enum specifies the types of data mlpack algorithms can use.  <a href="namespacemlpack_1_1data.html#aa7714fa0b7efc7b31cbda21da607c5b6">More...</a><br /></td></tr>
<tr class="separator:aa7714fa0b7efc7b31cbda21da607c5b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a387137c43ed9616d39ba90e890d181eb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a387137c43ed9616d39ba90e890d181eb">format</a> { <br />
&#160;&#160;<a class="el" href="namespacemlpack_1_1data.html#a387137c43ed9616d39ba90e890d181eba7038b9ea9dd309cf5cc8f7122f6c0cee">autodetect</a>
, <br />
&#160;&#160;<a class="el" href="namespacemlpack_1_1data.html#a387137c43ed9616d39ba90e890d181eba23ac0259f4d3527268c85207a3c2e1f0">json</a>
, <br />
&#160;&#160;<a class="el" href="namespacemlpack_1_1data.html#a387137c43ed9616d39ba90e890d181ebac0a194d2e3cadd6447861e57368c2581">xml</a>
, <br />
&#160;&#160;<a class="el" href="namespacemlpack_1_1data.html#a387137c43ed9616d39ba90e890d181eba4c41ae0ac8cc59e0caeaa4984dd5d469">binary</a>
<br />
 }</td></tr>
<tr class="memdesc:a387137c43ed9616d39ba90e890d181eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the formats we can read through cereal.  <a href="namespacemlpack_1_1data.html#a387137c43ed9616d39ba90e890d181eb">More...</a><br /></td></tr>
<tr class="separator:a387137c43ed9616d39ba90e890d181eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa47724fc0e8e354c6ca18818d81705a3"><td class="memItemLeft" align="right" valign="top">arma::file_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#aa47724fc0e8e354c6ca18818d81705a3">AutoDetect</a> (std::fstream &amp;stream, const std::string &amp;filename)</td></tr>
<tr class="memdesc:aa47724fc0e8e354c6ca18818d81705a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to auto-detect the type of a file given its extension, and by inspecting the parts of the file to disambiguate between types when necessary.  <a href="namespacemlpack_1_1data.html#aa47724fc0e8e354c6ca18818d81705a3">More...</a><br /></td></tr>
<tr class="separator:aa47724fc0e8e354c6ca18818d81705a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28da72e55467d0872681827b30b490ac"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a28da72e55467d0872681827b30b490ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a28da72e55467d0872681827b30b490ac">Binarize</a> (const arma::Mat&lt; T &gt; &amp;input, arma::Mat&lt; T &gt; &amp;output, const double threshold)</td></tr>
<tr class="memdesc:a28da72e55467d0872681827b30b490ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input dataset and threshold, set values greater than threshold to 1 and values less than or equal to the threshold to 0.  <a href="namespacemlpack_1_1data.html#a28da72e55467d0872681827b30b490ac">More...</a><br /></td></tr>
<tr class="separator:a28da72e55467d0872681827b30b490ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39606420520e81f5e87d6ea1e64c27ae"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a39606420520e81f5e87d6ea1e64c27ae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a39606420520e81f5e87d6ea1e64c27ae">Binarize</a> (const arma::Mat&lt; T &gt; &amp;input, arma::Mat&lt; T &gt; &amp;output, const double threshold, const size_t dimension)</td></tr>
<tr class="memdesc:a39606420520e81f5e87d6ea1e64c27ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input dataset and threshold, set values greater than threshold to 1 and values less than or equal to the threshold to 0.  <a href="namespacemlpack_1_1data.html#a39606420520e81f5e87d6ea1e64c27ae">More...</a><br /></td></tr>
<tr class="separator:a39606420520e81f5e87d6ea1e64c27ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb1b3de86790e53265efa63e5965d41"><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr class="memitem:a3bb1b3de86790e53265efa63e5965d41"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a3bb1b3de86790e53265efa63e5965d41">ConfusionMatrix</a> (const arma::Row&lt; size_t &gt; predictors, const arma::Row&lt; size_t &gt; responses, arma::Mat&lt; eT &gt; &amp;output, const size_t numClasses)</td></tr>
<tr class="memdesc:a3bb1b3de86790e53265efa63e5965d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">A confusion matrix is a summary of prediction results on a classification problem.  <a href="namespacemlpack_1_1data.html#a3bb1b3de86790e53265efa63e5965d41">More...</a><br /></td></tr>
<tr class="separator:a3bb1b3de86790e53265efa63e5965d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3115b81a148283970b530603b3f2aaa"><td class="memItemLeft" align="right" valign="top">arma::file_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#ac3115b81a148283970b530603b3f2aaa">DetectFromExtension</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:ac3115b81a148283970b530603b3f2aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the type based only on the extension.  <a href="namespacemlpack_1_1data.html#ac3115b81a148283970b530603b3f2aaa">More...</a><br /></td></tr>
<tr class="separator:ac3115b81a148283970b530603b3f2aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a13b28050a64b446916c067e1466951"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a5a13b28050a64b446916c067e1466951">Extension</a> (const std::string &amp;filename)</td></tr>
<tr class="separator:a5a13b28050a64b446916c067e1466951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a898633566d45ba664faacc815915e416"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a898633566d45ba664faacc815915e416">GetStringType</a> (const arma::file_type &amp;type)</td></tr>
<tr class="memdesc:a898633566d45ba664faacc815915e416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a file type, return a logical name corresponding to that file type.  <a href="namespacemlpack_1_1data.html#a898633566d45ba664faacc815915e416">More...</a><br /></td></tr>
<tr class="separator:a898633566d45ba664faacc815915e416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f0956c373bd666d19e70551fecaf90"><td class="memItemLeft" align="right" valign="top">arma::file_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#aa2f0956c373bd666d19e70551fecaf90">GuessFileType</a> (std::istream &amp;f)</td></tr>
<tr class="memdesc:aa2f0956c373bd666d19e70551fecaf90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an istream, attempt to guess the file type.  <a href="namespacemlpack_1_1data.html#aa2f0956c373bd666d19e70551fecaf90">More...</a><br /></td></tr>
<tr class="separator:aa2f0956c373bd666d19e70551fecaf90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb5cb8a6b868db7d521f8efbe03b6728"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#acb5cb8a6b868db7d521f8efbe03b6728">HAS_EXACT_METHOD_FORM</a> (serialize, HasSerializeCheck)</td></tr>
<tr class="separator:acb5cb8a6b868db7d521f8efbe03b6728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6814f77346f5af80d2c25ef3206713cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a6814f77346f5af80d2c25ef3206713cb">ImageFormatSupported</a> (const std::string &amp;fileName, const bool save=false)</td></tr>
<tr class="memdesc:a6814f77346f5af80d2c25ef3206713cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given image filename is supported.  <a href="namespacemlpack_1_1data.html#a6814f77346f5af80d2c25ef3206713cb">More...</a><br /></td></tr>
<tr class="separator:a6814f77346f5af80d2c25ef3206713cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3799ea79b454b97c5f79a82db6958a1b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3799ea79b454b97c5f79a82db6958a1b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a3799ea79b454b97c5f79a82db6958a1b">IsNaNInf</a> (T &amp;val, const std::string &amp;token)</td></tr>
<tr class="memdesc:a3799ea79b454b97c5f79a82db6958a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">See if the token is a NaN or an Inf, and if so, set the value accordingly and return a boolean representing whether or not it is.  <a href="namespacemlpack_1_1data.html#a3799ea79b454b97c5f79a82db6958a1b">More...</a><br /></td></tr>
<tr class="separator:a3799ea79b454b97c5f79a82db6958a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0c6adf83024427e47a03bd7fbfb885"><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr class="memitem:adb0c6adf83024427e47a03bd7fbfb885"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#adb0c6adf83024427e47a03bd7fbfb885">Load</a> (const std::string &amp;filename, arma::Col&lt; eT &gt; &amp;vec, const bool fatal=false)</td></tr>
<tr class="memdesc:adb0c6adf83024427e47a03bd7fbfb885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Don't document these with doxygen; these declarations aren't helpful to users.  <a href="namespacemlpack_1_1data.html#adb0c6adf83024427e47a03bd7fbfb885">More...</a><br /></td></tr>
<tr class="separator:adb0c6adf83024427e47a03bd7fbfb885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbff2a667bf247e00b1fc09b7ca5f831"><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr class="memitem:abbff2a667bf247e00b1fc09b7ca5f831"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#abbff2a667bf247e00b1fc09b7ca5f831">Load</a> (const std::string &amp;filename, arma::Mat&lt; eT &gt; &amp;matrix, const bool fatal=false, const bool transpose=true, const arma::file_type inputLoadType=arma::auto_detect)</td></tr>
<tr class="memdesc:abbff2a667bf247e00b1fc09b7ca5f831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a matrix from file, guessing the filetype from the extension.  <a href="namespacemlpack_1_1data.html#abbff2a667bf247e00b1fc09b7ca5f831">More...</a><br /></td></tr>
<tr class="separator:abbff2a667bf247e00b1fc09b7ca5f831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af06d46f91871c42f38e30aac5d4666"><td class="memTemplParams" colspan="2">template&lt;typename eT , typename PolicyType &gt; </td></tr>
<tr class="memitem:a9af06d46f91871c42f38e30aac5d4666"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a9af06d46f91871c42f38e30aac5d4666">Load</a> (const std::string &amp;filename, arma::Mat&lt; eT &gt; &amp;matrix, <a class="el" href="classmlpack_1_1data_1_1DatasetMapper.html">DatasetMapper</a>&lt; PolicyType &gt; &amp;info, const bool fatal=false, const bool transpose=true)</td></tr>
<tr class="memdesc:a9af06d46f91871c42f38e30aac5d4666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a matrix from a file, guessing the filetype from the extension and mapping categorical features with a <a class="el" href="classmlpack_1_1data_1_1DatasetMapper.html" title="Auxiliary information for a dataset, including mappings to/from strings (or other types) and the data...">DatasetMapper</a> object.  <a href="namespacemlpack_1_1data.html#a9af06d46f91871c42f38e30aac5d4666">More...</a><br /></td></tr>
<tr class="separator:a9af06d46f91871c42f38e30aac5d4666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa05aba27ed8693c1c4ed538240a549b1"><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr class="memitem:aa05aba27ed8693c1c4ed538240a549b1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#aa05aba27ed8693c1c4ed538240a549b1">Load</a> (const std::string &amp;filename, arma::Mat&lt; eT &gt; &amp;matrix, <a class="el" href="classmlpack_1_1data_1_1ImageInfo.html">ImageInfo</a> &amp;info, const bool fatal=false)</td></tr>
<tr class="memdesc:aa05aba27ed8693c1c4ed538240a549b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Image load/save interfaces.  <a href="namespacemlpack_1_1data.html#aa05aba27ed8693c1c4ed538240a549b1">More...</a><br /></td></tr>
<tr class="separator:aa05aba27ed8693c1c4ed538240a549b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5679a4dc8c6129e3895a1089855d25d"><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr class="memitem:ac5679a4dc8c6129e3895a1089855d25d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#ac5679a4dc8c6129e3895a1089855d25d">Load</a> (const std::string &amp;filename, arma::Row&lt; eT &gt; &amp;rowvec, const bool fatal=false)</td></tr>
<tr class="memdesc:ac5679a4dc8c6129e3895a1089855d25d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a row vector from a file, guessing the filetype from the extension.  <a href="namespacemlpack_1_1data.html#ac5679a4dc8c6129e3895a1089855d25d">More...</a><br /></td></tr>
<tr class="separator:ac5679a4dc8c6129e3895a1089855d25d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bfd894be870a3409cc7d3b10b08d689"><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr class="memitem:a7bfd894be870a3409cc7d3b10b08d689"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a7bfd894be870a3409cc7d3b10b08d689">Load</a> (const std::string &amp;filename, arma::SpMat&lt; eT &gt; &amp;matrix, const bool fatal=false, const bool transpose=true)</td></tr>
<tr class="memdesc:a7bfd894be870a3409cc7d3b10b08d689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a sparse matrix from file, using arma::coord_ascii format.  <a href="namespacemlpack_1_1data.html#a7bfd894be870a3409cc7d3b10b08d689">More...</a><br /></td></tr>
<tr class="separator:a7bfd894be870a3409cc7d3b10b08d689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0441d5f7e76f0fcdeec487d4a9732ac"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac0441d5f7e76f0fcdeec487d4a9732ac"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#ac0441d5f7e76f0fcdeec487d4a9732ac">Load</a> (const std::string &amp;filename, const std::string &amp;name, T &amp;t, const bool fatal=false, <a class="el" href="namespacemlpack_1_1data.html#a387137c43ed9616d39ba90e890d181eb">format</a> f=format::autodetect)</td></tr>
<tr class="memdesc:ac0441d5f7e76f0fcdeec487d4a9732ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Don't document these with doxygen; they aren't helpful for users to know about.  <a href="namespacemlpack_1_1data.html#ac0441d5f7e76f0fcdeec487d4a9732ac">More...</a><br /></td></tr>
<tr class="separator:ac0441d5f7e76f0fcdeec487d4a9732ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6afb44303645116a32d1ed168e0ff1"><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr class="memitem:adf6afb44303645116a32d1ed168e0ff1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#adf6afb44303645116a32d1ed168e0ff1">Load</a> (const std::vector&lt; std::string &gt; &amp;files, arma::Mat&lt; eT &gt; &amp;matrix, <a class="el" href="classmlpack_1_1data_1_1ImageInfo.html">ImageInfo</a> &amp;info, const bool fatal=false)</td></tr>
<tr class="memdesc:adf6afb44303645116a32d1ed168e0ff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the image file into the given matrix.  <a href="namespacemlpack_1_1data.html#adf6afb44303645116a32d1ed168e0ff1">More...</a><br /></td></tr>
<tr class="separator:adf6afb44303645116a32d1ed168e0ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a951a7dc1fd86524b8dd245bb91841731"><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr class="memitem:a951a7dc1fd86524b8dd245bb91841731"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a951a7dc1fd86524b8dd245bb91841731">LoadARFF</a> (const std::string &amp;filename, arma::Mat&lt; eT &gt; &amp;matrix)</td></tr>
<tr class="memdesc:a951a7dc1fd86524b8dd245bb91841731"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function to load an ARFF dataset as numeric features (that is, as an Armadillo matrix without any modification).  <a href="namespacemlpack_1_1data.html#a951a7dc1fd86524b8dd245bb91841731">More...</a><br /></td></tr>
<tr class="separator:a951a7dc1fd86524b8dd245bb91841731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a4a09a274c068e08373200fe611422"><td class="memTemplParams" colspan="2">template&lt;typename eT , typename PolicyType &gt; </td></tr>
<tr class="memitem:aa2a4a09a274c068e08373200fe611422"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#aa2a4a09a274c068e08373200fe611422">LoadARFF</a> (const std::string &amp;filename, arma::Mat&lt; eT &gt; &amp;matrix, <a class="el" href="classmlpack_1_1data_1_1DatasetMapper.html">DatasetMapper</a>&lt; PolicyType &gt; &amp;info)</td></tr>
<tr class="memdesc:aa2a4a09a274c068e08373200fe611422"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function to load an ARFF dataset as numeric and categorical features, using the DatasetInfo structure for mapping.  <a href="namespacemlpack_1_1data.html#aa2a4a09a274c068e08373200fe611422">More...</a><br /></td></tr>
<tr class="separator:aa2a4a09a274c068e08373200fe611422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01155770d761c5cf686a666f3622caa5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a01155770d761c5cf686a666f3622caa5">LoadImage</a> (const std::string &amp;filename, arma::Mat&lt; unsigned char &gt; &amp;matrix, <a class="el" href="classmlpack_1_1data_1_1ImageInfo.html">ImageInfo</a> &amp;info, const bool fatal=false)</td></tr>
<tr class="separator:a01155770d761c5cf686a666f3622caa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664b3fa5243889e2aed47ee750f840ed"><td class="memTemplParams" colspan="2">template&lt;typename eT , typename RowType &gt; </td></tr>
<tr class="memitem:a664b3fa5243889e2aed47ee750f840ed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a664b3fa5243889e2aed47ee750f840ed">NormalizeLabels</a> (const RowType &amp;labelsIn, arma::Row&lt; size_t &gt; &amp;labels, arma::Col&lt; eT &gt; &amp;mapping)</td></tr>
<tr class="memdesc:a664b3fa5243889e2aed47ee750f840ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of labels of a particular datatype, convert them to unsigned labels in the range [0, n) where n is the number of different labels.  <a href="namespacemlpack_1_1data.html#a664b3fa5243889e2aed47ee750f840ed">More...</a><br /></td></tr>
<tr class="separator:a664b3fa5243889e2aed47ee750f840ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a007765ae6ce1f59513e6644bd2c66988"><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr class="memitem:a007765ae6ce1f59513e6644bd2c66988"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a007765ae6ce1f59513e6644bd2c66988">OneHotEncoding</a> (const arma::Mat&lt; eT &gt; &amp;input, arma::Mat&lt; eT &gt; &amp;output, const <a class="el" href="namespacemlpack_1_1data.html#aa243ad7e4d29363b858bbc92b732921d">data::DatasetInfo</a> &amp;datasetInfo)</td></tr>
<tr class="memdesc:a007765ae6ce1f59513e6644bd2c66988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded function for the above function, which takes a matrix as input and also a DatasetInfo object and outputs a matrix.  <a href="namespacemlpack_1_1data.html#a007765ae6ce1f59513e6644bd2c66988">More...</a><br /></td></tr>
<tr class="separator:a007765ae6ce1f59513e6644bd2c66988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f3e880da9955942bd129414fe617a9"><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr class="memitem:a91f3e880da9955942bd129414fe617a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a91f3e880da9955942bd129414fe617a9">OneHotEncoding</a> (const arma::Mat&lt; eT &gt; &amp;input, const arma::Col&lt; size_t &gt; &amp;indices, arma::Mat&lt; eT &gt; &amp;output)</td></tr>
<tr class="memdesc:a91f3e880da9955942bd129414fe617a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded function for the above function, which takes a matrix as input and also a vector of indices to encode and outputs a matrix.  <a href="namespacemlpack_1_1data.html#a91f3e880da9955942bd129414fe617a9">More...</a><br /></td></tr>
<tr class="separator:a91f3e880da9955942bd129414fe617a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d41d92266983ceb192346478a54ec23"><td class="memTemplParams" colspan="2">template&lt;typename RowType , typename MatType &gt; </td></tr>
<tr class="memitem:a0d41d92266983ceb192346478a54ec23"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a0d41d92266983ceb192346478a54ec23">OneHotEncoding</a> (const RowType &amp;labelsIn, MatType &amp;output)</td></tr>
<tr class="memdesc:a0d41d92266983ceb192346478a54ec23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of labels of a particular datatype, convert them to binary vector.  <a href="namespacemlpack_1_1data.html#a0d41d92266983ceb192346478a54ec23">More...</a><br /></td></tr>
<tr class="separator:a0d41d92266983ceb192346478a54ec23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a901fe08dcdc58734f64a864dbdef0a28"><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr class="memitem:a901fe08dcdc58734f64a864dbdef0a28"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a901fe08dcdc58734f64a864dbdef0a28">RevertLabels</a> (const arma::Row&lt; size_t &gt; &amp;labels, const arma::Col&lt; eT &gt; &amp;mapping, arma::Row&lt; eT &gt; &amp;labelsOut)</td></tr>
<tr class="memdesc:a901fe08dcdc58734f64a864dbdef0a28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of labels that have been mapped to the range [0, n), map them back to the original labels given by the 'mapping' vector.  <a href="namespacemlpack_1_1data.html#a901fe08dcdc58734f64a864dbdef0a28">More...</a><br /></td></tr>
<tr class="separator:a901fe08dcdc58734f64a864dbdef0a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a255acca42390d66faaed4521eb502de8"><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr class="memitem:a255acca42390d66faaed4521eb502de8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a255acca42390d66faaed4521eb502de8">Save</a> (const std::string &amp;filename, arma::Mat&lt; eT &gt; &amp;matrix, <a class="el" href="classmlpack_1_1data_1_1ImageInfo.html">ImageInfo</a> &amp;info, const bool fatal=false)</td></tr>
<tr class="memdesc:a255acca42390d66faaed4521eb502de8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the image file from the given matrix.  <a href="namespacemlpack_1_1data.html#a255acca42390d66faaed4521eb502de8">More...</a><br /></td></tr>
<tr class="separator:a255acca42390d66faaed4521eb502de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd1605a1d160c09ee75c93a587dc313"><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr class="memitem:accd1605a1d160c09ee75c93a587dc313"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#accd1605a1d160c09ee75c93a587dc313">Save</a> (const std::string &amp;filename, const arma::Mat&lt; eT &gt; &amp;matrix, const bool fatal=false, bool transpose=true, arma::file_type inputSaveType=arma::auto_detect)</td></tr>
<tr class="memdesc:accd1605a1d160c09ee75c93a587dc313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves a matrix to file, guessing the filetype from the extension.  <a href="namespacemlpack_1_1data.html#accd1605a1d160c09ee75c93a587dc313">More...</a><br /></td></tr>
<tr class="separator:accd1605a1d160c09ee75c93a587dc313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5510cd863171eb3bc1dec000a78b482"><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr class="memitem:ad5510cd863171eb3bc1dec000a78b482"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#ad5510cd863171eb3bc1dec000a78b482">Save</a> (const std::string &amp;filename, const arma::SpMat&lt; eT &gt; &amp;matrix, const bool fatal=false, bool transpose=true)</td></tr>
<tr class="memdesc:ad5510cd863171eb3bc1dec000a78b482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves a sparse matrix to file, guessing the filetype from the extension.  <a href="namespacemlpack_1_1data.html#ad5510cd863171eb3bc1dec000a78b482">More...</a><br /></td></tr>
<tr class="separator:ad5510cd863171eb3bc1dec000a78b482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30f8bfca9b924d6d935c9f1fae91778"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af30f8bfca9b924d6d935c9f1fae91778"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#af30f8bfca9b924d6d935c9f1fae91778">Save</a> (const std::string &amp;filename, const std::string &amp;name, T &amp;t, const bool fatal=false, <a class="el" href="namespacemlpack_1_1data.html#a387137c43ed9616d39ba90e890d181eb">format</a> f=format::autodetect)</td></tr>
<tr class="memdesc:af30f8bfca9b924d6d935c9f1fae91778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves a model to file, guessing the filetype from the extension, or, optionally, saving the specified format.  <a href="namespacemlpack_1_1data.html#af30f8bfca9b924d6d935c9f1fae91778">More...</a><br /></td></tr>
<tr class="separator:af30f8bfca9b924d6d935c9f1fae91778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9402b433306b2735be417a07d8397d9c"><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr class="memitem:a9402b433306b2735be417a07d8397d9c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a9402b433306b2735be417a07d8397d9c">Save</a> (const std::vector&lt; std::string &gt; &amp;files, arma::Mat&lt; eT &gt; &amp;matrix, <a class="el" href="classmlpack_1_1data_1_1ImageInfo.html">ImageInfo</a> &amp;info, const bool fatal=false)</td></tr>
<tr class="memdesc:a9402b433306b2735be417a07d8397d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the image file from the given matrix.  <a href="namespacemlpack_1_1data.html#a9402b433306b2735be417a07d8397d9c">More...</a><br /></td></tr>
<tr class="separator:a9402b433306b2735be417a07d8397d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5053734839d456ce3bfe20b16a467d0c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a5053734839d456ce3bfe20b16a467d0c">SaveImage</a> (const std::string &amp;filename, arma::Mat&lt; unsigned char &gt; &amp;image, <a class="el" href="classmlpack_1_1data_1_1ImageInfo.html">ImageInfo</a> &amp;info, const bool fatal=false)</td></tr>
<tr class="memdesc:a5053734839d456ce3bfe20b16a467d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to save files.  <a href="namespacemlpack_1_1data.html#a5053734839d456ce3bfe20b16a467d0c">More...</a><br /></td></tr>
<tr class="separator:a5053734839d456ce3bfe20b16a467d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac4c8b737e134361d49d5c1c3f9f6ba"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0ac4c8b737e134361d49d5c1c3f9f6ba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a0ac4c8b737e134361d49d5c1c3f9f6ba">Split</a> (const arma::Mat&lt; T &gt; &amp;input, arma::Mat&lt; T &gt; &amp;trainData, arma::Mat&lt; T &gt; &amp;testData, const double testRatio, const bool shuffleData=true)</td></tr>
<tr class="memdesc:a0ac4c8b737e134361d49d5c1c3f9f6ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input dataset, split into a training set and test set.  <a href="namespacemlpack_1_1data.html#a0ac4c8b737e134361d49d5c1c3f9f6ba">More...</a><br /></td></tr>
<tr class="separator:a0ac4c8b737e134361d49d5c1c3f9f6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a5ecc1018b88a9cbe745e67d1e8672"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a91a5ecc1018b88a9cbe745e67d1e8672"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; arma::Mat&lt; T &gt;, arma::Mat&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a91a5ecc1018b88a9cbe745e67d1e8672">Split</a> (const arma::Mat&lt; T &gt; &amp;input, const double testRatio, const bool shuffleData=true)</td></tr>
<tr class="memdesc:a91a5ecc1018b88a9cbe745e67d1e8672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input dataset, split into a training set and test set.  <a href="namespacemlpack_1_1data.html#a91a5ecc1018b88a9cbe745e67d1e8672">More...</a><br /></td></tr>
<tr class="separator:a91a5ecc1018b88a9cbe745e67d1e8672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f749a2ac526fd90ab112400fad6ef2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename LabelsType , typename  = std::enable_if_t&lt;arma::is_arma_type&lt;LabelsType&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a32f749a2ac526fd90ab112400fad6ef2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a32f749a2ac526fd90ab112400fad6ef2">Split</a> (const arma::Mat&lt; T &gt; &amp;input, const LabelsType &amp;inputLabel, arma::Mat&lt; T &gt; &amp;trainData, arma::Mat&lt; T &gt; &amp;testData, LabelsType &amp;trainLabel, LabelsType &amp;testLabel, const double testRatio, const bool shuffleData=true)</td></tr>
<tr class="memdesc:a32f749a2ac526fd90ab112400fad6ef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input dataset and labels, split into a training set and test set.  <a href="namespacemlpack_1_1data.html#a32f749a2ac526fd90ab112400fad6ef2">More...</a><br /></td></tr>
<tr class="separator:a32f749a2ac526fd90ab112400fad6ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ad55a3d28296d823078fe7d0ced9b2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename LabelsType , typename  = std::enable_if_t&lt;arma::is_arma_type&lt;LabelsType&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a38ad55a3d28296d823078fe7d0ced9b2"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; arma::Mat&lt; T &gt;, arma::Mat&lt; T &gt;, LabelsType, LabelsType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a38ad55a3d28296d823078fe7d0ced9b2">Split</a> (const arma::Mat&lt; T &gt; &amp;input, const LabelsType &amp;inputLabel, const double testRatio, const bool shuffleData=true, const bool stratifyData=false)</td></tr>
<tr class="memdesc:a38ad55a3d28296d823078fe7d0ced9b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input dataset and labels, split into a training set and test set.  <a href="namespacemlpack_1_1data.html#a38ad55a3d28296d823078fe7d0ced9b2">More...</a><br /></td></tr>
<tr class="separator:a38ad55a3d28296d823078fe7d0ced9b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744850e5ad47df5e0af6f5845009a4d2"><td class="memTemplParams" colspan="2">template&lt;class FieldType , typename T , class  = std::enable_if_t&lt;              arma::is_Col&lt;typename FieldType::object_type&gt;::value ||              arma::is_Mat_only&lt;typename FieldType::object_type&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a744850e5ad47df5e0af6f5845009a4d2"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; FieldType, FieldType, arma::field&lt; T &gt;, arma::field&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a744850e5ad47df5e0af6f5845009a4d2">Split</a> (const FieldType &amp;input, const arma::field&lt; T &gt; &amp;inputLabel, const double testRatio, const bool shuffleData=true)</td></tr>
<tr class="memdesc:a744850e5ad47df5e0af6f5845009a4d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input dataset and labels, split into a training set and test set.  <a href="namespacemlpack_1_1data.html#a744850e5ad47df5e0af6f5845009a4d2">More...</a><br /></td></tr>
<tr class="separator:a744850e5ad47df5e0af6f5845009a4d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bca254ee313ff590e7d1bcada13d72a"><td class="memTemplParams" colspan="2">template&lt;typename FieldType , typename T , typename  = std::enable_if_t&lt;              arma::is_Col&lt;typename FieldType::object_type&gt;::value ||              arma::is_Mat_only&lt;typename FieldType::object_type&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a7bca254ee313ff590e7d1bcada13d72a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a7bca254ee313ff590e7d1bcada13d72a">Split</a> (const FieldType &amp;input, const arma::field&lt; T &gt; &amp;inputLabel, FieldType &amp;trainData, arma::field&lt; T &gt; &amp;trainLabel, FieldType &amp;testData, arma::field&lt; T &gt; &amp;testLabel, const double testRatio, const bool shuffleData=true)</td></tr>
<tr class="memdesc:a7bca254ee313ff590e7d1bcada13d72a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input dataset and labels, split into a training set and test set.  <a href="namespacemlpack_1_1data.html#a7bca254ee313ff590e7d1bcada13d72a">More...</a><br /></td></tr>
<tr class="separator:a7bca254ee313ff590e7d1bcada13d72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b163f42a48fdc8993c2165f9089494"><td class="memTemplParams" colspan="2">template&lt;class FieldType , class  = std::enable_if_t&lt;              arma::is_Col&lt;typename FieldType::object_type&gt;::value ||              arma::is_Mat_only&lt;typename FieldType::object_type&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:af9b163f42a48fdc8993c2165f9089494"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; FieldType, FieldType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#af9b163f42a48fdc8993c2165f9089494">Split</a> (const FieldType &amp;input, const double testRatio, const bool shuffleData=true)</td></tr>
<tr class="memdesc:af9b163f42a48fdc8993c2165f9089494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input dataset, split into a training set and test set.  <a href="namespacemlpack_1_1data.html#af9b163f42a48fdc8993c2165f9089494">More...</a><br /></td></tr>
<tr class="separator:af9b163f42a48fdc8993c2165f9089494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0baaf8bcdf473761f7c59c9e1577d1f1"><td class="memTemplParams" colspan="2">template&lt;class FieldType , class  = std::enable_if_t&lt;              arma::is_Col&lt;typename FieldType::object_type&gt;::value ||              arma::is_Mat_only&lt;typename FieldType::object_type&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a0baaf8bcdf473761f7c59c9e1577d1f1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a0baaf8bcdf473761f7c59c9e1577d1f1">Split</a> (const FieldType &amp;input, FieldType &amp;trainData, FieldType &amp;testData, const double testRatio, const bool shuffleData=true)</td></tr>
<tr class="memdesc:a0baaf8bcdf473761f7c59c9e1577d1f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input dataset, split into a training set and test set.  <a href="namespacemlpack_1_1data.html#a0baaf8bcdf473761f7c59c9e1577d1f1">More...</a><br /></td></tr>
<tr class="separator:a0baaf8bcdf473761f7c59c9e1577d1f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ba4ec838f0ac7dd92c69b6c60dfb22"><td class="memTemplParams" colspan="2">template&lt;typename InputType &gt; </td></tr>
<tr class="memitem:aa8ba4ec838f0ac7dd92c69b6c60dfb22"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#aa8ba4ec838f0ac7dd92c69b6c60dfb22">SplitHelper</a> (const InputType &amp;input, InputType &amp;train, InputType &amp;test, const double testRatio, const arma::uvec &amp;order=arma::uvec())</td></tr>
<tr class="memdesc:aa8ba4ec838f0ac7dd92c69b6c60dfb22"><td class="mdescLeft">&#160;</td><td class="mdescRight">This helper function splits any <code>input</code> data into training and testing parts.  <a href="namespacemlpack_1_1data.html#aa8ba4ec838f0ac7dd92c69b6c60dfb22">More...</a><br /></td></tr>
<tr class="separator:aa8ba4ec838f0ac7dd92c69b6c60dfb22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5943effbe5980ae3af45b5e62240fc8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename LabelsType , typename  = std::enable_if_t&lt;arma::is_arma_type&lt;LabelsType&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ae5943effbe5980ae3af45b5e62240fc8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#ae5943effbe5980ae3af45b5e62240fc8">StratifiedSplit</a> (const arma::Mat&lt; T &gt; &amp;input, const LabelsType &amp;inputLabel, arma::Mat&lt; T &gt; &amp;trainData, arma::Mat&lt; T &gt; &amp;testData, LabelsType &amp;trainLabel, LabelsType &amp;testLabel, const double testRatio, const bool shuffleData=true)</td></tr>
<tr class="memdesc:ae5943effbe5980ae3af45b5e62240fc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input dataset and labels, stratify into a training set and test set.  <a href="namespacemlpack_1_1data.html#ae5943effbe5980ae3af45b5e62240fc8">More...</a><br /></td></tr>
<tr class="separator:ae5943effbe5980ae3af45b5e62240fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Functions to load and save matrices and models. </p>
<p>Functions to load and save matrices. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a728f5dac92331960e1e5822919dd2a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a728f5dac92331960e1e5822919dd2a41">&#9670;&nbsp;</a></span>BagOfWordsEncoding</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlpack_1_1data.html#a728f5dac92331960e1e5822919dd2a41">BagOfWordsEncoding</a> =  <a class="el" href="classmlpack_1_1data_1_1StringEncoding.html">StringEncoding</a>&lt;<a class="el" href="classmlpack_1_1data_1_1BagOfWordsEncodingPolicy.html">BagOfWordsEncodingPolicy</a>, <a class="el" href="classmlpack_1_1data_1_1StringEncodingDictionary.html">StringEncodingDictionary</a>&lt;TokenType&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenient alias for the <a class="el" href="classmlpack_1_1data_1_1StringEncoding.html" title="The class translates a set of strings into numbers using various encoding algorithms.">StringEncoding</a> class with <a class="el" href="classmlpack_1_1data_1_1BagOfWordsEncodingPolicy.html" title="Definition of the BagOfWordsEncodingPolicy class.">BagOfWordsEncodingPolicy</a> and the default dictionary for the given token type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TokenType</td><td>Type of the tokens. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bag__of__words__encoding__policy_8hpp_source.html#l00166">166</a> of file <a class="el" href="bag__of__words__encoding__policy_8hpp_source.html">bag_of_words_encoding_policy.hpp</a>.</p>

</div>
</div>
<a id="aa243ad7e4d29363b858bbc92b732921d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa243ad7e4d29363b858bbc92b732921d">&#9670;&nbsp;</a></span>DatasetInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classmlpack_1_1data_1_1DatasetMapper.html">DatasetMapper</a>&lt; <a class="el" href="classmlpack_1_1data_1_1IncrementPolicy.html">IncrementPolicy</a>, std::string &gt; <a class="el" href="namespacemlpack_1_1data.html#aa243ad7e4d29363b858bbc92b732921d">DatasetInfo</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="dataset__mapper_8hpp_source.html#l00196">196</a> of file <a class="el" href="dataset__mapper_8hpp_source.html">dataset_mapper.hpp</a>.</p>

</div>
</div>
<a id="aaa7ca4dc9e2a0d1189d7717b98c01933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa7ca4dc9e2a0d1189d7717b98c01933">&#9670;&nbsp;</a></span>DictionaryEncoding</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlpack_1_1data.html#aaa7ca4dc9e2a0d1189d7717b98c01933">DictionaryEncoding</a> =  <a class="el" href="classmlpack_1_1data_1_1StringEncoding.html">StringEncoding</a>&lt;<a class="el" href="classmlpack_1_1data_1_1DictionaryEncodingPolicy.html">DictionaryEncodingPolicy</a>, <a class="el" href="classmlpack_1_1data_1_1StringEncodingDictionary.html">StringEncodingDictionary</a>&lt;TokenType&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenient alias for the <a class="el" href="classmlpack_1_1data_1_1StringEncoding.html" title="The class translates a set of strings into numbers using various encoding algorithms.">StringEncoding</a> class with <a class="el" href="classmlpack_1_1data_1_1DictionaryEncodingPolicy.html" title="DicitonaryEnocdingPolicy is used as a helper class for StringEncoding.">DictionaryEncodingPolicy</a> and the default dictionary for the given token type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TokenType</td><td>Type of the tokens. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="dictionary__encoding__policy_8hpp_source.html#l00145">145</a> of file <a class="el" href="dictionary__encoding__policy_8hpp_source.html">dictionary_encoding_policy.hpp</a>.</p>

</div>
</div>
<a id="adc64c1431b690f470d4949729d31191f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc64c1431b690f470d4949729d31191f">&#9670;&nbsp;</a></span>TfIdfEncoding</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlpack_1_1data.html#adc64c1431b690f470d4949729d31191f">TfIdfEncoding</a> =  <a class="el" href="classmlpack_1_1data_1_1StringEncoding.html">StringEncoding</a>&lt;<a class="el" href="classmlpack_1_1data_1_1TfIdfEncodingPolicy.html">TfIdfEncodingPolicy</a>, <a class="el" href="classmlpack_1_1data_1_1StringEncodingDictionary.html">StringEncodingDictionary</a>&lt;TokenType&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenient alias for the <a class="el" href="classmlpack_1_1data_1_1StringEncoding.html" title="The class translates a set of strings into numbers using various encoding algorithms.">StringEncoding</a> class with <a class="el" href="classmlpack_1_1data_1_1TfIdfEncodingPolicy.html" title="Definition of the TfIdfEncodingPolicy class.">TfIdfEncodingPolicy</a> and the default dictionary for the given token type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TokenType</td><td>Type of the tokens. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tf__idf__encoding__policy_8hpp_source.html#l00344">344</a> of file <a class="el" href="tf__idf__encoding__policy_8hpp_source.html">tf_idf_encoding_policy.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aa7714fa0b7efc7b31cbda21da607c5b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7714fa0b7efc7b31cbda21da607c5b6">&#9670;&nbsp;</a></span>Datatype</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlpack_1_1data.html#aa7714fa0b7efc7b31cbda21da607c5b6">Datatype</a> : bool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Datatype enum specifies the types of data mlpack algorithms can use. </p>
<p>The vast majority of mlpack algorithms can only use numeric data (i.e. float/double/etc.), but some algorithms can use categorical data, specified via this Datatype enum and the <a class="el" href="classmlpack_1_1data_1_1DatasetMapper.html" title="Auxiliary information for a dataset, including mappings to/from strings (or other types) and the data...">DatasetMapper</a> class. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa7714fa0b7efc7b31cbda21da607c5b6a1b5484703e716389553255e6f11f12ec"></a>numeric&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa7714fa0b7efc7b31cbda21da607c5b6a2992a7ab833605792145cd40762644c7"></a>categorical&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="datatype_8hpp_source.html#l00024">24</a> of file <a class="el" href="datatype_8hpp_source.html">datatype.hpp</a>.</p>

</div>
</div>
<a id="a387137c43ed9616d39ba90e890d181eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a387137c43ed9616d39ba90e890d181eb">&#9670;&nbsp;</a></span>format</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlpack_1_1data.html#a387137c43ed9616d39ba90e890d181eb">format</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define the formats we can read through cereal. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a387137c43ed9616d39ba90e890d181eba7038b9ea9dd309cf5cc8f7122f6c0cee"></a>autodetect&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a387137c43ed9616d39ba90e890d181eba23ac0259f4d3527268c85207a3c2e1f0"></a>json&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a387137c43ed9616d39ba90e890d181ebac0a194d2e3cadd6447861e57368c2581"></a>xml&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a387137c43ed9616d39ba90e890d181eba4c41ae0ac8cc59e0caeaa4984dd5d469"></a>binary&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="format_8hpp_source.html#l00020">20</a> of file <a class="el" href="format_8hpp_source.html">format.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa47724fc0e8e354c6ca18818d81705a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa47724fc0e8e354c6ca18818d81705a3">&#9670;&nbsp;</a></span>AutoDetect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arma::file_type mlpack::data::AutoDetect </td>
          <td>(</td>
          <td class="paramtype">std::fstream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to auto-detect the type of a file given its extension, and by inspecting the parts of the file to disambiguate between types when necessary. </p>
<p>(For instance, a .csv file could be delimited by spaces, commas, or tabs.) This is meant to be used during loading.</p>
<p>If the file is detected as a CSV, and the CSV is detected to have a header row, <code>stream</code> will be fast-forwarded to point at the second line of the file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Opened file stream to look into for autodetection. </td></tr>
    <tr><td class="paramname">filename</td><td>Name of the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The detected file type. arma::file_type_unknown if unknown. </dd></dl>

</div>
</div>
<a id="a28da72e55467d0872681827b30b490ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28da72e55467d0872681827b30b490ac">&#9670;&nbsp;</a></span>Binarize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlpack::data::Binarize </td>
          <td>(</td>
          <td class="paramtype">const arma::Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an input dataset and threshold, set values greater than threshold to 1 and values less than or equal to the threshold to 0. </p>
<p>This overload applies the changes to all dimensions.</p>
<div class="fragment"><div class="line">arma::Mat&lt;double&gt; input = loadData();</div>
<div class="line">arma::Mat&lt;double&gt; output;</div>
<div class="line"><span class="keywordtype">double</span> threshold = 0.5;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Binarize the whole Matrix. All positive values in will be set to 1 and</span></div>
<div class="line"><span class="comment">// the values less than or equal to 0.5 will become 0.</span></div>
<div class="line">Binarize&lt;double&gt;(input, output, threshold);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Input matrix to Binarize. </td></tr>
    <tr><td class="paramname">output</td><td>Matrix you want to save binarized data into. </td></tr>
    <tr><td class="paramname">threshold</td><td>Threshold can by any number. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="binarize_8hpp_source.html#l00041">41</a> of file <a class="el" href="binarize_8hpp_source.html">binarize.hpp</a>.</p>

<p class="reference">References <a class="el" href="prereqs_8hpp_source.html#l00137">omp_size_t</a>.</p>

</div>
</div>
<a id="a39606420520e81f5e87d6ea1e64c27ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39606420520e81f5e87d6ea1e64c27ae">&#9670;&nbsp;</a></span>Binarize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlpack::data::Binarize </td>
          <td>(</td>
          <td class="paramtype">const arma::Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>dimension</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an input dataset and threshold, set values greater than threshold to 1 and values less than or equal to the threshold to 0. </p>
<p>This overload takes a dimension and applys the changes to the given dimension.</p>
<div class="fragment"><div class="line">arma::Mat&lt;double&gt; input = loadData();</div>
<div class="line">arma::Mat&lt;double&gt; output;</div>
<div class="line"><span class="keywordtype">double</span> threshold = 0.5;</div>
<div class="line"><span class="keywordtype">size_t</span> dimension = 0;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Binarize the first dimension. All positive values in the first dimension</span></div>
<div class="line"><span class="comment">// will be set to 1 and the values less than or equal to 0 will become 0.</span></div>
<div class="line">Binarize&lt;double&gt;(input, output, threshold, dimension);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Input matrix to Binarize. </td></tr>
    <tr><td class="paramname">output</td><td>Matrix you want to save binarized data into. </td></tr>
    <tr><td class="paramname">threshold</td><td>Threshold can by any number. </td></tr>
    <tr><td class="paramname">dimension</td><td>Feature to apply the Binarize function. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="binarize_8hpp_source.html#l00077">77</a> of file <a class="el" href="binarize_8hpp_source.html">binarize.hpp</a>.</p>

<p class="reference">References <a class="el" href="prereqs_8hpp_source.html#l00137">omp_size_t</a>.</p>

</div>
</div>
<a id="a3bb1b3de86790e53265efa63e5965d41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bb1b3de86790e53265efa63e5965d41">&#9670;&nbsp;</a></span>ConfusionMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlpack::data::ConfusionMatrix </td>
          <td>(</td>
          <td class="paramtype">const arma::Row&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>predictors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arma::Row&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>responses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; eT &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>numClasses</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A confusion matrix is a summary of prediction results on a classification problem. </p>
<p>The number of correct and incorrect predictions are summarized by count and broken down by each class. For example, for 2 classes, the function call will be</p>
<div class="fragment"><div class="line"><a class="code" href="namespacemlpack_1_1data.html#a3bb1b3de86790e53265efa63e5965d41">ConfusionMatrix</a>(predictors, responses, output, 2)</div>
<div class="ttc" id="anamespacemlpack_1_1data_html_a3bb1b3de86790e53265efa63e5965d41"><div class="ttname"><a href="namespacemlpack_1_1data.html#a3bb1b3de86790e53265efa63e5965d41">mlpack::data::ConfusionMatrix</a></div><div class="ttdeci">void ConfusionMatrix(const arma::Row&lt; size_t &gt; predictors, const arma::Row&lt; size_t &gt; responses, arma::Mat&lt; eT &gt; &amp;output, const size_t numClasses)</div><div class="ttdoc">A confusion matrix is a summary of prediction results on a classification problem.</div></div>
</div><!-- fragment --><p>In this case, the output matrix will be of size 2 * 2:</p>
<div class="fragment"><div class="line">     0     1</div>
<div class="line">0    TP    FN</div>
<div class="line">1    FP    TN</div>
</div><!-- fragment --><p>The confusion matrix for two labels will look like what is shown above. In this confusion matrix, TP represents the number of true positives, FP represents the number of false positives, FN represents the number of false negatives, and TN represents the number of true negatives.</p>
<p>When generalizing to 2 or more classes, the row index of the confusion matrix represents the predicted classes and column index represents the actual class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predictors</td><td>Vector of data points. </td></tr>
    <tr><td class="paramname">responses</td><td>The measured data for each point. </td></tr>
    <tr><td class="paramname">output</td><td>Matrix which is represented as confusion matrix. </td></tr>
    <tr><td class="paramname">numClasses</td><td>Number of classes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3115b81a148283970b530603b3f2aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3115b81a148283970b530603b3f2aaa">&#9670;&nbsp;</a></span>DetectFromExtension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arma::file_type mlpack::data::DetectFromExtension </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the type based only on the extension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name of the file whose type we should detect. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Detected type of file. arma::file_type_unknown if unknown. </dd></dl>

</div>
</div>
<a id="a5a13b28050a64b446916c067e1466951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a13b28050a64b446916c067e1466951">&#9670;&nbsp;</a></span>Extension()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string mlpack::data::Extension </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="extension_8hpp_source.html#l00021">21</a> of file <a class="el" href="extension_8hpp_source.html">extension.hpp</a>.</p>

</div>
</div>
<a id="a898633566d45ba664faacc815915e416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a898633566d45ba664faacc815915e416">&#9670;&nbsp;</a></span>GetStringType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mlpack::data::GetStringType </td>
          <td>(</td>
          <td class="paramtype">const arma::file_type &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a file type, return a logical name corresponding to that file type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Type to get the logical name of. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2f0956c373bd666d19e70551fecaf90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f0956c373bd666d19e70551fecaf90">&#9670;&nbsp;</a></span>GuessFileType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arma::file_type mlpack::data::GuessFileType </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an istream, attempt to guess the file type. </p>
<p>This is taken originally from Armadillo's function guess_file_type_internal(), but we avoid using internal Armadillo functionality.</p>
<p>If the file is detected as a CSV, and the CSV is detected to have a header row, the stream <code>f</code> will be fast-forwarded to point at the second line of the file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Opened istream to look into to guess the file type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb5cb8a6b868db7d521f8efbe03b6728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb5cb8a6b868db7d521f8efbe03b6728">&#9670;&nbsp;</a></span>HAS_EXACT_METHOD_FORM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlpack::data::HAS_EXACT_METHOD_FORM </td>
          <td>(</td>
          <td class="paramtype">serialize&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HasSerializeCheck&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6814f77346f5af80d2c25ef3206713cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6814f77346f5af80d2c25ef3206713cb">&#9670;&nbsp;</a></span>ImageFormatSupported()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlpack::data::ImageFormatSupported </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>save</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given image filename is supported. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>Name of the image file. </td></tr>
    <tr><td class="paramname">save</td><td>Set to true to check if the file format can be saved, else loaded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean value indicating success if it is an image. </dd></dl>

</div>
</div>
<a id="a3799ea79b454b97c5f79a82db6958a1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3799ea79b454b97c5f79a82db6958a1b">&#9670;&nbsp;</a></span>IsNaNInf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlpack::data::IsNaNInf </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See if the token is a NaN or an Inf, and if so, set the value accordingly and return a boolean representing whether or not it is. </p>

<p class="definition">Definition at line <a class="el" href="is__naninf_8hpp_source.html#l00027">27</a> of file <a class="el" href="is__naninf_8hpp_source.html">is_naninf.hpp</a>.</p>

</div>
</div>
<a id="adb0c6adf83024427e47a03bd7fbfb885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb0c6adf83024427e47a03bd7fbfb885">&#9670;&nbsp;</a></span>Load() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlpack::data::Load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Col&lt; eT &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>fatal</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Don't document these with doxygen; these declarations aren't helpful to users. </p>
<p>Load a column vector from a file, guessing the filetype from the extension.</p>
<p>The supported types of files are the same as found in Armadillo:</p>
<ul>
<li>CSV (csv_ascii), denoted by .csv, or optionally .txt</li>
<li>TSV (raw_ascii), denoted by .tsv, .csv, or .txt</li>
<li>ASCII (raw_ascii), denoted by .txt</li>
<li>Armadillo ASCII (arma_ascii), also denoted by .txt</li>
<li>PGM (pgm_binary), denoted by .pgm</li>
<li>PPM (ppm_binary), denoted by .ppm</li>
<li>Raw binary (raw_binary), denoted by .bin</li>
<li>Armadillo binary (arma_binary), denoted by .bin</li>
<li>HDF5, denoted by .hdf, .hdf5, .h5, or .he5</li>
</ul>
<p>If the file extension is not one of those types, an error will be given. This is preferable to Armadillo's default behavior of loading an unknown filetype as raw_binary, which can have very confusing effects.</p>
<p>If the parameter 'fatal' is set to true, a std::runtime_error exception will be thrown if the matrix does not load successfully.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name of file to load. </td></tr>
    <tr><td class="paramname">vec</td><td>Column vector to load contents of file into. </td></tr>
    <tr><td class="paramname">fatal</td><td>If an error should be reported as fatal (default false). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean value indicating success or failure of load. </dd></dl>

</div>
</div>
<a id="abbff2a667bf247e00b1fc09b7ca5f831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbff2a667bf247e00b1fc09b7ca5f831">&#9670;&nbsp;</a></span>Load() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlpack::data::Load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; eT &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>fatal</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transpose</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arma::file_type&#160;</td>
          <td class="paramname"><em>inputLoadType</em> = <code>arma::auto_detect</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a matrix from file, guessing the filetype from the extension. </p>
<p>This will transpose the matrix at load time (unless the transpose parameter is set to false).</p>
<p>The supported types of files are the same as found in Armadillo:</p>
<ul>
<li>CSV (arma::csv_ascii), denoted by .csv, or optionally .txt</li>
<li>TSV (arma::raw_ascii), denoted by .tsv, .csv, or .txt</li>
<li>ASCII (arma::raw_ascii), denoted by .txt</li>
<li>Armadillo ASCII (arma::arma_ascii), also denoted by .txt</li>
<li>PGM (arma::pgm_binary), denoted by .pgm</li>
<li>PPM (arma::ppm_binary), denoted by .ppm</li>
<li>Raw binary (arma::raw_binary), denoted by .bin</li>
<li>Armadillo binary (arma::arma_binary), denoted by .bin</li>
<li>HDF5 (arma::hdf5_binary), denoted by .hdf, .hdf5, .h5, or .he5</li>
</ul>
<p>By default, this function will try to automatically determine the type of file to load based on its extension and by inspecting the file. If you know the file type and want to specify it manually, override the default <code>inputLoadType</code> parameter with the correct type above (e.g. <code>arma::csv_ascii</code>.)</p>
<p>If the detected file type is CSV (<code>arma::csv_ascii</code>), the first row will be checked for a CSV header. If a CSV header is not detected, the first row will be treated as data; otherwise, the first row will be skipped.</p>
<p>If the parameter 'fatal' is set to true, a std::runtime_error exception will be thrown if the matrix does not load successfully. The parameter 'transpose' controls whether or not the matrix is transposed after loading. In most cases, because data is generally stored in a row-major format and mlpack requires column-major matrices, this should be left at its default value of 'true'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name of file to load. </td></tr>
    <tr><td class="paramname">matrix</td><td>Matrix to load contents of file into. </td></tr>
    <tr><td class="paramname">fatal</td><td>If an error should be reported as fatal (default false). </td></tr>
    <tr><td class="paramname">transpose</td><td>If true, transpose the matrix after loading (default true). </td></tr>
    <tr><td class="paramname">inputLoadType</td><td>Used to determine the type of file to load (default arma::auto_detect). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean value indicating success or failure of load. </dd></dl>

<p class="reference">Referenced by <a class="el" href="cli_2get__param_8hpp_source.html#l00046">mlpack::bindings::cli::GetParam()</a>.</p>

</div>
</div>
<a id="a9af06d46f91871c42f38e30aac5d4666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9af06d46f91871c42f38e30aac5d4666">&#9670;&nbsp;</a></span>Load() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlpack::data::Load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; eT &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1data_1_1DatasetMapper.html">DatasetMapper</a>&lt; PolicyType &gt; &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>fatal</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transpose</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a matrix from a file, guessing the filetype from the extension and mapping categorical features with a <a class="el" href="classmlpack_1_1data_1_1DatasetMapper.html" title="Auxiliary information for a dataset, including mappings to/from strings (or other types) and the data...">DatasetMapper</a> object. </p>
<p>This will transpose the matrix (unless the transpose parameter is set to false). This particular overload of <a class="el" href="namespacemlpack_1_1data.html#abbff2a667bf247e00b1fc09b7ca5f831" title="Loads a matrix from file, guessing the filetype from the extension.">Load()</a> can only load text-based formats, such as those given below:</p>
<ul>
<li>CSV (csv_ascii), denoted by .csv, or optionally .txt</li>
<li>TSV (raw_ascii), denoted by .tsv, .csv, or .txt</li>
<li>ASCII (raw_ascii), denoted by .txt</li>
</ul>
<p>If the file extension is not one of those types, an error will be given. This is preferable to Armadillo's default behavior of loading an unknown filetype as raw_binary, which can have very confusing effects.</p>
<p>If the parameter 'fatal' is set to true, a std::runtime_error exception will be thrown if the matrix does not load successfully. The parameter 'transpose' controls whether or not the matrix is transposed after loading. In most cases, because data is generally stored in a row-major format and mlpack requires column-major matrices, this should be left at its default value of 'true'.</p>
<p>The <a class="el" href="classmlpack_1_1data_1_1DatasetMapper.html" title="Auxiliary information for a dataset, including mappings to/from strings (or other types) and the data...">DatasetMapper</a> object passed to this function will be re-created, so any mappings from previous loads will be lost.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name of file to load. </td></tr>
    <tr><td class="paramname">matrix</td><td>Matrix to load contents of file into. </td></tr>
    <tr><td class="paramname">info</td><td><a class="el" href="classmlpack_1_1data_1_1DatasetMapper.html" title="Auxiliary information for a dataset, including mappings to/from strings (or other types) and the data...">DatasetMapper</a> object to populate with mappings and data types. </td></tr>
    <tr><td class="paramname">fatal</td><td>If an error should be reported as fatal (default false). </td></tr>
    <tr><td class="paramname">transpose</td><td>If true, transpose the matrix after loading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean value indicating success or failure of load. </dd></dl>

</div>
</div>
<a id="aa05aba27ed8693c1c4ed538240a549b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa05aba27ed8693c1c4ed538240a549b1">&#9670;&nbsp;</a></span>Load() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlpack::data::Load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; eT &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1data_1_1ImageInfo.html">ImageInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>fatal</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Image load/save interfaces. </p>
<p>Load the image file into the given matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name of the image file. </td></tr>
    <tr><td class="paramname">matrix</td><td>Matrix to load the image into. </td></tr>
    <tr><td class="paramname">info</td><td>An object of <a class="el" href="classmlpack_1_1data_1_1ImageInfo.html" title="Implements meta-data of images required by data::Load and data::Save for loading and saving images in...">ImageInfo</a> class. </td></tr>
    <tr><td class="paramname">fatal</td><td>If an error should be reported as fatal (default false). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean value indicating success or failure of load. </dd></dl>

</div>
</div>
<a id="ac5679a4dc8c6129e3895a1089855d25d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5679a4dc8c6129e3895a1089855d25d">&#9670;&nbsp;</a></span>Load() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlpack::data::Load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Row&lt; eT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rowvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>fatal</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a row vector from a file, guessing the filetype from the extension. </p>
<p>The supported types of files are the same as found in Armadillo:</p>
<ul>
<li>CSV (csv_ascii), denoted by .csv, or optionally .txt</li>
<li>TSV (raw_ascii), denoted by .tsv, .csv, or .txt</li>
<li>ASCII (raw_ascii), denoted by .txt</li>
<li>Armadillo ASCII (arma_ascii), also denoted by .txt</li>
<li>PGM (pgm_binary), denoted by .pgm</li>
<li>PPM (ppm_binary), denoted by .ppm</li>
<li>Raw binary (raw_binary), denoted by .bin</li>
<li>Armadillo binary (arma_binary), denoted by .bin</li>
<li>HDF5, denoted by .hdf, .hdf5, .h5, or .he5</li>
</ul>
<p>If the file extension is not one of those types, an error will be given. This is preferable to Armadillo's default behavior of loading an unknown filetype as raw_binary, which can have very confusing effects.</p>
<p>If the parameter 'fatal' is set to true, a std::runtime_error exception will be thrown if the matrix does not load successfully.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name of file to load. </td></tr>
    <tr><td class="paramname">rowvec</td><td>Row vector to load contents of file into. </td></tr>
    <tr><td class="paramname">fatal</td><td>If an error should be reported as fatal (default false). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean value indicating success or failure of load. </dd></dl>

</div>
</div>
<a id="a7bfd894be870a3409cc7d3b10b08d689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bfd894be870a3409cc7d3b10b08d689">&#9670;&nbsp;</a></span>Load() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlpack::data::Load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::SpMat&lt; eT &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>fatal</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transpose</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a sparse matrix from file, using arma::coord_ascii format. </p>
<p>This will transpose the matrix at load time (unless the transpose parameter is set to false). If the filetype cannot be determined, an error will be given.</p>
<p>The supported types of files are the same as found in Armadillo:</p>
<ul>
<li>TSV (coord_ascii), denoted by .tsv or .txt</li>
<li>TXT (coord_ascii), denoted by .txt</li>
<li>Raw binary (raw_binary), denoted by .bin</li>
<li>Armadillo binary (arma_binary), denoted by .bin</li>
</ul>
<p>If the file extension is not one of those types, an error will be given. This is preferable to Armadillo's default behavior of loading an unknown filetype as raw_binary, which can have very confusing effects.</p>
<p>If the parameter 'fatal' is set to true, a std::runtime_error exception will be thrown if the matrix does not load successfully. The parameter 'transpose' controls whether or not the matrix is transposed after loading. In most cases, because data is generally stored in a row-major format and mlpack requires column-major matrices, this should be left at its default value of 'true'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name of file to load. </td></tr>
    <tr><td class="paramname">matrix</td><td>Sparse matrix to load contents of file into. </td></tr>
    <tr><td class="paramname">fatal</td><td>If an error should be reported as fatal (default false). </td></tr>
    <tr><td class="paramname">transpose</td><td>If true, transpose the matrix after loading (default true). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean value indicating success or failure of load. </dd></dl>

</div>
</div>
<a id="ac0441d5f7e76f0fcdeec487d4a9732ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0441d5f7e76f0fcdeec487d4a9732ac">&#9670;&nbsp;</a></span>Load() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlpack::data::Load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>fatal</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlpack_1_1data.html#a387137c43ed9616d39ba90e890d181eb">format</a>&#160;</td>
          <td class="paramname"><em>f</em> = <code>format::autodetect</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Don't document these with doxygen; they aren't helpful for users to know about. </p>
<p>Load a model from a file, guessing the filetype from the extension, or, optionally, loading the specified format. If automatic extension detection is used and the filetype cannot be determined, an error will be given.</p>
<p>The supported types of files are the same as what is supported by the cereal library:</p>
<ul>
<li>json, denoted by .json</li>
<li>xml, denoted by .xml</li>
<li>binary, denoted by .bin</li>
</ul>
<p>The format parameter can take any of the values in the 'format' enum: 'format::autodetect', 'format::json', 'format::xml', and 'format::binary'. The autodetect functionality operates on the file extension (so, "file.txt" would be autodetected as text).</p>
<p>The name parameter should be specified to indicate the name of the structure to be loaded. This should be the same as the name that was used to save the structure (otherwise, the loading procedure will fail).</p>
<p>If the parameter 'fatal' is set to true, then an exception will be thrown in the event of load failure. Otherwise, the method will return false and the relevant error information will be printed to <a class="el" href="classmlpack_1_1Log.html#af8dd463e0db2840410fe6b1165429d5b" title="Prints warning messages prefixed with [WARN ].">Log::Warn</a>. </p>

</div>
</div>
<a id="adf6afb44303645116a32d1ed168e0ff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf6afb44303645116a32d1ed168e0ff1">&#9670;&nbsp;</a></span>Load() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlpack::data::Load </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>files</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; eT &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1data_1_1ImageInfo.html">ImageInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>fatal</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load the image file into the given matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">files</td><td>A vector consisting of filenames. </td></tr>
    <tr><td class="paramname">matrix</td><td>Matrix to save the image from. </td></tr>
    <tr><td class="paramname">info</td><td>An object of <a class="el" href="classmlpack_1_1data_1_1ImageInfo.html" title="Implements meta-data of images required by data::Load and data::Save for loading and saving images in...">ImageInfo</a> class. </td></tr>
    <tr><td class="paramname">fatal</td><td>If an error should be reported as fatal (default false). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean value indicating success or failure of load. </dd></dl>

</div>
</div>
<a id="a951a7dc1fd86524b8dd245bb91841731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a951a7dc1fd86524b8dd245bb91841731">&#9670;&nbsp;</a></span>LoadARFF() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlpack::data::LoadARFF </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; eT &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function to load an ARFF dataset as numeric features (that is, as an Armadillo matrix without any modification). </p>
<p>An exception will be thrown if any features are non-numeric. </p>

</div>
</div>
<a id="aa2a4a09a274c068e08373200fe611422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2a4a09a274c068e08373200fe611422">&#9670;&nbsp;</a></span>LoadARFF() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlpack::data::LoadARFF </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; eT &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1data_1_1DatasetMapper.html">DatasetMapper</a>&lt; PolicyType &gt; &amp;&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function to load an ARFF dataset as numeric and categorical features, using the DatasetInfo structure for mapping. </p>
<p>An exception will be thrown upon failure.</p>
<p>A pre-existing DatasetInfo object can be passed in, but if the dimensionality of the given DatasetInfo object (info.Dimensionality()) does not match the dimensionality of the data, a std::invalid_argument exception will be thrown. If an empty DatasetInfo object is given (constructed with the default constructor or otherwise, so that info.Dimensionality() is 0), it will be set to the right dimensionality.</p>
<p>This ability to pass in pre-existing DatasetInfo objects is very necessary when, e.g., loading a test set after training. If the same DatasetInfo from loading the training set is not used, then the test set may be loaded with different mappings&mdash;which can cause horrible problems!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name of ARFF file to load. </td></tr>
    <tr><td class="paramname">matrix</td><td>Matrix to load data into. </td></tr>
    <tr><td class="paramname">info</td><td>DatasetInfo object; can be default-constructed or pre-existing from another call to <a class="el" href="namespacemlpack_1_1data.html#a951a7dc1fd86524b8dd245bb91841731" title="A utility function to load an ARFF dataset as numeric features (that is, as an Armadillo matrix witho...">LoadARFF()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01155770d761c5cf686a666f3622caa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01155770d761c5cf686a666f3622caa5">&#9670;&nbsp;</a></span>LoadImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlpack::data::LoadImage </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1data_1_1ImageInfo.html">ImageInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>fatal</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a664b3fa5243889e2aed47ee750f840ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a664b3fa5243889e2aed47ee750f840ed">&#9670;&nbsp;</a></span>NormalizeLabels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlpack::data::NormalizeLabels </td>
          <td>(</td>
          <td class="paramtype">const RowType &amp;&#160;</td>
          <td class="paramname"><em>labelsIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Row&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Col&lt; eT &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a set of labels of a particular datatype, convert them to unsigned labels in the range [0, n) where n is the number of different labels. </p>
<p>Also, a reverse mapping from the new label to the old value is stored in the 'mapping' vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">labelsIn</td><td>Input labels of arbitrary datatype. </td></tr>
    <tr><td class="paramname">labels</td><td>Vector that unsigned labels will be stored in. </td></tr>
    <tr><td class="paramname">mapping</td><td>Reverse mapping to convert new labels back to old labels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a007765ae6ce1f59513e6644bd2c66988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a007765ae6ce1f59513e6644bd2c66988">&#9670;&nbsp;</a></span>OneHotEncoding() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlpack::data::OneHotEncoding </td>
          <td>(</td>
          <td class="paramtype">const arma::Mat&lt; eT &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; eT &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlpack_1_1data.html#aa243ad7e4d29363b858bbc92b732921d">data::DatasetInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>datasetInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloaded function for the above function, which takes a matrix as input and also a DatasetInfo object and outputs a matrix. </p>
<p>This function encodes all the dimensions marked <code>Datatype::categorical</code> in the <a class="el" href="namespacemlpack_1_1data.html#aa243ad7e4d29363b858bbc92b732921d">data::DatasetInfo</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Input dataset to be encoded. </td></tr>
    <tr><td class="paramname">output</td><td>Encoded matrix. </td></tr>
    <tr><td class="paramname">datasetInfo</td><td>DatasetInfo object that has information about data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91f3e880da9955942bd129414fe617a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91f3e880da9955942bd129414fe617a9">&#9670;&nbsp;</a></span>OneHotEncoding() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlpack::data::OneHotEncoding </td>
          <td>(</td>
          <td class="paramtype">const arma::Mat&lt; eT &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arma::Col&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; eT &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloaded function for the above function, which takes a matrix as input and also a vector of indices to encode and outputs a matrix. </p>
<p>Indices represent the IDs of the dimensions to be one-hot encoded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Input dataset to be encoded. </td></tr>
    <tr><td class="paramname">indices</td><td>Index of rows to be encoded. </td></tr>
    <tr><td class="paramname">output</td><td>Encoded matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d41d92266983ceb192346478a54ec23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d41d92266983ceb192346478a54ec23">&#9670;&nbsp;</a></span>OneHotEncoding() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlpack::data::OneHotEncoding </td>
          <td>(</td>
          <td class="paramtype">const RowType &amp;&#160;</td>
          <td class="paramname"><em>labelsIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatType &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a set of labels of a particular datatype, convert them to binary vector. </p>
<p>The categorical values be mapped to integer values. Then, each integer value is represented as a binary vector that is all zero values except the index of the integer, which is marked with a 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">labelsIn</td><td>Input labels of arbitrary datatype. </td></tr>
    <tr><td class="paramname">output</td><td>Binary matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a901fe08dcdc58734f64a864dbdef0a28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a901fe08dcdc58734f64a864dbdef0a28">&#9670;&nbsp;</a></span>RevertLabels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlpack::data::RevertLabels </td>
          <td>(</td>
          <td class="paramtype">const arma::Row&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arma::Col&lt; eT &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Row&lt; eT &gt; &amp;&#160;</td>
          <td class="paramname"><em>labelsOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a set of labels that have been mapped to the range [0, n), map them back to the original labels given by the 'mapping' vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">labels</td><td>Set of normalized labels to convert. </td></tr>
    <tr><td class="paramname">mapping</td><td>Mapping to use to convert labels. </td></tr>
    <tr><td class="paramname">labelsOut</td><td>Vector to store new labels in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a255acca42390d66faaed4521eb502de8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a255acca42390d66faaed4521eb502de8">&#9670;&nbsp;</a></span>Save() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlpack::data::Save </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; eT &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1data_1_1ImageInfo.html">ImageInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>fatal</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save the image file from the given matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name of the image file. </td></tr>
    <tr><td class="paramname">matrix</td><td>Matrix to save the image from. </td></tr>
    <tr><td class="paramname">info</td><td>An object of <a class="el" href="classmlpack_1_1data_1_1ImageInfo.html" title="Implements meta-data of images required by data::Load and data::Save for loading and saving images in...">ImageInfo</a> class. </td></tr>
    <tr><td class="paramname">fatal</td><td>If an error should be reported as fatal (default false). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean value indicating success or failure of load. </dd></dl>

</div>
</div>
<a id="accd1605a1d160c09ee75c93a587dc313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accd1605a1d160c09ee75c93a587dc313">&#9670;&nbsp;</a></span>Save() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlpack::data::Save </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arma::Mat&lt; eT &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>fatal</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transpose</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::file_type&#160;</td>
          <td class="paramname"><em>inputSaveType</em> = <code>arma::auto_detect</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves a matrix to file, guessing the filetype from the extension. </p>
<p>This will transpose the matrix at save time. If the filetype cannot be determined, an error will be given.</p>
<p>The supported types of files are the same as found in Armadillo:</p>
<ul>
<li>CSV (arma::csv_ascii), denoted by .csv, or optionally .txt</li>
<li>ASCII (arma::raw_ascii), denoted by .json</li>
<li>Armadillo ASCII (arma::arma_ascii), also denoted by .txt</li>
<li>PGM (arma::pgm_binary), denoted by .pgm</li>
<li>PPM (arma::ppm_binary), denoted by .ppm</li>
<li>Raw binary (arma::raw_binary), denoted by .bin</li>
<li>Armadillo binary (arma::arma_binary), denoted by .bin</li>
<li>HDF5 (arma::hdf5_binary), denoted by .hdf5, .hdf, .h5, or .he5</li>
</ul>
<p>By default, this function will try to automatically determine the format to save with based only on the filename's extension. If you would prefer to specify a file type manually, override the default <code>inputSaveType</code> parameter with the correct type above (e.g. <code>arma::csv_ascii</code>.)</p>
<p>If the 'fatal' parameter is set to true, a std::runtime_error exception will be thrown upon failure. If the 'transpose' parameter is set to true, the matrix will be transposed before saving. Generally, because mlpack stores matrices in a column-major format and most datasets are stored on disk as row-major, this parameter should be left at its default value of 'true'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name of file to save to. </td></tr>
    <tr><td class="paramname">matrix</td><td>Matrix to save into file. </td></tr>
    <tr><td class="paramname">fatal</td><td>If an error should be reported as fatal (default false). </td></tr>
    <tr><td class="paramname">transpose</td><td>If true, transpose the matrix before saving (default true). </td></tr>
    <tr><td class="paramname">inputSaveType</td><td>File type to save to (defaults to arma::auto_detect). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean value indicating success or failure of save. </dd></dl>

</div>
</div>
<a id="ad5510cd863171eb3bc1dec000a78b482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5510cd863171eb3bc1dec000a78b482">&#9670;&nbsp;</a></span>Save() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlpack::data::Save </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arma::SpMat&lt; eT &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>fatal</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transpose</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves a sparse matrix to file, guessing the filetype from the extension. </p>
<p>This will transpose the matrix at save time. If the filetype cannot be determined, an error will be given.</p>
<p>The supported types of files are the same as found in Armadillo:</p>
<ul>
<li>TSV (coord_ascii), denoted by .tsv or .txt</li>
<li>TXT (coord_ascii), denoted by .txt</li>
<li>Raw binary (raw_binary), denoted by .bin</li>
<li>Armadillo binary (arma_binary), denoted by .bin</li>
</ul>
<p>If the file extension is not one of those types, an error will be given. If the 'fatal' parameter is set to true, a std::runtime_error exception will be thrown upon failure. If the 'transpose' parameter is set to true, the matrix will be transposed before saving. Generally, because mlpack stores matrices in a column-major format and most datasets are stored on disk as row-major, this parameter should be left at its default value of 'true'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name of file to save to. </td></tr>
    <tr><td class="paramname">matrix</td><td>Sparse matrix to save into file. </td></tr>
    <tr><td class="paramname">fatal</td><td>If an error should be reported as fatal (default false). </td></tr>
    <tr><td class="paramname">transpose</td><td>If true, transpose the matrix before saving (default true). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean value indicating success or failure of save. </dd></dl>

</div>
</div>
<a id="af30f8bfca9b924d6d935c9f1fae91778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af30f8bfca9b924d6d935c9f1fae91778">&#9670;&nbsp;</a></span>Save() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlpack::data::Save </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>fatal</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlpack_1_1data.html#a387137c43ed9616d39ba90e890d181eb">format</a>&#160;</td>
          <td class="paramname"><em>f</em> = <code>format::autodetect</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves a model to file, guessing the filetype from the extension, or, optionally, saving the specified format. </p>
<p>If automatic extension detection is used and the filetype cannot be determined, and error will be given.</p>
<p>The supported types of files are the same as what is supported by the cereal library:</p>
<ul>
<li>json, denoted by .json</li>
<li>xml, denoted by .xml</li>
<li>binary, denoted by .bin</li>
</ul>
<p>The format parameter can take any of the values in the 'format' enum: 'format::autodetect', 'format::json', 'format::xml', and 'format::binary'. The autodetect functionality operates on the file extension (so, "file.txt" would be autodetected as text).</p>
<p>The name parameter should be specified to indicate the name of the structure to be saved. If <a class="el" href="namespacemlpack_1_1data.html#abbff2a667bf247e00b1fc09b7ca5f831" title="Loads a matrix from file, guessing the filetype from the extension.">Load()</a> is later called on the generated file, the name used to load should be the same as the name used for this call to <a class="el" href="namespacemlpack_1_1data.html#accd1605a1d160c09ee75c93a587dc313" title="Saves a matrix to file, guessing the filetype from the extension.">Save()</a>.</p>
<p>If the parameter 'fatal' is set to true, then an exception will be thrown in the event of a save failure. Otherwise, the method will return false and the relevant error information will be printed to <a class="el" href="classmlpack_1_1Log.html#af8dd463e0db2840410fe6b1165429d5b" title="Prints warning messages prefixed with [WARN ].">Log::Warn</a>. </p>

</div>
</div>
<a id="a9402b433306b2735be417a07d8397d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9402b433306b2735be417a07d8397d9c">&#9670;&nbsp;</a></span>Save() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlpack::data::Save </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>files</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; eT &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1data_1_1ImageInfo.html">ImageInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>fatal</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save the image file from the given matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">files</td><td>A vector consisting of filenames. </td></tr>
    <tr><td class="paramname">matrix</td><td>Matrix to save the image from. </td></tr>
    <tr><td class="paramname">info</td><td>An object of <a class="el" href="classmlpack_1_1data_1_1ImageInfo.html" title="Implements meta-data of images required by data::Load and data::Save for loading and saving images in...">ImageInfo</a> class. </td></tr>
    <tr><td class="paramname">fatal</td><td>If an error should be reported as fatal (default false). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean value indicating success or failure of load. </dd></dl>

</div>
</div>
<a id="a5053734839d456ce3bfe20b16a467d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5053734839d456ce3bfe20b16a467d0c">&#9670;&nbsp;</a></span>SaveImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlpack::data::SaveImage </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1data_1_1ImageInfo.html">ImageInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>fatal</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to save files. </p>
<p>Implementation in save_image.cpp. </p>

</div>
</div>
<a id="a0ac4c8b737e134361d49d5c1c3f9f6ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ac4c8b737e134361d49d5c1c3f9f6ba">&#9670;&nbsp;</a></span>Split() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlpack::data::Split </td>
          <td>(</td>
          <td class="paramtype">const arma::Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>trainData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>testData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>testRatio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>shuffleData</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an input dataset, split into a training set and test set. </p>
<p>Example usage below. This overload places the split dataset into the two output parameters given (trainData, testData).</p>
<div class="fragment"><div class="line">arma::mat input = loadData();</div>
<div class="line">arma::mat trainData;</div>
<div class="line">arma::mat testData;</div>
<div class="line"><a class="code" href="namespacemlpack_1_1math.html#a99560c3cf9c2db393309a31933b8d480">math::RandomSeed</a>(100); <span class="comment">// Set the seed if you like.</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Split the dataset into a training and test set, with 30% of the data being</span></div>
<div class="line"><span class="comment">// held out for the test set.</span></div>
<div class="line"><a class="code" href="namespacemlpack_1_1data.html#a32f749a2ac526fd90ab112400fad6ef2">Split</a>(input, trainData, testData, 0.3);</div>
<div class="ttc" id="anamespacemlpack_1_1data_html_a32f749a2ac526fd90ab112400fad6ef2"><div class="ttname"><a href="namespacemlpack_1_1data.html#a32f749a2ac526fd90ab112400fad6ef2">mlpack::data::Split</a></div><div class="ttdeci">void Split(const arma::Mat&lt; T &gt; &amp;input, const LabelsType &amp;inputLabel, arma::Mat&lt; T &gt; &amp;trainData, arma::Mat&lt; T &gt; &amp;testData, LabelsType &amp;trainLabel, LabelsType &amp;testLabel, const double testRatio, const bool shuffleData=true)</div><div class="ttdoc">Given an input dataset and labels, split into a training set and test set.</div><div class="ttdef"><b>Definition:</b> <a href="split__data_8hpp_source.html#l00255">split_data.hpp:255</a></div></div>
<div class="ttc" id="anamespacemlpack_1_1math_html_a99560c3cf9c2db393309a31933b8d480"><div class="ttname"><a href="namespacemlpack_1_1math.html#a99560c3cf9c2db393309a31933b8d480">mlpack::math::RandomSeed</a></div><div class="ttdeci">void RandomSeed(const size_t seed)</div><div class="ttdoc">Set the random seed used by the random functions (Random() and RandInt()).</div><div class="ttdef"><b>Definition:</b> <a href="random_8hpp_source.html#l00040">random.hpp:40</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Input dataset to split. </td></tr>
    <tr><td class="paramname">trainData</td><td>Matrix to store training data into. </td></tr>
    <tr><td class="paramname">testData</td><td>Matrix to store test data into. </td></tr>
    <tr><td class="paramname">testRatio</td><td>Percentage of dataset to use for test set (between 0 and 1). </td></tr>
    <tr><td class="paramname">shuffleData</td><td>If true, the sample order is shuffled; otherwise, each sample is visited in linear order. (Default true). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="split__data_8hpp_source.html#l00302">302</a> of file <a class="el" href="split__data_8hpp_source.html">split_data.hpp</a>.</p>

<p class="reference">References <a class="el" href="split__data_8hpp_source.html#l00027">SplitHelper()</a>.</p>

</div>
</div>
<a id="a91a5ecc1018b88a9cbe745e67d1e8672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a5ecc1018b88a9cbe745e67d1e8672">&#9670;&nbsp;</a></span>Split() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;arma::Mat&lt;T&gt;, arma::Mat&lt;T&gt; &gt; mlpack::data::Split </td>
          <td>(</td>
          <td class="paramtype">const arma::Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>testRatio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>shuffleData</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an input dataset, split into a training set and test set. </p>
<p>Example usage below. This overload returns the split dataset as a std::tuple with two elements: an arma::Mat&lt;T&gt; containing the training data and an arma::Mat&lt;T&gt; containing the test data.</p>
<div class="fragment"><div class="line">arma::mat input = loadData();</div>
<div class="line"><span class="keyword">auto</span> splitResult = <a class="code" href="namespacemlpack_1_1data.html#a32f749a2ac526fd90ab112400fad6ef2">Split</a>(input, 0.2);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Input dataset to split. </td></tr>
    <tr><td class="paramname">testRatio</td><td>Percentage of dataset to use for test set (between 0 and 1). </td></tr>
    <tr><td class="paramname">shuffleData</td><td>If true, the sample order is shuffled; otherwise, each sample is visited in linear order. (Default true). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple containing trainData (arma::Mat&lt;T&gt;) and testData (arma::Mat&lt;T&gt;). </dd></dl>

<p class="definition">Definition at line <a class="el" href="split__data_8hpp_source.html#l00399">399</a> of file <a class="el" href="split__data_8hpp_source.html">split_data.hpp</a>.</p>

<p class="reference">References <a class="el" href="split__data_8hpp_source.html#l00255">Split()</a>.</p>

</div>
</div>
<a id="a32f749a2ac526fd90ab112400fad6ef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32f749a2ac526fd90ab112400fad6ef2">&#9670;&nbsp;</a></span>Split() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlpack::data::Split </td>
          <td>(</td>
          <td class="paramtype">const arma::Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LabelsType &amp;&#160;</td>
          <td class="paramname"><em>inputLabel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>trainData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>testData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LabelsType &amp;&#160;</td>
          <td class="paramname"><em>trainLabel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LabelsType &amp;&#160;</td>
          <td class="paramname"><em>testLabel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>testRatio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>shuffleData</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an input dataset and labels, split into a training set and test set. </p>
<p>Example usage below. This overload places the split dataset into the four output parameters given (trainData, testData, trainLabel, and testLabel).</p>
<div class="fragment"><div class="line">arma::mat input = loadData();</div>
<div class="line">arma::Row&lt;size_t&gt; label = loadLabel();</div>
<div class="line">arma::mat trainData;</div>
<div class="line">arma::mat testData;</div>
<div class="line">arma::Row&lt;size_t&gt; trainLabel;</div>
<div class="line">arma::Row&lt;size_t&gt; testLabel;</div>
<div class="line"><a class="code" href="namespacemlpack_1_1math.html#a99560c3cf9c2db393309a31933b8d480">math::RandomSeed</a>(100); <span class="comment">// Set the seed if you like.</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Split the dataset into a training and test set, with 30% of the data being</span></div>
<div class="line"><span class="comment">// held out for the test set.</span></div>
<div class="line"><a class="code" href="namespacemlpack_1_1data.html#a32f749a2ac526fd90ab112400fad6ef2">Split</a>(input, label, trainData,</div>
<div class="line">               testData, trainLabel, testLabel, 0.3);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the elements of the input matrix. </td></tr>
    <tr><td class="paramname">LabelsType</td><td>Type of input labels. It can be arma::Mat, arma::Row, arma::Cube or arma::SpMat. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Input dataset to split. </td></tr>
    <tr><td class="paramname">inputLabel</td><td>Input labels to split. </td></tr>
    <tr><td class="paramname">trainData</td><td>Matrix to store training data into. </td></tr>
    <tr><td class="paramname">testData</td><td>Matrix to store test data into. </td></tr>
    <tr><td class="paramname">trainLabel</td><td>Vector to store training labels into. </td></tr>
    <tr><td class="paramname">testLabel</td><td>Vector to store test labels into. </td></tr>
    <tr><td class="paramname">testRatio</td><td>Percentage of dataset to use for test set (between 0 and 1). </td></tr>
    <tr><td class="paramname">shuffleData</td><td>If true, the sample order is shuffled; otherwise, each sample is visited in linear order. (Default true.) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="split__data_8hpp_source.html#l00255">255</a> of file <a class="el" href="split__data_8hpp_source.html">split_data.hpp</a>.</p>

<p class="reference">References <a class="el" href="split__data_8hpp_source.html#l00027">SplitHelper()</a>.</p>

<p class="reference">Referenced by <a class="el" href="split__data_8hpp_source.html#l00351">Split()</a>.</p>

</div>
</div>
<a id="a38ad55a3d28296d823078fe7d0ced9b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38ad55a3d28296d823078fe7d0ced9b2">&#9670;&nbsp;</a></span>Split() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;arma::Mat&lt;T&gt;, arma::Mat&lt;T&gt;, LabelsType, LabelsType&gt; mlpack::data::Split </td>
          <td>(</td>
          <td class="paramtype">const arma::Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LabelsType &amp;&#160;</td>
          <td class="paramname"><em>inputLabel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>testRatio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>shuffleData</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>stratifyData</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an input dataset and labels, split into a training set and test set. </p>
<p>Example usage below. This overload returns the split dataset as a std::tuple with four elements: an arma::Mat&lt;T&gt; containing the training data, an arma::Mat&lt;T&gt; containing the test data, an arma::Row&lt;U&gt; containing the training labels, and an arma::Row&lt;U&gt; containing the test labels.</p>
<div class="fragment"><div class="line">arma::mat input = loadData();</div>
<div class="line">arma::Row&lt;size_t&gt; label = loadLabel();</div>
<div class="line"><span class="keyword">auto</span> splitResult = <a class="code" href="namespacemlpack_1_1data.html#a32f749a2ac526fd90ab112400fad6ef2">Split</a>(input, label, 0.2);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the elements of the input matrix. </td></tr>
    <tr><td class="paramname">LabelsType</td><td>Type of input labels. It can be arma::Mat, arma::Row, arma::Cube or arma::SpMat. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Input dataset to split. </td></tr>
    <tr><td class="paramname">inputLabel</td><td>Input labels to split. </td></tr>
    <tr><td class="paramname">testRatio</td><td>Percentage of dataset to use for test set (between 0 and 1). </td></tr>
    <tr><td class="paramname">shuffleData</td><td>If true, the sample order is shuffled; otherwise, each sample is visited in linear order. (Default true). </td></tr>
    <tr><td class="paramname">stratifyData</td><td>If true, the train and test splits are stratified so that the ratio of each class in the training and test sets is the same as in the original dataset. Expects labels to be of type arma::Row&lt;&gt; or arma::Col&lt;&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple containing trainData (arma::Mat&lt;T&gt;), testData (arma::Mat&lt;T&gt;), trainLabel (arma::Row&lt;U&gt;), and testLabel (arma::Row&lt;U&gt;). </dd></dl>

<p class="definition">Definition at line <a class="el" href="split__data_8hpp_source.html#l00351">351</a> of file <a class="el" href="split__data_8hpp_source.html">split_data.hpp</a>.</p>

<p class="reference">References <a class="el" href="split__data_8hpp_source.html#l00255">Split()</a>, and <a class="el" href="split__data_8hpp_source.html#l00103">StratifiedSplit()</a>.</p>

</div>
</div>
<a id="a744850e5ad47df5e0af6f5845009a4d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a744850e5ad47df5e0af6f5845009a4d2">&#9670;&nbsp;</a></span>Split() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;FieldType, FieldType, arma::field&lt;T&gt;, arma::field&lt;T&gt; &gt; mlpack::data::Split </td>
          <td>(</td>
          <td class="paramtype">const FieldType &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arma::field&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputLabel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>testRatio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>shuffleData</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an input dataset and labels, split into a training set and test set. </p>
<p>Example usage below. This overload returns the split dataset as a std::tuple with four elements: an FieldType containing the training data, an FieldType containing the test data, an arma::field&lt;arma::vec&gt; containing the training labels, and an arma::field&lt;arma::vec&gt; containing the test labels.</p>
<p>The input dataset must be of type arma::field. It should have the shape - (n_rows = 1, n_cols = Number of samples, n_slices = 1)</p>
<p>NOTE: Here FieldType could be arma::field&lt;arma::mat&gt; or arma::field&lt;arma::vec&gt;</p>
<div class="fragment"><div class="line">arma::field&lt;arma::mat&gt; input = loadData();</div>
<div class="line">arma::field&lt;arma::vec&gt; label = loadLabel();</div>
<div class="line"><span class="keyword">auto</span> splitResult = <a class="code" href="namespacemlpack_1_1data.html#a32f749a2ac526fd90ab112400fad6ef2">Split</a>(input, label, 0.2);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Input dataset to split. </td></tr>
    <tr><td class="paramname">inputLabel</td><td>Input labels to split. </td></tr>
    <tr><td class="paramname">testRatio</td><td>Percentage of dataset to use for test set (between 0 and 1). </td></tr>
    <tr><td class="paramname">shuffleData</td><td>If true, the sample order is shuffled; otherwise, each sample is visited in linear order. (Default true). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple containing trainData (FieldType), testData (FieldType), trainLabel (arma::field&lt;arma::vec&gt;), and testLabel (arma::field&lt;arma::vec&gt;). </dd></dl>

<p class="definition">Definition at line <a class="el" href="split__data_8hpp_source.html#l00554">554</a> of file <a class="el" href="split__data_8hpp_source.html">split_data.hpp</a>.</p>

<p class="reference">References <a class="el" href="split__data_8hpp_source.html#l00255">Split()</a>.</p>

</div>
</div>
<a id="a7bca254ee313ff590e7d1bcada13d72a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bca254ee313ff590e7d1bcada13d72a">&#9670;&nbsp;</a></span>Split() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlpack::data::Split </td>
          <td>(</td>
          <td class="paramtype">const FieldType &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arma::field&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputLabel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FieldType &amp;&#160;</td>
          <td class="paramname"><em>trainData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::field&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>trainLabel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FieldType &amp;&#160;</td>
          <td class="paramname"><em>testData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::field&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>testLabel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>testRatio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>shuffleData</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an input dataset and labels, split into a training set and test set. </p>
<p>Example usage below. This overload places the split dataset into the four output parameters given (trainData, testData, trainLabel, and testLabel).</p>
<p>The input dataset must be of type arma::field. It should have the shape - (n_rows = 1, n_cols = Number of samples, n_slices = 1).</p>
<p>NOTE: Here FieldType could be arma::field&lt;arma::mat&gt; or arma::field&lt;arma::vec&gt;.</p>
<div class="fragment"><div class="line">arma::field&lt;arma::mat&gt; input = loadData();</div>
<div class="line">arma::field&lt;arma::vec&gt; label = loadLabel();</div>
<div class="line">arma::field&lt;arma::mat&gt; trainData;</div>
<div class="line">arma::field&lt;arma::mat&gt; testData;</div>
<div class="line">arma::field&lt;arma::vec&gt; trainLabel;</div>
<div class="line">arma::field&lt;arma::vec&gt; testLabel;</div>
<div class="line"><a class="code" href="namespacemlpack_1_1math.html#a99560c3cf9c2db393309a31933b8d480">math::RandomSeed</a>(100); <span class="comment">// Set the seed if you like.</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Split the dataset into a training and test set, with 30% of the data being</span></div>
<div class="line"><span class="comment">// held out for the test set.</span></div>
<div class="line"><a class="code" href="namespacemlpack_1_1data.html#a32f749a2ac526fd90ab112400fad6ef2">Split</a>(input, label, trainData, testData, trainLabel, testLabel, 0.3);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Input dataset to split. </td></tr>
    <tr><td class="paramname">inputLabel</td><td>Input labels to split. </td></tr>
    <tr><td class="paramname">trainData</td><td>FieldType to store training data into. </td></tr>
    <tr><td class="paramname">testData</td><td>FieldType test data into. </td></tr>
    <tr><td class="paramname">trainLabel</td><td>Field vector to store training labels into. </td></tr>
    <tr><td class="paramname">testLabel</td><td>Field vector to store test labels into. </td></tr>
    <tr><td class="paramname">testRatio</td><td>Percentage of dataset to use for test set (between 0 and 1). </td></tr>
    <tr><td class="paramname">shuffleData</td><td>If true, the sample order is shuffled; otherwise, each sample is visited in linear order. (Default true.) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="split__data_8hpp_source.html#l00449">449</a> of file <a class="el" href="split__data_8hpp_source.html">split_data.hpp</a>.</p>

<p class="reference">References <a class="el" href="split__data_8hpp_source.html#l00027">SplitHelper()</a>.</p>

</div>
</div>
<a id="af9b163f42a48fdc8993c2165f9089494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b163f42a48fdc8993c2165f9089494">&#9670;&nbsp;</a></span>Split() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;FieldType, FieldType&gt; mlpack::data::Split </td>
          <td>(</td>
          <td class="paramtype">const FieldType &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>testRatio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>shuffleData</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an input dataset, split into a training set and test set. </p>
<p>Example usage below. This overload returns the split dataset as a std::tuple with two elements: an FieldType containing the training data and an FieldType containing the test data.</p>
<p>The input dataset must be of type arma::field. It should have the shape - (n_rows = 1, n_cols = Number of samples, n_slices = 1)</p>
<p>NOTE: Here FieldType could be arma::field&lt;arma::mat&gt; or arma::field&lt;arma::vec&gt;</p>
<div class="fragment"><div class="line">arma::field&lt;arma::mat&gt; input = loadData();</div>
<div class="line"><span class="keyword">auto</span> splitResult = <a class="code" href="namespacemlpack_1_1data.html#a32f749a2ac526fd90ab112400fad6ef2">Split</a>(input, 0.2);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Input dataset to split. </td></tr>
    <tr><td class="paramname">testRatio</td><td>Percentage of dataset to use for test set (between 0 and 1). </td></tr>
    <tr><td class="paramname">shuffleData</td><td>If true, the sample order is shuffled; otherwise, each sample is visited in linear order. (Default true). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple containing trainData (FieldType) and testData (FieldType). </dd></dl>

<p class="definition">Definition at line <a class="el" href="split__data_8hpp_source.html#l00601">601</a> of file <a class="el" href="split__data_8hpp_source.html">split_data.hpp</a>.</p>

<p class="reference">References <a class="el" href="split__data_8hpp_source.html#l00255">Split()</a>.</p>

</div>
</div>
<a id="a0baaf8bcdf473761f7c59c9e1577d1f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0baaf8bcdf473761f7c59c9e1577d1f1">&#9670;&nbsp;</a></span>Split() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlpack::data::Split </td>
          <td>(</td>
          <td class="paramtype">const FieldType &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FieldType &amp;&#160;</td>
          <td class="paramname"><em>trainData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FieldType &amp;&#160;</td>
          <td class="paramname"><em>testData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>testRatio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>shuffleData</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an input dataset, split into a training set and test set. </p>
<p>Example usage below. This overload places the split dataset into the two output parameters given (trainData, testData).</p>
<p>The input dataset must be of type arma::field. It should have the shape - (n_rows = 1, n_cols = Number of samples, n_slices = 1)</p>
<p>NOTE: Here FieldType could be arma::field&lt;arma::mat&gt; or arma::field&lt;arma::vec&gt;</p>
<div class="fragment"><div class="line">arma::field&lt;arma::mat&gt; input = loadData();</div>
<div class="line">arma::field&lt;arma::mat&gt; trainData;</div>
<div class="line">arma::field&lt;arma::mat&gt; testData;</div>
<div class="line"><a class="code" href="namespacemlpack_1_1math.html#a99560c3cf9c2db393309a31933b8d480">math::RandomSeed</a>(100); <span class="comment">// Set the seed if you like.</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Split the dataset into a training and test set, with 30% of the data being</span></div>
<div class="line"><span class="comment">// held out for the test set.</span></div>
<div class="line"><a class="code" href="namespacemlpack_1_1data.html#a32f749a2ac526fd90ab112400fad6ef2">Split</a>(input, trainData, testData, 0.3);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Input dataset to split. </td></tr>
    <tr><td class="paramname">trainData</td><td>FieldType to store training data into. </td></tr>
    <tr><td class="paramname">testData</td><td>FieldType test data into. </td></tr>
    <tr><td class="paramname">testRatio</td><td>Percentage of dataset to use for test set (between 0 and 1). </td></tr>
    <tr><td class="paramname">shuffleData</td><td>If true, the sample order is shuffled; otherwise, each sample is visited in linear order. (Default true). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="split__data_8hpp_source.html#l00504">504</a> of file <a class="el" href="split__data_8hpp_source.html">split_data.hpp</a>.</p>

<p class="reference">References <a class="el" href="split__data_8hpp_source.html#l00027">SplitHelper()</a>.</p>

</div>
</div>
<a id="aa8ba4ec838f0ac7dd92c69b6c60dfb22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8ba4ec838f0ac7dd92c69b6c60dfb22">&#9670;&nbsp;</a></span>SplitHelper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlpack::data::SplitHelper </td>
          <td>(</td>
          <td class="paramtype">const InputType &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputType &amp;&#160;</td>
          <td class="paramname"><em>train</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputType &amp;&#160;</td>
          <td class="paramname"><em>test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>testRatio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arma::uvec &amp;&#160;</td>
          <td class="paramname"><em>order</em> = <code>arma::uvec()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This helper function splits any <code>input</code> data into training and testing parts. </p>
<p>In order to shuffle the input data before spliting, an array of shuffled indices of the input data is passed in the form of argument <code>order</code>. </p>

<p class="definition">Definition at line <a class="el" href="split__data_8hpp_source.html#l00027">27</a> of file <a class="el" href="split__data_8hpp_source.html">split_data.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="split__data_8hpp_source.html#l00255">Split()</a>.</p>

</div>
</div>
<a id="ae5943effbe5980ae3af45b5e62240fc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5943effbe5980ae3af45b5e62240fc8">&#9670;&nbsp;</a></span>StratifiedSplit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlpack::data::StratifiedSplit </td>
          <td>(</td>
          <td class="paramtype">const arma::Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LabelsType &amp;&#160;</td>
          <td class="paramname"><em>inputLabel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>trainData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>testData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LabelsType &amp;&#160;</td>
          <td class="paramname"><em>trainLabel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LabelsType &amp;&#160;</td>
          <td class="paramname"><em>testLabel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>testRatio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>shuffleData</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an input dataset and labels, stratify into a training set and test set. </p>
<p>It is recommended to have the input labels between the range [0, n) where n is the number of different labels. The <a class="el" href="namespacemlpack_1_1data.html#a664b3fa5243889e2aed47ee750f840ed" title="Given a set of labels of a particular datatype, convert them to unsigned labels in the range [0,...">NormalizeLabels()</a> function in <a class="el" href="namespacemlpack_1_1data.html" title="Functions to load and save matrices and models.">mlpack::data</a> can be used for this. Expects labels to be of type arma::Row&lt;&gt; or arma::Col&lt;&gt;. Throws a runtime error if this is not the case. Example usage below. This overload places the stratified dataset into the four output parameters given (trainData, testData, trainLabel, and testLabel).</p>
<div class="fragment"><div class="line">arma::mat input = loadData();</div>
<div class="line">arma::Row&lt;size_t&gt; label = loadLabel();</div>
<div class="line">arma::mat trainData;</div>
<div class="line">arma::mat testData;</div>
<div class="line">arma::Row&lt;size_t&gt; trainLabel;</div>
<div class="line">arma::Row&lt;size_t&gt; testLabel;</div>
<div class="line"><a class="code" href="namespacemlpack_1_1math.html#a99560c3cf9c2db393309a31933b8d480">math::RandomSeed</a>(100); <span class="comment">// Set the seed if you like.</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Stratify the dataset into a training and test set, with 30% of the data</span></div>
<div class="line"><span class="comment">// being held out for the test set.</span></div>
<div class="line"><a class="code" href="namespacemlpack_1_1data.html#ae5943effbe5980ae3af45b5e62240fc8">StratifiedSplit</a>(input, label, trainData,</div>
<div class="line">                testData, trainLabel, testLabel, 0.3);</div>
<div class="ttc" id="anamespacemlpack_1_1data_html_ae5943effbe5980ae3af45b5e62240fc8"><div class="ttname"><a href="namespacemlpack_1_1data.html#ae5943effbe5980ae3af45b5e62240fc8">mlpack::data::StratifiedSplit</a></div><div class="ttdeci">void StratifiedSplit(const arma::Mat&lt; T &gt; &amp;input, const LabelsType &amp;inputLabel, arma::Mat&lt; T &gt; &amp;trainData, arma::Mat&lt; T &gt; &amp;testData, LabelsType &amp;trainLabel, LabelsType &amp;testLabel, const double testRatio, const bool shuffleData=true)</div><div class="ttdoc">Given an input dataset and labels, stratify into a training set and test set.</div><div class="ttdef"><b>Definition:</b> <a href="split__data_8hpp_source.html#l00103">split_data.hpp:103</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Input dataset to stratify. </td></tr>
    <tr><td class="paramname">inputLabel</td><td>Input labels to stratify. </td></tr>
    <tr><td class="paramname">trainData</td><td>Matrix to store training data into. </td></tr>
    <tr><td class="paramname">testData</td><td>Matrix to store test data into. </td></tr>
    <tr><td class="paramname">trainLabel</td><td>Vector to store training labels into. </td></tr>
    <tr><td class="paramname">testLabel</td><td>Vector to store test labels into. </td></tr>
    <tr><td class="paramname">testRatio</td><td>Percentage of dataset to use for test set (between 0 and 1). </td></tr>
    <tr><td class="paramname">shuffleData</td><td>If true, the sample order is shuffled; otherwise, each sample is visited in linear order. (Default true.) </td></tr>
  </table>
  </dd>
</dl>
<p>Basic idea: Let us say we have to stratify a dataset based on labels: 0 0 0 0 0 (5 0s) 1 1 1 1 1 1 1 1 1 1 1 (11 1s)</p>
<p>Let our test ratio be 0.2. Then, the number of 0 labels in our test set = floor(5 * 0.2) = 1. The number of 1 labels in our test set = floor(11 * 0.2) = 2.</p>
<p>In our first pass over the dataset, We visit each label and keep count of each label in our 'labelCounts' uvec.</p>
<p>We then take a second pass over the dataset. We now maintain an additional uvec 'testLabelCounts' to hold the label counts of our test set.</p>
<p>In this pass, when we encounter a label we check the 'testLabelCounts' uvec for the count of this label in the test set. If this count is less than the required number of labels in the test set, we add the data to the test set and increment the label count in the uvec. If this count is equal to or more than the required count in the test set, we add this data to the train set.</p>
<p>Based on the above steps, we get the following labels in the split set: Train set (4 0s, 9 1s) 0 0 0 0 1 1 1 1 1 1 1 1 1</p>
<p>Test set (1 0s, 2 1s) 0 1 1</p>

<p class="definition">Definition at line <a class="el" href="split__data_8hpp_source.html#l00103">103</a> of file <a class="el" href="split__data_8hpp_source.html">split_data.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="split__data_8hpp_source.html#l00351">Split()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.9.1
</small></address>
</body>
<script type="text/javascript">
var x = document.querySelectorAll("img.formulaDsp");
var i;
for (i = 0; i < x.length; i++)
{
  x[i].width = x[i].offsetWidth / 4;
}
</script>
</html>
