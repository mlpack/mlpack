<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="namespacemlpack_1_1tree" kind="namespace" language="C++">
    <compoundname>mlpack::tree</compoundname>
    <innerclass refid="classmlpack_1_1tree_1_1AllCategoricalSplit" prot="public">mlpack::tree::AllCategoricalSplit</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1AllDimensionSelect" prot="public">mlpack::tree::AllDimensionSelect</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1AxisParallelProjVector" prot="public">mlpack::tree::AxisParallelProjVector</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1BestBinaryNumericSplit" prot="public">mlpack::tree::BestBinaryNumericSplit</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1BinaryNumericSplit" prot="public">mlpack::tree::BinaryNumericSplit</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1BinaryNumericSplitInfo" prot="public">mlpack::tree::BinaryNumericSplitInfo</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1BinarySpaceTree" prot="public">mlpack::tree::BinarySpaceTree</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1CategoricalSplitInfo" prot="public">mlpack::tree::CategoricalSplitInfo</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1CompareCosineNode" prot="public">mlpack::tree::CompareCosineNode</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1CosineTree" prot="public">mlpack::tree::CosineTree</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1CoverTree" prot="public">mlpack::tree::CoverTree</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1DecisionTree" prot="public">mlpack::tree::DecisionTree</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1DiscreteHilbertValue" prot="public">mlpack::tree::DiscreteHilbertValue</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1EmptyStatistic" prot="public">mlpack::tree::EmptyStatistic</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1ExampleTree" prot="public">mlpack::tree::ExampleTree</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1FirstPointIsRoot" prot="public">mlpack::tree::FirstPointIsRoot</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1GiniGain" prot="public">mlpack::tree::GiniGain</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1GiniImpurity" prot="public">mlpack::tree::GiniImpurity</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1GreedySingleTreeTraverser" prot="public">mlpack::tree::GreedySingleTreeTraverser</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1HilbertRTreeAuxiliaryInformation" prot="public">mlpack::tree::HilbertRTreeAuxiliaryInformation</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1HilbertRTreeDescentHeuristic" prot="public">mlpack::tree::HilbertRTreeDescentHeuristic</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1HilbertRTreeSplit" prot="public">mlpack::tree::HilbertRTreeSplit</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1HoeffdingCategoricalSplit" prot="public">mlpack::tree::HoeffdingCategoricalSplit</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1HoeffdingInformationGain" prot="public">mlpack::tree::HoeffdingInformationGain</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1HoeffdingNumericSplit" prot="public">mlpack::tree::HoeffdingNumericSplit</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1HoeffdingTree" prot="public">mlpack::tree::HoeffdingTree</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1HoeffdingTreeModel" prot="public">mlpack::tree::HoeffdingTreeModel</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1HyperplaneBase" prot="public">mlpack::tree::HyperplaneBase</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1InformationGain" prot="public">mlpack::tree::InformationGain</innerclass>
    <innerclass refid="structmlpack_1_1tree_1_1IsSpillTree" prot="public">mlpack::tree::IsSpillTree</innerclass>
    <innerclass refid="structmlpack_1_1tree_1_1IsSpillTree_3_01tree_1_1SpillTree_3_01MetricType_00_01StatisticType_00_0d41f2b10e451850b8eb14d3156c51340" prot="public">mlpack::tree::IsSpillTree&lt; tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt; &gt;</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1MeanSpaceSplit" prot="public">mlpack::tree::MeanSpaceSplit</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1MeanSplit" prot="public">mlpack::tree::MeanSplit</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1MidpointSpaceSplit" prot="public">mlpack::tree::MidpointSpaceSplit</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1MidpointSplit" prot="public">mlpack::tree::MidpointSplit</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1MinimalCoverageSweep" prot="public">mlpack::tree::MinimalCoverageSweep</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1MinimalSplitsNumberSweep" prot="public">mlpack::tree::MinimalSplitsNumberSweep</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1MultipleRandomDimensionSelect" prot="public">mlpack::tree::MultipleRandomDimensionSelect</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1NoAuxiliaryInformation" prot="public">mlpack::tree::NoAuxiliaryInformation</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1NumericSplitInfo" prot="public">mlpack::tree::NumericSplitInfo</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1Octree" prot="public">mlpack::tree::Octree</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1ProjVector" prot="public">mlpack::tree::ProjVector</innerclass>
    <innerclass refid="structmlpack_1_1tree_1_1QueueFrame" prot="public">mlpack::tree::QueueFrame</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1RandomBinaryNumericSplit" prot="public">mlpack::tree::RandomBinaryNumericSplit</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1RandomDimensionSelect" prot="public">mlpack::tree::RandomDimensionSelect</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1RandomForest" prot="public">mlpack::tree::RandomForest</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1RectangleTree" prot="public">mlpack::tree::RectangleTree</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1RPlusPlusTreeAuxiliaryInformation" prot="public">mlpack::tree::RPlusPlusTreeAuxiliaryInformation</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1RPlusPlusTreeDescentHeuristic" prot="public">mlpack::tree::RPlusPlusTreeDescentHeuristic</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1RPlusPlusTreeSplitPolicy" prot="public">mlpack::tree::RPlusPlusTreeSplitPolicy</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1RPlusTreeDescentHeuristic" prot="public">mlpack::tree::RPlusTreeDescentHeuristic</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1RPlusTreeSplit" prot="public">mlpack::tree::RPlusTreeSplit</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1RPlusTreeSplitPolicy" prot="public">mlpack::tree::RPlusTreeSplitPolicy</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1RPTreeMaxSplit" prot="public">mlpack::tree::RPTreeMaxSplit</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1RPTreeMeanSplit" prot="public">mlpack::tree::RPTreeMeanSplit</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1RStarTreeDescentHeuristic" prot="public">mlpack::tree::RStarTreeDescentHeuristic</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1RStarTreeSplit" prot="public">mlpack::tree::RStarTreeSplit</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1RTreeDescentHeuristic" prot="public">mlpack::tree::RTreeDescentHeuristic</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1RTreeSplit" prot="public">mlpack::tree::RTreeSplit</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1SpaceSplit" prot="public">mlpack::tree::SpaceSplit</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1SpillTree" prot="public">mlpack::tree::SpillTree</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1TraversalInfo" prot="public">mlpack::tree::TraversalInfo</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1TreeTraits" prot="public">mlpack::tree::TreeTraits</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1TreeTraits_3_01BinarySpaceTree_3_01MetricType_00_01StatisticType_00_01Mat267d3b8606ae92840ddcba6834055254" prot="public">mlpack::tree::TreeTraits&lt; BinarySpaceTree&lt; MetricType, StatisticType, MatType, bound::BallBound, SplitType &gt; &gt;</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1TreeTraits_3_01BinarySpaceTree_3_01MetricType_00_01StatisticType_00_01Mat224e09bac64c8e2ee29120d72866c234" prot="public">mlpack::tree::TreeTraits&lt; BinarySpaceTree&lt; MetricType, StatisticType, MatType, bound::CellBound, SplitType &gt; &gt;</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1TreeTraits_3_01BinarySpaceTree_3_01MetricType_00_01StatisticType_00_01Mat5e47ac61d347b64f5768de253cdf2773" prot="public">mlpack::tree::TreeTraits&lt; BinarySpaceTree&lt; MetricType, StatisticType, MatType, bound::HollowBallBound, SplitType &gt; &gt;</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1TreeTraits_3_01BinarySpaceTree_3_01MetricType_00_01StatisticType_00_01Mat455d0165b2c85743977ec4c0a5dd95ca" prot="public">mlpack::tree::TreeTraits&lt; BinarySpaceTree&lt; MetricType, StatisticType, MatType, BoundType, RPTreeMaxSplit &gt; &gt;</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1TreeTraits_3_01BinarySpaceTree_3_01MetricType_00_01StatisticType_00_01Mat83fa92e671856c0b52f8456f1beaf6c5" prot="public">mlpack::tree::TreeTraits&lt; BinarySpaceTree&lt; MetricType, StatisticType, MatType, BoundType, RPTreeMeanSplit &gt; &gt;</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1TreeTraits_3_01BinarySpaceTree_3_01MetricType_00_01StatisticType_00_01Matc82955fcc5e17376c7ac825c22d34930" prot="public">mlpack::tree::TreeTraits&lt; BinarySpaceTree&lt; MetricType, StatisticType, MatType, BoundType, SplitType &gt; &gt;</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1TreeTraits_3_01CoverTree_3_01MetricType_00_01StatisticType_00_01MatType_00_01RootPointPolicy_01_4_01_4" prot="public">mlpack::tree::TreeTraits&lt; CoverTree&lt; MetricType, StatisticType, MatType, RootPointPolicy &gt; &gt;</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1TreeTraits_3_01Octree_3_01MetricType_00_01StatisticType_00_01MatType_01_4_01_4" prot="public">mlpack::tree::TreeTraits&lt; Octree&lt; MetricType, StatisticType, MatType &gt; &gt;</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1TreeTraits_3_01RectangleTree_3_01MetricType_00_01StatisticType_00_01MatTyd3300c6b7e2f56d4c1027298545eb7bf" prot="public">mlpack::tree::TreeTraits&lt; RectangleTree&lt; MetricType, StatisticType, MatType, RPlusTreeSplit&lt; SplitPolicyType, SweepType &gt;, DescentType, AuxiliaryInformationType &gt; &gt;</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1TreeTraits_3_01RectangleTree_3_01MetricType_00_01StatisticType_00_01MatTy0686cbbcde9440cadacd80904499ea50" prot="public">mlpack::tree::TreeTraits&lt; RectangleTree&lt; MetricType, StatisticType, MatType, SplitType, DescentType, AuxiliaryInformationType &gt; &gt;</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1TreeTraits_3_01SpillTree_3_01MetricType_00_01StatisticType_00_01MatType_03c639ada9e7ec3c7879b4d5a2cf50982" prot="public">mlpack::tree::TreeTraits&lt; SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt; &gt;</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1UBTreeSplit" prot="public">mlpack::tree::UBTreeSplit</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1VantagePointSplit" prot="public">mlpack::tree::VantagePointSplit</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1XTreeAuxiliaryInformation" prot="public">mlpack::tree::XTreeAuxiliaryInformation</innerclass>
    <innerclass refid="classmlpack_1_1tree_1_1XTreeSplit" prot="public">mlpack::tree::XTreeSplit</innerclass>
    <innernamespace refid="namespacemlpack_1_1tree_1_1enumerate">mlpack::tree::enumerate</innernamespace>
    <innernamespace refid="namespacemlpack_1_1tree_1_1split">mlpack::tree::split</innernamespace>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="namespacemlpack_1_1tree_1afa85d70df69e258859143d448fbe0553" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename MetricType</type>
          </param>
        </templateparamlist>
        <type><ref refid="classmlpack_1_1tree_1_1HyperplaneBase" kindref="compound">HyperplaneBase</ref>&lt; <ref refid="classmlpack_1_1bound_1_1HRectBound" kindref="compound">bound::HRectBound</ref>&lt; MetricType &gt;, <ref refid="classmlpack_1_1tree_1_1AxisParallelProjVector" kindref="compound">AxisParallelProjVector</ref> &gt;</type>
        <definition>using AxisOrthogonalHyperplane =  HyperplaneBase&lt;bound::HRectBound&lt;MetricType&gt;, AxisParallelProjVector&gt;</definition>
        <argsstring></argsstring>
        <name>AxisOrthogonalHyperplane</name>
        <briefdescription>
<para>AxisOrthogonalHyperplane represents a hyperplane orthogonal to an axis. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/tree/space_split/hyperplane.hpp" line="144" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/tree/space_split/hyperplane.hpp" bodystart="145" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacemlpack_1_1tree_1a9d4905444011bbd045122cc985638b32" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename MetricType</type>
          </param>
          <param>
            <type>typename StatisticType</type>
          </param>
          <param>
            <type>typename MatType</type>
          </param>
        </templateparamlist>
        <type><ref refid="classmlpack_1_1tree_1_1BinarySpaceTree" kindref="compound">BinarySpaceTree</ref>&lt; MetricType, StatisticType, MatType, <ref refid="classmlpack_1_1bound_1_1BallBound" kindref="compound">bound::BallBound</ref>, <ref refid="classmlpack_1_1tree_1_1MidpointSplit" kindref="compound">MidpointSplit</ref> &gt;</type>
        <definition>using BallTree =  BinarySpaceTree&lt;MetricType, StatisticType, MatType, bound::BallBound, MidpointSplit&gt;</definition>
        <argsstring></argsstring>
        <name>BallTree</name>
        <briefdescription>
<para>A midpoint-split ball tree. </para>
        </briefdescription>
        <detaileddescription>
<para>This tree holds its points only in the leaves, similar to the KDTree and MeanSplitKDTree. However, the bounding shape of each node is a ball, not a hyper-rectangle. This can make the ball tree advantageous in some higher-dimensional situations and for some datasets. The tree construction algorithm here is the same as Omohundro&apos;s &apos;K-d construction algorithm&apos;, except the splitting value is the midpoint, not the median. This can result in trees that better reflect the data, although they may be unbalanced.</para>
<para><programlisting><codeline><highlight class="normal">@techreport{omohundro1989five,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>author={S.M.<sp/>Omohundro},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>title={Five<sp/>balltree<sp/>construction<sp/>algorithms},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>year={1989},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>institution={University<sp/>of<sp/>California,<sp/>Berkeley<sp/>International<sp/>Computer</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Science<sp/>Institute<sp/>Technical<sp/>Reports},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>number={TR-89-063}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>This template typedef satisfies the TreeType policy API.</para>
<para><simplesect kind="see"><para><ref refid="trees" kindref="compound">The TreeType policy in mlpack</ref>, <ref refid="classmlpack_1_1tree_1_1BinarySpaceTree" kindref="compound">BinarySpaceTree</ref>, <ref refid="namespacemlpack_1_1tree_1a73c2146f8d1da65d927c7746bfe7e750" kindref="member">KDTree</ref>, <ref refid="namespacemlpack_1_1tree_1a530d041f3f210c6097891301478e10bd" kindref="member">MeanSplitBallTree</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/tree/binary_space_tree/typedef.hpp" line="108" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/tree/binary_space_tree/typedef.hpp" bodystart="112" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacemlpack_1_1tree_1aa1c709206789f8ef16cf826bf965498e" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename FitnessFunction</type>
          </param>
        </templateparamlist>
        <type><ref refid="classmlpack_1_1tree_1_1BinaryNumericSplit" kindref="compound">BinaryNumericSplit</ref>&lt; FitnessFunction, double &gt;</type>
        <definition>using BinaryDoubleNumericSplit =  BinaryNumericSplit&lt;FitnessFunction, double&gt;</definition>
        <argsstring></argsstring>
        <name>BinaryDoubleNumericSplit</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/methods/hoeffding_trees/binary_numeric_split.hpp" line="128" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/methods/hoeffding_trees/binary_numeric_split.hpp" bodystart="128" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacemlpack_1_1tree_1a7c339b4bb20ff6160b203e3c7d78ae31" prot="public" static="no">
        <type>boost::heap::priority_queue&lt; <ref refid="classmlpack_1_1tree_1_1CosineTree" kindref="compound">CosineTree</ref> *, boost::heap::compare&lt; <ref refid="classmlpack_1_1tree_1_1CompareCosineNode" kindref="compound">CompareCosineNode</ref> &gt; &gt;</type>
        <definition>typedef boost::heap::priority_queue&lt;CosineTree*, boost::heap::compare&lt;CompareCosineNode&gt; &gt; CosineNodeQueue</definition>
        <argsstring></argsstring>
        <name>CosineNodeQueue</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/tree/cosine_tree/cosine_tree.hpp" line="27" column="2" bodyfile="/home/aakash/mlpack/src/mlpack/core/tree/cosine_tree/cosine_tree.hpp" bodystart="23" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacemlpack_1_1tree_1acc5f6fdc02048452ed6860b6e869ecbf" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename FitnessFunction</type>
            <defval>GiniGain</defval>
          </param>
          <param>
            <type>template&lt; typename &gt; class</type>
            <declname>NumericSplitType</declname>
            <defname>NumericSplitType</defname>
            <defval>BestBinaryNumericSplit</defval>
          </param>
          <param>
            <type>template&lt; typename &gt; class</type>
            <declname>CategoricalSplitType</declname>
            <defname>CategoricalSplitType</defname>
            <defval>AllCategoricalSplit</defval>
          </param>
          <param>
            <type>typename DimensionSelectType</type>
            <defval>AllDimensionSelect</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classmlpack_1_1tree_1_1DecisionTree" kindref="compound">DecisionTree</ref>&lt; FitnessFunction, NumericSplitType, CategoricalSplitType, DimensionSelectType, false &gt;</type>
        <definition>using DecisionStump =  DecisionTree&lt;FitnessFunction, NumericSplitType, CategoricalSplitType, DimensionSelectType, false&gt;</definition>
        <argsstring></argsstring>
        <name>DecisionStump</name>
        <briefdescription>
<para>Convenience typedef for decision stumps (single level decision trees). </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/methods/decision_tree/decision_tree.hpp" line="585" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/methods/decision_tree/decision_tree.hpp" bodystart="589" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacemlpack_1_1tree_1a6168a0dfd946fa930c61e8d5b480b688" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename TreeType</type>
          </param>
        </templateparamlist>
        <type><ref refid="classmlpack_1_1tree_1_1HilbertRTreeAuxiliaryInformation" kindref="compound">HilbertRTreeAuxiliaryInformation</ref>&lt; TreeType, <ref refid="classmlpack_1_1tree_1_1DiscreteHilbertValue" kindref="compound">DiscreteHilbertValue</ref> &gt;</type>
        <definition>using DiscreteHilbertRTreeAuxiliaryInformation =  HilbertRTreeAuxiliaryInformation&lt;TreeType, DiscreteHilbertValue&gt;</definition>
        <argsstring></argsstring>
        <name>DiscreteHilbertRTreeAuxiliaryInformation</name>
        <briefdescription>
<para>The Hilbert R-tree, a variant of the R tree with an ordering along the Hilbert curve. </para>
        </briefdescription>
        <detaileddescription>
<para>This template typedef satisfies the TreeType policy API.</para>
<para><programlisting><codeline><highlight class="normal">@inproceedings{kamel1994r,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>author<sp/>=<sp/>{Kamel,<sp/>Ibrahim<sp/>and<sp/>Faloutsos,<sp/>Christos},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>title<sp/>=<sp/>{Hilbert<sp/>R-tree:<sp/>An<sp/>Improved<sp/>R-tree<sp/>Using<sp/>Fractals},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>booktitle<sp/>=<sp/>{Proceedings<sp/>of<sp/>the<sp/>20th<sp/>International<sp/>Conference<sp/>on<sp/>Very<sp/>Large<sp/>Data<sp/>Bases},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>series<sp/>=<sp/>{VLDB<sp/>&apos;94},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>year<sp/>=<sp/>{1994},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>isbn<sp/>=<sp/>{1-55860-153-8},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pages<sp/>=<sp/>{500--509},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>numpages<sp/>=<sp/>{10},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>url<sp/>=<sp/>{http://dl.acm.org/citation.cfm?id=645920.673001},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>acmid<sp/>=<sp/>{673001},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>publisher<sp/>=<sp/>{Morgan<sp/>Kaufmann<sp/>Publishers<sp/>Inc.},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>address<sp/>=<sp/>{San<sp/>Francisco,<sp/>CA,<sp/>USA}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para><simplesect kind="see"><para><ref refid="trees" kindref="compound">The TreeType policy in mlpack</ref>, <ref refid="namespacemlpack_1_1tree_1ae4af35641769744ba680cc934e1c1f0e" kindref="member">RTree</ref>, DiscreteHilbertRTree </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/tree/rectangle_tree/typedef.hpp" line="127" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/tree/rectangle_tree/typedef.hpp" bodystart="128" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacemlpack_1_1tree_1a2400d611f91ddb39aa23bc26b0ec377c" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename FitnessFunction</type>
            <defval>GiniGain</defval>
          </param>
          <param>
            <type>typename DimensionSelectionType</type>
            <defval>MultipleRandomDimensionSelect</defval>
          </param>
          <param>
            <type>template&lt; typename &gt; class</type>
            <declname>CategoricalSplitType</declname>
            <defname>CategoricalSplitType</defname>
            <defval>AllCategoricalSplit</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classmlpack_1_1tree_1_1RandomForest" kindref="compound">RandomForest</ref>&lt; FitnessFunction, DimensionSelectionType, <ref refid="classmlpack_1_1tree_1_1RandomBinaryNumericSplit" kindref="compound">RandomBinaryNumericSplit</ref>, CategoricalSplitType, false &gt;</type>
        <definition>using ExtraTrees =  RandomForest&lt;FitnessFunction, DimensionSelectionType, RandomBinaryNumericSplit, CategoricalSplitType, false&gt;</definition>
        <argsstring></argsstring>
        <name>ExtraTrees</name>
        <briefdescription>
<para>Convenience typedef for Extra Trees. </para>
        </briefdescription>
        <detaileddescription>
<para>(Extremely Randomized Trees Forest)</para>
<para><programlisting><codeline><highlight class="normal">@article{10.1007/s10994-006-6226-1,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>author<sp/>=<sp/>{Geurts,<sp/>Pierre<sp/>and<sp/>Ernst,<sp/>Damien<sp/>and<sp/>Wehenkel,<sp/>Louis},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>title<sp/>=<sp/>{Extremely<sp/>Randomized<sp/>Trees},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>year<sp/>=<sp/>{2006},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>issue_date<sp/>=<sp/>{April<sp/>2006},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>publisher<sp/>=<sp/>{Kluwer<sp/>Academic<sp/>Publishers},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>address<sp/>=<sp/>{USA},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>volume<sp/>=<sp/>{63},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>number<sp/>=<sp/>{1},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>issn<sp/>=<sp/>{0885-6125},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>url<sp/>=<sp/>{https://doi.org/10.1007/s10994-006-6226-1},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>doi<sp/>=<sp/>{10.1007/s10994-006-6226-1},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>journal<sp/>=<sp/>{Mach.<sp/>Learn.},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>month<sp/>=<sp/>apr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pages<sp/>=<sp/>{3â€“42},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>numpages<sp/>=<sp/>{40},</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/methods/random_forest/random_forest.hpp" line="439" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/methods/random_forest/random_forest.hpp" bodystart="443" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacemlpack_1_1tree_1a898fa68fa580511c0cf3c9b41ac2935f" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename MetricType</type>
          </param>
          <param>
            <type>typename StatisticType</type>
          </param>
          <param>
            <type>typename MatType</type>
          </param>
        </templateparamlist>
        <type><ref refid="classmlpack_1_1tree_1_1RectangleTree" kindref="compound">RectangleTree</ref>&lt; MetricType, StatisticType, MatType, <ref refid="classmlpack_1_1tree_1_1HilbertRTreeSplit" kindref="compound">HilbertRTreeSplit</ref>&lt; 2 &gt;, <ref refid="classmlpack_1_1tree_1_1HilbertRTreeDescentHeuristic" kindref="compound">HilbertRTreeDescentHeuristic</ref>, <ref refid="namespacemlpack_1_1tree_1a6168a0dfd946fa930c61e8d5b480b688" kindref="member">DiscreteHilbertRTreeAuxiliaryInformation</ref> &gt;</type>
        <definition>using HilbertRTree =  RectangleTree&lt;MetricType, StatisticType, MatType, HilbertRTreeSplit&lt;2&gt;, HilbertRTreeDescentHeuristic, DiscreteHilbertRTreeAuxiliaryInformation&gt;</definition>
        <argsstring></argsstring>
        <name>HilbertRTree</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/tree/rectangle_tree/typedef.hpp" line="131" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/tree/rectangle_tree/typedef.hpp" bodystart="136" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacemlpack_1_1tree_1adab87fde9829454616f519ea70291b62" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename FitnessFunction</type>
          </param>
        </templateparamlist>
        <type><ref refid="classmlpack_1_1tree_1_1HoeffdingNumericSplit" kindref="compound">HoeffdingNumericSplit</ref>&lt; FitnessFunction, double &gt;</type>
        <definition>using HoeffdingDoubleNumericSplit =  HoeffdingNumericSplit&lt;FitnessFunction, double&gt;</definition>
        <argsstring></argsstring>
        <name>HoeffdingDoubleNumericSplit</name>
        <briefdescription>
<para>Convenience typedef. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/methods/hoeffding_trees/hoeffding_numeric_split.hpp" line="147" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/methods/hoeffding_trees/hoeffding_numeric_split.hpp" bodystart="148" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacemlpack_1_1tree_1a3f440993550b42b081689803da5972b5" prot="public" static="no">
        <type>StreamingDecisionTree&lt; <ref refid="classmlpack_1_1tree_1_1HoeffdingTree" kindref="compound">HoeffdingTree</ref>&lt;&gt; &gt;</type>
        <definition>typedef StreamingDecisionTree&lt;HoeffdingTree&lt;&gt; &gt; HoeffdingTreeType</definition>
        <argsstring></argsstring>
        <name>HoeffdingTreeType</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/methods/hoeffding_trees/typedef.hpp" line="21" column="31" bodyfile="/home/aakash/mlpack/src/mlpack/methods/hoeffding_trees/typedef.hpp" bodystart="21" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacemlpack_1_1tree_1ac4b7e2e4fa5c9c21bba75a48365b5c19" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename MetricType</type>
          </param>
        </templateparamlist>
        <type><ref refid="classmlpack_1_1tree_1_1HyperplaneBase" kindref="compound">HyperplaneBase</ref>&lt; <ref refid="classmlpack_1_1bound_1_1BallBound" kindref="compound">bound::BallBound</ref>&lt; MetricType &gt;, <ref refid="classmlpack_1_1tree_1_1ProjVector" kindref="compound">ProjVector</ref> &gt;</type>
        <definition>using Hyperplane =  HyperplaneBase&lt;bound::BallBound&lt;MetricType&gt;, ProjVector&gt;</definition>
        <argsstring></argsstring>
        <name>Hyperplane</name>
        <briefdescription>
<para>Hyperplane represents a general hyperplane (not necessarily axis-orthogonal). </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/tree/space_split/hyperplane.hpp" line="151" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/tree/space_split/hyperplane.hpp" bodystart="151" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacemlpack_1_1tree_1a27b9268c266fdfe2f4563d07052a0ecf" prot="public" static="no">
        <type><ref refid="classmlpack_1_1tree_1_1DecisionTree" kindref="compound">DecisionTree</ref>&lt; <ref refid="classmlpack_1_1tree_1_1InformationGain" kindref="compound">InformationGain</ref>, <ref refid="classmlpack_1_1tree_1_1BestBinaryNumericSplit" kindref="compound">BestBinaryNumericSplit</ref>, <ref refid="classmlpack_1_1tree_1_1AllCategoricalSplit" kindref="compound">AllCategoricalSplit</ref>, <ref refid="classmlpack_1_1tree_1_1AllDimensionSelect" kindref="compound">AllDimensionSelect</ref>, true &gt;</type>
        <definition>typedef DecisionTree&lt;InformationGain, BestBinaryNumericSplit, AllCategoricalSplit, AllDimensionSelect, true&gt; ID3DecisionStump</definition>
        <argsstring></argsstring>
        <name>ID3DecisionStump</name>
        <briefdescription>
<para>Convenience typedef for ID3 decision stumps (single level decision trees made with the ID3 algorithm). </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/methods/decision_tree/decision_tree.hpp" line="599" column="2" bodyfile="/home/aakash/mlpack/src/mlpack/methods/decision_tree/decision_tree.hpp" bodystart="599" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacemlpack_1_1tree_1a73c2146f8d1da65d927c7746bfe7e750" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename MetricType</type>
          </param>
          <param>
            <type>typename StatisticType</type>
          </param>
          <param>
            <type>typename MatType</type>
          </param>
        </templateparamlist>
        <type><ref refid="classmlpack_1_1tree_1_1BinarySpaceTree" kindref="compound">BinarySpaceTree</ref>&lt; MetricType, StatisticType, MatType, <ref refid="classmlpack_1_1bound_1_1HRectBound" kindref="compound">bound::HRectBound</ref>, <ref refid="classmlpack_1_1tree_1_1MidpointSplit" kindref="compound">MidpointSplit</ref> &gt;</type>
        <definition>using KDTree =  BinarySpaceTree&lt;MetricType, StatisticType, MatType, bound::HRectBound, MidpointSplit&gt;</definition>
        <argsstring></argsstring>
        <name>KDTree</name>
        <briefdescription>
<para>The standard midpoint-split kd-tree. </para>
        </briefdescription>
        <detaileddescription>
<para>This is not the original formulation by Bentley but instead the later formulation by Deng and Moore, which only holds points in the leaves of the tree. When recursively splitting nodes, the KDTree class select the dimension with maximum variance to split on, and picks the midpoint of the range in that dimension as the value on which to split nodes.</para>
<para>For more information, see the following papers.</para>
<para><programlisting><codeline><highlight class="normal">@article{bentley1975multidimensional,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>title={Multidimensional<sp/>binary<sp/>search<sp/>trees<sp/>used<sp/>for<sp/>associative<sp/>searching},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>author={Bentley,<sp/>J.L.},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>journal={Communications<sp/>of<sp/>the<sp/>ACM},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>volume={18},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>number={9},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pages={509--517},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>year={1975},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>publisher={ACM}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">@inproceedings{deng1995multiresolution,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>title={Multiresolution<sp/>instance-based<sp/>learning},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>author={Deng,<sp/>K.<sp/>and<sp/>Moore,<sp/>A.W.},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>booktitle={Proceedings<sp/>of<sp/>the<sp/>1995<sp/>International<sp/>Joint<sp/>Conference<sp/>on<sp/>AI</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>(IJCAI-95)},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pages={1233--1239},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>year={1995}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>This template typedef satisfies the TreeType policy API.</para>
<para><simplesect kind="see"><para><ref refid="trees" kindref="compound">The TreeType policy in mlpack</ref>, <ref refid="classmlpack_1_1tree_1_1BinarySpaceTree" kindref="compound">BinarySpaceTree</ref>, <ref refid="namespacemlpack_1_1tree_1a1028e6acf1fc61997237d3677cae0947" kindref="member">MeanSplitKDTree</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/tree/binary_space_tree/typedef.hpp" line="59" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/tree/binary_space_tree/typedef.hpp" bodystart="63" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacemlpack_1_1tree_1a1b6c0a1bc747a7d103f74058863de80b" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename MetricType</type>
          </param>
          <param>
            <type>typename StatisticType</type>
          </param>
          <param>
            <type>typename MatType</type>
          </param>
        </templateparamlist>
        <type><ref refid="classmlpack_1_1tree_1_1BinarySpaceTree" kindref="compound">BinarySpaceTree</ref>&lt; MetricType, StatisticType, MatType, <ref refid="classmlpack_1_1bound_1_1HRectBound" kindref="compound">bound::HRectBound</ref>, <ref refid="classmlpack_1_1tree_1_1RPTreeMaxSplit" kindref="compound">RPTreeMaxSplit</ref> &gt;</type>
        <definition>using MaxRPTree =  BinarySpaceTree&lt;MetricType, StatisticType, MatType, bound::HRectBound, RPTreeMaxSplit&gt;</definition>
        <argsstring></argsstring>
        <name>MaxRPTree</name>
        <briefdescription>
<para>A max-split random projection tree. </para>
        </briefdescription>
        <detaileddescription>
<para>When recursively splitting nodes, the MaxSplitRPTree class selects a random hyperplane and splits a node by the hyperplane. The tree holds points in leaf nodes. In contrast to the k-d tree, children of a MaxSplitRPTree node may overlap.</para>
<para><programlisting><codeline><highlight class="normal">@inproceedings{dasgupta2008,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>author<sp/>=<sp/>{Dasgupta,<sp/>Sanjoy<sp/>and<sp/>Freund,<sp/>Yoav},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>title<sp/>=<sp/>{Random<sp/>Projection<sp/>Trees<sp/>and<sp/>Low<sp/>Dimensional<sp/>Manifolds},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>booktitle<sp/>=<sp/>{Proceedings<sp/>of<sp/>the<sp/>Fortieth<sp/>Annual<sp/>ACM<sp/>Symposium<sp/>on<sp/>Theory<sp/>of</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Computing},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>series<sp/>=<sp/>{STOC<sp/>&apos;08},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>year<sp/>=<sp/>{2008},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pages<sp/>=<sp/>{537--546},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>numpages<sp/>=<sp/>{10},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>publisher<sp/>=<sp/>{ACM},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>address<sp/>=<sp/>{New<sp/>York,<sp/>NY,<sp/>USA},</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>This template typedef satisfies the TreeType policy API.</para>
<para><simplesect kind="see"><para><ref refid="trees" kindref="compound">The TreeType policy in mlpack</ref>, <ref refid="classmlpack_1_1tree_1_1BinarySpaceTree" kindref="compound">BinarySpaceTree</ref>, <ref refid="namespacemlpack_1_1tree_1a9d4905444011bbd045122cc985638b32" kindref="member">BallTree</ref>, <ref refid="namespacemlpack_1_1tree_1a1028e6acf1fc61997237d3677cae0947" kindref="member">MeanSplitKDTree</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/tree/binary_space_tree/typedef.hpp" line="228" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/tree/binary_space_tree/typedef.hpp" bodystart="232" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacemlpack_1_1tree_1a530d041f3f210c6097891301478e10bd" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename MetricType</type>
          </param>
          <param>
            <type>typename StatisticType</type>
          </param>
          <param>
            <type>typename MatType</type>
          </param>
        </templateparamlist>
        <type><ref refid="classmlpack_1_1tree_1_1BinarySpaceTree" kindref="compound">BinarySpaceTree</ref>&lt; MetricType, StatisticType, MatType, <ref refid="classmlpack_1_1bound_1_1BallBound" kindref="compound">bound::BallBound</ref>, <ref refid="classmlpack_1_1tree_1_1MeanSplit" kindref="compound">MeanSplit</ref> &gt;</type>
        <definition>using MeanSplitBallTree =  BinarySpaceTree&lt;MetricType, StatisticType, MatType, bound::BallBound, MeanSplit&gt;</definition>
        <argsstring></argsstring>
        <name>MeanSplitBallTree</name>
        <briefdescription>
<para>A mean-split ball tree. </para>
        </briefdescription>
        <detaileddescription>
<para>This tree, like the BallTree, holds its points only in the leaves. The tree construction algorithm here is the same as Omohundro&apos;s &apos;K-dc onstruction algorithm&apos;, except the splitting value is the mean, not the median. This can result in trees that better reflect the data, although they may be unbalanced.</para>
<para><programlisting><codeline><highlight class="normal">@techreport{omohundro1989five,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>author={S.M.<sp/>Omohundro},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>title={Five<sp/>balltree<sp/>construction<sp/>algorithms},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>year={1989},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>institution={University<sp/>of<sp/>California,<sp/>Berkeley<sp/>International<sp/>Computer</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Science<sp/>Institute<sp/>Technical<sp/>Reports},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>number={TR-89-063}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>This template typedef satisfies the TreeType policy API.</para>
<para><simplesect kind="see"><para><ref refid="trees" kindref="compound">The TreeType policy in mlpack</ref>, <ref refid="classmlpack_1_1tree_1_1BinarySpaceTree" kindref="compound">BinarySpaceTree</ref>, <ref refid="namespacemlpack_1_1tree_1a9d4905444011bbd045122cc985638b32" kindref="member">BallTree</ref>, <ref refid="namespacemlpack_1_1tree_1a1028e6acf1fc61997237d3677cae0947" kindref="member">MeanSplitKDTree</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/tree/binary_space_tree/typedef.hpp" line="137" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/tree/binary_space_tree/typedef.hpp" bodystart="141" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacemlpack_1_1tree_1a1028e6acf1fc61997237d3677cae0947" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename MetricType</type>
          </param>
          <param>
            <type>typename StatisticType</type>
          </param>
          <param>
            <type>typename MatType</type>
          </param>
        </templateparamlist>
        <type><ref refid="classmlpack_1_1tree_1_1BinarySpaceTree" kindref="compound">BinarySpaceTree</ref>&lt; MetricType, StatisticType, MatType, <ref refid="classmlpack_1_1bound_1_1HRectBound" kindref="compound">bound::HRectBound</ref>, <ref refid="classmlpack_1_1tree_1_1MeanSplit" kindref="compound">MeanSplit</ref> &gt;</type>
        <definition>using MeanSplitKDTree =  BinarySpaceTree&lt;MetricType, StatisticType, MatType, bound::HRectBound, MeanSplit&gt;</definition>
        <argsstring></argsstring>
        <name>MeanSplitKDTree</name>
        <briefdescription>
<para>A mean-split kd-tree. </para>
        </briefdescription>
        <detaileddescription>
<para>This is the same as the KDTree, but this particular implementation will use the mean of the data in the split dimension as the value on which to split, instead of the midpoint. This can sometimes give better performance, but it is not always clear which type of tree is best.</para>
<para>This template typedef satisfies the TreeType policy API.</para>
<para><simplesect kind="see"><para><ref refid="trees" kindref="compound">The TreeType policy in mlpack</ref>, <ref refid="classmlpack_1_1tree_1_1BinarySpaceTree" kindref="compound">BinarySpaceTree</ref>, <ref refid="namespacemlpack_1_1tree_1a73c2146f8d1da65d927c7746bfe7e750" kindref="member">KDTree</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/tree/binary_space_tree/typedef.hpp" line="76" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/tree/binary_space_tree/typedef.hpp" bodystart="80" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacemlpack_1_1tree_1a70daa44ca5882971662fb7a5410213e3" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename MetricType</type>
          </param>
          <param>
            <type>typename StatisticType</type>
          </param>
          <param>
            <type>typename MatType</type>
          </param>
        </templateparamlist>
        <type><ref refid="classmlpack_1_1tree_1_1SpillTree" kindref="compound">SpillTree</ref>&lt; MetricType, StatisticType, MatType, <ref refid="namespacemlpack_1_1tree_1afa85d70df69e258859143d448fbe0553" kindref="member">AxisOrthogonalHyperplane</ref>, <ref refid="classmlpack_1_1tree_1_1MeanSpaceSplit" kindref="compound">MeanSpaceSplit</ref> &gt;</type>
        <definition>using MeanSPTree =  SpillTree&lt;MetricType, StatisticType, MatType, AxisOrthogonalHyperplane, MeanSpaceSplit&gt;</definition>
        <argsstring></argsstring>
        <name>MeanSPTree</name>
        <briefdescription>
<para>A mean-split hybrid spill tree. </para>
        </briefdescription>
        <detaileddescription>
<para>This is the same as the SPTree, but this particular implementation will use the mean of the data in the split dimension as the value on which to split, instead of the midpoint. This can sometimes give better performance, but it is not always clear which type of tree is best.</para>
<para>This template typedef satisfies the TreeType policy API.</para>
<para><simplesect kind="see"><para><ref refid="trees" kindref="compound">The TreeType policy in mlpack</ref>, <ref refid="classmlpack_1_1tree_1_1SpillTree" kindref="compound">SpillTree</ref>, <ref refid="namespacemlpack_1_1tree_1af141bd85a0c63728935fff9f5f8dd587" kindref="member">SPTree</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/tree/spill_tree/typedef.hpp" line="76" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/tree/spill_tree/typedef.hpp" bodystart="80" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacemlpack_1_1tree_1a4f23fef4a51d815ae6667fb9f6920979" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename MetricType</type>
          </param>
          <param>
            <type>typename StatisticType</type>
          </param>
          <param>
            <type>typename MatType</type>
          </param>
        </templateparamlist>
        <type><ref refid="classmlpack_1_1tree_1_1SpillTree" kindref="compound">SpillTree</ref>&lt; MetricType, StatisticType, MatType, <ref refid="namespacemlpack_1_1tree_1ac4b7e2e4fa5c9c21bba75a48365b5c19" kindref="member">Hyperplane</ref>, <ref refid="classmlpack_1_1tree_1_1MeanSpaceSplit" kindref="compound">MeanSpaceSplit</ref> &gt;</type>
        <definition>using NonOrtMeanSPTree =  SpillTree&lt;MetricType, StatisticType, MatType, Hyperplane, MeanSpaceSplit&gt;</definition>
        <argsstring></argsstring>
        <name>NonOrtMeanSPTree</name>
        <briefdescription>
<para>A mean-split hybrid spill tree considering general splitting hyperplanes (not necessarily axis-orthogonal). </para>
        </briefdescription>
        <detaileddescription>
<para>This is the same as the NonOrtSPTree, but this particular implementation will use the mean of the data in the split projection as the value on which to split, instead of the midpoint. This can sometimes give better performance, but it is not always clear which type of tree is best.</para>
<para>This template typedef satisfies the TreeType policy API.</para>
<para><simplesect kind="see"><para><ref refid="trees" kindref="compound">The TreeType policy in mlpack</ref>, <ref refid="classmlpack_1_1tree_1_1SpillTree" kindref="compound">SpillTree</ref>, <ref refid="namespacemlpack_1_1tree_1a70daa44ca5882971662fb7a5410213e3" kindref="member">MeanSPTree</ref>, <ref refid="namespacemlpack_1_1tree_1a6c0340182bd764bfd3e7514619cb2662" kindref="member">NonOrtSPTree</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/tree/spill_tree/typedef.hpp" line="115" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/tree/spill_tree/typedef.hpp" bodystart="119" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacemlpack_1_1tree_1a6c0340182bd764bfd3e7514619cb2662" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename MetricType</type>
          </param>
          <param>
            <type>typename StatisticType</type>
          </param>
          <param>
            <type>typename MatType</type>
          </param>
        </templateparamlist>
        <type><ref refid="classmlpack_1_1tree_1_1SpillTree" kindref="compound">SpillTree</ref>&lt; MetricType, StatisticType, MatType, <ref refid="namespacemlpack_1_1tree_1ac4b7e2e4fa5c9c21bba75a48365b5c19" kindref="member">Hyperplane</ref>, <ref refid="classmlpack_1_1tree_1_1MidpointSpaceSplit" kindref="compound">MidpointSpaceSplit</ref> &gt;</type>
        <definition>using NonOrtSPTree =  SpillTree&lt;MetricType, StatisticType, MatType, Hyperplane, MidpointSpaceSplit&gt;</definition>
        <argsstring></argsstring>
        <name>NonOrtSPTree</name>
        <briefdescription>
<para>A hybrid spill tree considering general splitting hyperplanes (not necessarily axis-orthogonal). </para>
        </briefdescription>
        <detaileddescription>
<para>This particular implementation will consider the midpoint of the projection of the data in the vector determined by the farthest pair of points. This can sometimes give better performance, but generally it doesn&apos;t because it takes O(d) to calculate the projection of the query point when deciding which node to traverse, while when using a axis-orthogonal hyperplane, as SPTree does, we can do it in O(1).</para>
<para>This template typedef satisfies the TreeType policy API.</para>
<para><simplesect kind="see"><para><ref refid="trees" kindref="compound">The TreeType policy in mlpack</ref>, <ref refid="classmlpack_1_1tree_1_1SpillTree" kindref="compound">SpillTree</ref>, <ref refid="namespacemlpack_1_1tree_1af141bd85a0c63728935fff9f5f8dd587" kindref="member">SPTree</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/tree/spill_tree/typedef.hpp" line="96" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/tree/spill_tree/typedef.hpp" bodystart="100" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacemlpack_1_1tree_1a8d37735a4c28a68dd71ecb462c22e43c" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename MetricType</type>
          </param>
          <param>
            <type>typename StatisticType</type>
          </param>
          <param>
            <type>typename MatType</type>
          </param>
        </templateparamlist>
        <type><ref refid="classmlpack_1_1tree_1_1RectangleTree" kindref="compound">RectangleTree</ref>&lt; MetricType, StatisticType, MatType, <ref refid="classmlpack_1_1tree_1_1RPlusTreeSplit" kindref="compound">RPlusTreeSplit</ref>&lt; <ref refid="classmlpack_1_1tree_1_1RPlusPlusTreeSplitPolicy" kindref="compound">RPlusPlusTreeSplitPolicy</ref>, <ref refid="classmlpack_1_1tree_1_1MinimalSplitsNumberSweep" kindref="compound">MinimalSplitsNumberSweep</ref> &gt;, <ref refid="classmlpack_1_1tree_1_1RPlusPlusTreeDescentHeuristic" kindref="compound">RPlusPlusTreeDescentHeuristic</ref>, <ref refid="classmlpack_1_1tree_1_1RPlusPlusTreeAuxiliaryInformation" kindref="compound">RPlusPlusTreeAuxiliaryInformation</ref> &gt;</type>
        <definition>using RPlusPlusTree =  RectangleTree&lt;MetricType, StatisticType, MatType, RPlusTreeSplit&lt;RPlusPlusTreeSplitPolicy, MinimalSplitsNumberSweep&gt;, RPlusPlusTreeDescentHeuristic, RPlusPlusTreeAuxiliaryInformation&gt;</definition>
        <argsstring></argsstring>
        <name>RPlusPlusTree</name>
        <briefdescription>
<para>The R++ tree, a variant of the R+ tree with maximum buonding rectangles. </para>
        </briefdescription>
        <detaileddescription>
<para>This template typedef satisfies the TreeType policy API.</para>
<para><programlisting><codeline><highlight class="normal">@inproceedings{sumak2014r,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>author<sp/>=<sp/>{{\v{S}}um{\&apos;a}k,<sp/>Martin<sp/>and<sp/>Gursk{\&apos;y},<sp/>Peter},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>title<sp/>=<sp/>{R++-Tree:<sp/>An<sp/>Efficient<sp/>Spatial<sp/>Access<sp/>Method<sp/>for<sp/>Highly<sp/>Redundant</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>Point<sp/>Data},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>booktitle<sp/>=<sp/>{New<sp/>Trends<sp/>in<sp/>Databases<sp/>and<sp/>Information<sp/>Systems:<sp/>17th<sp/>East</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>European<sp/>Conference<sp/>on<sp/>Advances<sp/>in<sp/>Databases<sp/>and<sp/>Information<sp/>Systems},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>year<sp/>=<sp/>{2014},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>isbn<sp/>=<sp/>{978-3-319-01863-8},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pages<sp/>=<sp/>{37--44},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>publisher<sp/>=<sp/>{Springer<sp/>International<sp/>Publishing},</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para><simplesect kind="see"><para><ref refid="trees" kindref="compound">The TreeType policy in mlpack</ref>, <ref refid="namespacemlpack_1_1tree_1ae4af35641769744ba680cc934e1c1f0e" kindref="member">RTree</ref>, <ref refid="namespacemlpack_1_1tree_1ae4af35641769744ba680cc934e1c1f0e" kindref="member">RTree</ref>, <ref refid="namespacemlpack_1_1tree_1ab824e5f1c342bc76e5b2def29d2cb2e5" kindref="member">RPlusTree</ref>, <ref refid="namespacemlpack_1_1tree_1a8d37735a4c28a68dd71ecb462c22e43c" kindref="member">RPlusPlusTree</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/tree/rectangle_tree/typedef.hpp" line="191" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/tree/rectangle_tree/typedef.hpp" bodystart="197" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacemlpack_1_1tree_1ab824e5f1c342bc76e5b2def29d2cb2e5" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename MetricType</type>
          </param>
          <param>
            <type>typename StatisticType</type>
          </param>
          <param>
            <type>typename MatType</type>
          </param>
        </templateparamlist>
        <type><ref refid="classmlpack_1_1tree_1_1RectangleTree" kindref="compound">RectangleTree</ref>&lt; MetricType, StatisticType, MatType, <ref refid="classmlpack_1_1tree_1_1RPlusTreeSplit" kindref="compound">RPlusTreeSplit</ref>&lt; <ref refid="classmlpack_1_1tree_1_1RPlusTreeSplitPolicy" kindref="compound">RPlusTreeSplitPolicy</ref>, <ref refid="classmlpack_1_1tree_1_1MinimalCoverageSweep" kindref="compound">MinimalCoverageSweep</ref> &gt;, <ref refid="classmlpack_1_1tree_1_1RPlusTreeDescentHeuristic" kindref="compound">RPlusTreeDescentHeuristic</ref>, <ref refid="classmlpack_1_1tree_1_1NoAuxiliaryInformation" kindref="compound">NoAuxiliaryInformation</ref> &gt;</type>
        <definition>using RPlusTree =  RectangleTree&lt;MetricType, StatisticType, MatType, RPlusTreeSplit&lt;RPlusTreeSplitPolicy, MinimalCoverageSweep&gt;, RPlusTreeDescentHeuristic, NoAuxiliaryInformation&gt;</definition>
        <argsstring></argsstring>
        <name>RPlusTree</name>
        <briefdescription>
<para>The R+ tree, a variant of the R tree that avoids overlapping rectangles. </para>
        </briefdescription>
        <detaileddescription>
<para>The implementation is modified from the original paper implementation. This template typedef satisfies the TreeType policy API.</para>
<para><programlisting><codeline><highlight class="normal">@inproceedings{sellis1987r,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>author<sp/>=<sp/>{Sellis,<sp/>Timos<sp/>K.<sp/>and<sp/>Roussopoulos,<sp/>Nick<sp/>and<sp/>Faloutsos,<sp/>Christos},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>title<sp/>=<sp/>{The<sp/>R+-Tree:<sp/>A<sp/>Dynamic<sp/>Index<sp/>for<sp/>Multi-Dimensional<sp/>Objects},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>booktitle<sp/>=<sp/>{Proceedings<sp/>of<sp/>the<sp/>13th<sp/>International<sp/>Conference<sp/>on<sp/>Very</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>Large<sp/>Data<sp/>Bases},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>series<sp/>=<sp/>{VLDB<sp/>&apos;87},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>year<sp/>=<sp/>{1987},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>isbn<sp/>=<sp/>{0-934613-46-X},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pages<sp/>=<sp/>{507--518},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>numpages<sp/>=<sp/>{12},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>publisher<sp/>=<sp/>{Morgan<sp/>Kaufmann<sp/>Publishers<sp/>Inc.},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>address<sp/>=<sp/>{San<sp/>Francisco,<sp/>CA,<sp/>USA},</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para><simplesect kind="see"><para><ref refid="trees" kindref="compound">The TreeType policy in mlpack</ref>, <ref refid="namespacemlpack_1_1tree_1ae4af35641769744ba680cc934e1c1f0e" kindref="member">RTree</ref>, <ref refid="namespacemlpack_1_1tree_1ae4af35641769744ba680cc934e1c1f0e" kindref="member">RTree</ref>, <ref refid="namespacemlpack_1_1tree_1ab824e5f1c342bc76e5b2def29d2cb2e5" kindref="member">RPlusTree</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/tree/rectangle_tree/typedef.hpp" line="162" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/tree/rectangle_tree/typedef.hpp" bodystart="168" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacemlpack_1_1tree_1a13e8453de3098f2c2d4770a2266cc009" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename MetricType</type>
          </param>
          <param>
            <type>typename StatisticType</type>
          </param>
          <param>
            <type>typename MatType</type>
          </param>
        </templateparamlist>
        <type><ref refid="classmlpack_1_1tree_1_1BinarySpaceTree" kindref="compound">BinarySpaceTree</ref>&lt; MetricType, StatisticType, MatType, <ref refid="classmlpack_1_1bound_1_1HRectBound" kindref="compound">bound::HRectBound</ref>, <ref refid="classmlpack_1_1tree_1_1RPTreeMeanSplit" kindref="compound">RPTreeMeanSplit</ref> &gt;</type>
        <definition>using RPTree =  BinarySpaceTree&lt;MetricType, StatisticType, MatType, bound::HRectBound, RPTreeMeanSplit&gt;</definition>
        <argsstring></argsstring>
        <name>RPTree</name>
        <briefdescription>
<para>A mean-split random projection tree. </para>
        </briefdescription>
        <detaileddescription>
<para>When recursively splitting nodes, the RPTree class may perform one of two different kinds of split. Depending on the diameter and the average distance between points, the node may be split by a random hyperplane or according to the distance from the mean point. The tree holds points in leaf nodes. In contrast to the k-d tree, children of a MaxSplitRPTree node may overlap.</para>
<para><programlisting><codeline><highlight class="normal">@inproceedings{dasgupta2008,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>author<sp/>=<sp/>{Dasgupta,<sp/>Sanjoy<sp/>and<sp/>Freund,<sp/>Yoav},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>title<sp/>=<sp/>{Random<sp/>Projection<sp/>Trees<sp/>and<sp/>Low<sp/>Dimensional<sp/>Manifolds},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>booktitle<sp/>=<sp/>{Proceedings<sp/>of<sp/>the<sp/>Fortieth<sp/>Annual<sp/>ACM<sp/>Symposium<sp/>on<sp/>Theory<sp/>of</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Computing},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>series<sp/>=<sp/>{STOC<sp/>&apos;08},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>year<sp/>=<sp/>{2008},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pages<sp/>=<sp/>{537--546},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>numpages<sp/>=<sp/>{10},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>publisher<sp/>=<sp/>{ACM},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>address<sp/>=<sp/>{New<sp/>York,<sp/>NY,<sp/>USA},</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>This template typedef satisfies the TreeType policy API.</para>
<para><simplesect kind="see"><para><ref refid="trees" kindref="compound">The TreeType policy in mlpack</ref>, <ref refid="classmlpack_1_1tree_1_1BinarySpaceTree" kindref="compound">BinarySpaceTree</ref>, <ref refid="namespacemlpack_1_1tree_1a9d4905444011bbd045122cc985638b32" kindref="member">BallTree</ref>, <ref refid="namespacemlpack_1_1tree_1a1028e6acf1fc61997237d3677cae0947" kindref="member">MeanSplitKDTree</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/tree/binary_space_tree/typedef.hpp" line="262" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/tree/binary_space_tree/typedef.hpp" bodystart="266" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacemlpack_1_1tree_1a879db9c5c88d62f13f4a1667bc5adf5c" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename MetricType</type>
          </param>
          <param>
            <type>typename StatisticType</type>
          </param>
          <param>
            <type>typename MatType</type>
          </param>
        </templateparamlist>
        <type><ref refid="classmlpack_1_1tree_1_1RectangleTree" kindref="compound">RectangleTree</ref>&lt; MetricType, StatisticType, MatType, <ref refid="classmlpack_1_1tree_1_1RStarTreeSplit" kindref="compound">RStarTreeSplit</ref>, <ref refid="classmlpack_1_1tree_1_1RStarTreeDescentHeuristic" kindref="compound">RStarTreeDescentHeuristic</ref>, <ref refid="classmlpack_1_1tree_1_1NoAuxiliaryInformation" kindref="compound">NoAuxiliaryInformation</ref> &gt;</type>
        <definition>using RStarTree =  RectangleTree&lt;MetricType, StatisticType, MatType, RStarTreeSplit, RStarTreeDescentHeuristic, NoAuxiliaryInformation&gt;</definition>
        <argsstring></argsstring>
        <name>RStarTree</name>
        <briefdescription>
<para>The R*-tree, a more recent variant of the R tree. </para>
        </briefdescription>
        <detaileddescription>
<para>This template typedef satisfies the TreeType policy API.</para>
<para><programlisting><codeline><highlight class="normal">@inproceedings{beckmann1990r,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>title={The<sp/>R*-tree:<sp/>an<sp/>efficient<sp/>and<sp/>robust<sp/>access<sp/>method<sp/>for<sp/>points<sp/>and</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>rectangles},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>author={Beckmann,<sp/>N.<sp/>and<sp/>Kriegel,<sp/>H.-P.<sp/>and<sp/>Schneider,<sp/>R.<sp/>and<sp/>Seeger,<sp/>B.},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>booktitle={Proceedings<sp/>of<sp/>the<sp/>1990<sp/>ACM<sp/>SIGMOD<sp/>International<sp/>Conference<sp/>on</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Management<sp/>of<sp/>Data<sp/>(SIGMOD<sp/>&apos;90)},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>volume={19},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>number={2},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>year={1990},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>publisher={ACM}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para><simplesect kind="see"><para><ref refid="trees" kindref="compound">The TreeType policy in mlpack</ref>, <ref refid="namespacemlpack_1_1tree_1ae4af35641769744ba680cc934e1c1f0e" kindref="member">RTree</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/tree/rectangle_tree/typedef.hpp" line="70" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/tree/rectangle_tree/typedef.hpp" bodystart="75" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacemlpack_1_1tree_1ae4af35641769744ba680cc934e1c1f0e" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename MetricType</type>
          </param>
          <param>
            <type>typename StatisticType</type>
          </param>
          <param>
            <type>typename MatType</type>
          </param>
        </templateparamlist>
        <type><ref refid="classmlpack_1_1tree_1_1RectangleTree" kindref="compound">RectangleTree</ref>&lt; MetricType, StatisticType, MatType, <ref refid="classmlpack_1_1tree_1_1RTreeSplit" kindref="compound">RTreeSplit</ref>, <ref refid="classmlpack_1_1tree_1_1RTreeDescentHeuristic" kindref="compound">RTreeDescentHeuristic</ref>, <ref refid="classmlpack_1_1tree_1_1NoAuxiliaryInformation" kindref="compound">NoAuxiliaryInformation</ref> &gt;</type>
        <definition>using RTree =  RectangleTree&lt;MetricType, StatisticType, MatType, RTreeSplit, RTreeDescentHeuristic, NoAuxiliaryInformation&gt;</definition>
        <argsstring></argsstring>
        <name>RTree</name>
        <briefdescription>
<para>An implementation of the R tree that satisfies the TreeType policy API. </para>
        </briefdescription>
        <detaileddescription>
<para>This is the same R-tree structure as proposed by Guttman:</para>
<para><programlisting><codeline><highlight class="normal">@inproceedings{guttman1984r,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>title={R-trees:<sp/>a<sp/>dynamic<sp/>index<sp/>structure<sp/>for<sp/>spatial<sp/>searching},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>author={Guttman,<sp/>A.},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>booktitle={Proceedings<sp/>of<sp/>the<sp/>1984<sp/>ACM<sp/>SIGMOD<sp/>International<sp/>Conference<sp/>on</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Management<sp/>of<sp/>Data<sp/>(SIGMOD<sp/>&apos;84)},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>volume={14},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>number={2},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>year={1984},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>publisher={ACM}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para><simplesect kind="see"><para><ref refid="trees" kindref="compound">The TreeType policy in mlpack</ref>, <ref refid="namespacemlpack_1_1tree_1a879db9c5c88d62f13f4a1667bc5adf5c" kindref="member">RStarTree</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/tree/rectangle_tree/typedef.hpp" line="42" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/tree/rectangle_tree/typedef.hpp" bodystart="47" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacemlpack_1_1tree_1af141bd85a0c63728935fff9f5f8dd587" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename MetricType</type>
          </param>
          <param>
            <type>typename StatisticType</type>
          </param>
          <param>
            <type>typename MatType</type>
          </param>
        </templateparamlist>
        <type><ref refid="classmlpack_1_1tree_1_1SpillTree" kindref="compound">SpillTree</ref>&lt; MetricType, StatisticType, MatType, <ref refid="namespacemlpack_1_1tree_1afa85d70df69e258859143d448fbe0553" kindref="member">AxisOrthogonalHyperplane</ref>, <ref refid="classmlpack_1_1tree_1_1MidpointSpaceSplit" kindref="compound">MidpointSpaceSplit</ref> &gt;</type>
        <definition>using SPTree =  SpillTree&lt;MetricType, StatisticType, MatType, AxisOrthogonalHyperplane, MidpointSpaceSplit&gt;</definition>
        <argsstring></argsstring>
        <name>SPTree</name>
        <briefdescription>
<para>The hybrid spill tree. </para>
        </briefdescription>
        <detaileddescription>
<para>It is a variant of metric-trees in which the children of a node can &quot;spill over&quot; onto each other, and contain shared datapoints.</para>
<para>When recursively splitting nodes, the SPTree class select the dimension with maximum width to split on, and picks the midpoint of the range in that dimension as the value on which to split nodes.</para>
<para>In each case a &quot;overlapping buffer&quot; is defined, included points at a distance less than tau from the decision boundary defined by the midpoint.</para>
<para>For each node, we first split the points considering the overlapping buffer. If either of its children contains more than rho fraction of the total points we undo the overlapping splitting. Instead a conventional partition is used. In this way, we can ensure that each split reduces the number of points of a node by at least a constant factor.</para>
<para>For more information, see the following paper.</para>
<para><programlisting><codeline><highlight class="normal">@inproceedings{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>author<sp/>=<sp/>{Ting<sp/>Liu,<sp/>Andrew<sp/>W.<sp/>Moore,<sp/>Alexander<sp/>Gray<sp/>and<sp/>Ke<sp/>Yang},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>title<sp/>=<sp/>{An<sp/>Investigation<sp/>of<sp/>Practical<sp/>Approximate<sp/>Nearest<sp/>Neighbor</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Algorithms},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>booktitle<sp/>=<sp/>{Advances<sp/>in<sp/>Neural<sp/>Information<sp/>Processing<sp/>Systems<sp/>17},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>year<sp/>=<sp/>{2005},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pages<sp/>=<sp/>{825--832}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>This template typedef satisfies the TreeType policy API.</para>
<para><simplesect kind="see"><para><ref refid="trees" kindref="compound">The TreeType policy in mlpack</ref>, <ref refid="classmlpack_1_1tree_1_1SpillTree" kindref="compound">SpillTree</ref>, <ref refid="namespacemlpack_1_1tree_1a70daa44ca5882971662fb7a5410213e3" kindref="member">MeanSPTree</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/tree/spill_tree/typedef.hpp" line="58" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/tree/spill_tree/typedef.hpp" bodystart="62" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacemlpack_1_1tree_1a6ed9d585969e7837af0d41e0c3975602" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename MetricType</type>
          </param>
          <param>
            <type>typename StatisticType</type>
          </param>
          <param>
            <type>typename MatType</type>
          </param>
        </templateparamlist>
        <type><ref refid="classmlpack_1_1tree_1_1CoverTree" kindref="compound">CoverTree</ref>&lt; MetricType, StatisticType, MatType, <ref refid="classmlpack_1_1tree_1_1FirstPointIsRoot" kindref="compound">FirstPointIsRoot</ref> &gt;</type>
        <definition>using StandardCoverTree =  CoverTree&lt;MetricType, StatisticType, MatType, FirstPointIsRoot&gt;</definition>
        <argsstring></argsstring>
        <name>StandardCoverTree</name>
        <briefdescription>
<para>The standard cover tree, as detailed in the original cover tree paper: </para>
        </briefdescription>
        <detaileddescription>
<para><programlisting><codeline><highlight class="normal">@inproceedings{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>author={Beygelzimer,<sp/>A.<sp/>and<sp/>Kakade,<sp/>S.<sp/>and<sp/>Langford,<sp/>J.},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>title={Cover<sp/>trees<sp/>for<sp/>nearest<sp/>neighbor},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>booktitle={Proceedings<sp/>of<sp/>the<sp/>23rd<sp/>International<sp/>Conference<sp/>on<sp/>Machine</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Learning<sp/>(ICML<sp/>2006)},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pages={97--104},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>year={2006}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>This template typedef satisfies the requirements of the TreeType API.</para>
<para><simplesect kind="see"><para><ref refid="trees" kindref="compound">The TreeType policy in mlpack</ref>, <ref refid="classmlpack_1_1tree_1_1CoverTree" kindref="compound">CoverTree</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/tree/cover_tree/typedef.hpp" line="39" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/tree/cover_tree/typedef.hpp" bodystart="42" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacemlpack_1_1tree_1afef9300f198bfdcb0272cc71fcd1ef12" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename MetricType</type>
          </param>
          <param>
            <type>typename StatisticType</type>
          </param>
          <param>
            <type>typename MatType</type>
          </param>
        </templateparamlist>
        <type><ref refid="classmlpack_1_1tree_1_1BinarySpaceTree" kindref="compound">BinarySpaceTree</ref>&lt; MetricType, StatisticType, MatType, <ref refid="classmlpack_1_1bound_1_1CellBound" kindref="compound">bound::CellBound</ref>, <ref refid="classmlpack_1_1tree_1_1UBTreeSplit" kindref="compound">UBTreeSplit</ref> &gt;</type>
        <definition>using UBTree =  BinarySpaceTree&lt;MetricType, StatisticType, MatType, bound::CellBound, UBTreeSplit&gt;</definition>
        <argsstring></argsstring>
        <name>UBTree</name>
        <briefdescription>
<para>The Universal B-tree. </para>
        </briefdescription>
        <detaileddescription>
<para>When recursively splitting nodes, the class calculates addresses of all points and splits each node according to the median address. Children may overlap since the implementation of a tighter bound requires a lot of arithmetic operations. In order to get a tighter bound increase the CellBound::maxNumBounds constant.</para>
<para><programlisting><codeline><highlight class="normal">@inproceedings{bayer1997,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>author<sp/>=<sp/>{Bayer,<sp/>Rudolf},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>title<sp/>=<sp/>{The<sp/>Universal<sp/>B-Tree<sp/>for<sp/>Multidimensional<sp/>Indexing:<sp/>General</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Concepts},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>booktitle<sp/>=<sp/>{Proceedings<sp/>of<sp/>the<sp/>International<sp/>Conference<sp/>on<sp/>Worldwide</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Computing<sp/>and<sp/>Its<sp/>Applications},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>series<sp/>=<sp/>{WWCA<sp/>&apos;97},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>year<sp/>=<sp/>{1997},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>isbn<sp/>=<sp/>{3-540-63343-X},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pages<sp/>=<sp/>{198--209},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>numpages<sp/>=<sp/>{12},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>publisher<sp/>=<sp/>{Springer-Verlag},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>address<sp/>=<sp/>{London,<sp/>UK,<sp/>UK},</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>This template typedef satisfies the TreeType policy API.</para>
<para><simplesect kind="see"><para><ref refid="trees" kindref="compound">The TreeType policy in mlpack</ref>, <ref refid="classmlpack_1_1tree_1_1BinarySpaceTree" kindref="compound">BinarySpaceTree</ref>, <ref refid="namespacemlpack_1_1tree_1a9d4905444011bbd045122cc985638b32" kindref="member">BallTree</ref>, <ref refid="namespacemlpack_1_1tree_1a1028e6acf1fc61997237d3677cae0947" kindref="member">MeanSplitKDTree</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/tree/binary_space_tree/typedef.hpp" line="297" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/tree/binary_space_tree/typedef.hpp" bodystart="301" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacemlpack_1_1tree_1a2cc107a67c3011cc95797065a0867d7e" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename MetricType</type>
          </param>
          <param>
            <type>typename StatisticType</type>
          </param>
          <param>
            <type>typename MatType</type>
          </param>
        </templateparamlist>
        <type><ref refid="classmlpack_1_1tree_1_1BinarySpaceTree" kindref="compound">BinarySpaceTree</ref>&lt; MetricType, StatisticType, MatType, <ref refid="classmlpack_1_1bound_1_1HollowBallBound" kindref="compound">bound::HollowBallBound</ref>, <ref refid="namespacemlpack_1_1tree_1aa93c424ec92d738156c120337109b79e" kindref="member">VPTreeSplit</ref> &gt;</type>
        <definition>using VPTree =  BinarySpaceTree&lt;MetricType, StatisticType, MatType, bound::HollowBallBound, VPTreeSplit&gt;</definition>
        <argsstring></argsstring>
        <name>VPTree</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/tree/binary_space_tree/typedef.hpp" line="195" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/tree/binary_space_tree/typedef.hpp" bodystart="199" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacemlpack_1_1tree_1aa93c424ec92d738156c120337109b79e" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename BoundType</type>
          </param>
          <param>
            <type>typename MatType</type>
            <defval>arma::mat</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classmlpack_1_1tree_1_1VantagePointSplit" kindref="compound">VantagePointSplit</ref>&lt; BoundType, MatType, 100 &gt;</type>
        <definition>using VPTreeSplit =  VantagePointSplit&lt;BoundType, MatType, 100&gt;</definition>
        <argsstring></argsstring>
        <name>VPTreeSplit</name>
        <briefdescription>
<para>The vantage point tree (which is also called the metric tree. </para>
        </briefdescription>
        <detaileddescription>
<para>Vantage point trees and metric trees were invented independently by Yianilos an Uhlmann) is a kind of the binary space tree. When recursively splitting nodes, the VPTree class selects the vantage point and splits the node according to the distance to this point. Thus, points that are closer to the vantage point form the inner subtree. Other points form the outer subtree. The vantage point is contained in the first (inner) node.</para>
<para>This implementation differs from the original algorithms. Namely, vantage points are not contained in intermediate nodes. The tree has points only in the leaves of the tree.</para>
<para>For more information, see the following papers.</para>
<para><programlisting><codeline><highlight class="normal">@inproceedings{yianilos1993vptrees,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>author<sp/>=<sp/>{Yianilos,<sp/>Peter<sp/>N.},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>title<sp/>=<sp/>{Data<sp/>Structures<sp/>and<sp/>Algorithms<sp/>for<sp/>Nearest<sp/>Neighbor<sp/>Search<sp/>in</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>General<sp/>Metric<sp/>Spaces},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>booktitle<sp/>=<sp/>{Proceedings<sp/>of<sp/>the<sp/>Fourth<sp/>Annual<sp/>ACM-SIAM<sp/>Symposium<sp/>on</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Discrete<sp/>Algorithms},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>series<sp/>=<sp/>{SODA<sp/>&apos;93},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>year<sp/>=<sp/>{1993},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>isbn<sp/>=<sp/>{0-89871-313-7},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pages<sp/>=<sp/>{311--321},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>numpages<sp/>=<sp/>{11},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>publisher<sp/>=<sp/>{Society<sp/>for<sp/>Industrial<sp/>and<sp/>Applied<sp/>Mathematics},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>address<sp/>=<sp/>{Philadelphia,<sp/>PA,<sp/>USA}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">@article{uhlmann1991metrictrees,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>author<sp/>=<sp/>{Jeffrey<sp/>K.<sp/>Uhlmann},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>title<sp/>=<sp/>{Satisfying<sp/>general<sp/>proximity<sp/>/<sp/>similarity<sp/>queries<sp/>with<sp/>metric</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>trees},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>journal<sp/>=<sp/>{Information<sp/>Processing<sp/>Letters},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>volume<sp/>=<sp/>{40},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>number<sp/>=<sp/>{4},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pages<sp/>=<sp/>{175<sp/>-<sp/>179},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>year<sp/>=<sp/>{1991},</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>This template typedef satisfies the TreeType policy API.</para>
<para><simplesect kind="see"><para><ref refid="trees" kindref="compound">The TreeType policy in mlpack</ref>, <ref refid="classmlpack_1_1tree_1_1BinarySpaceTree" kindref="compound">BinarySpaceTree</ref>, VantagePointTree, <ref refid="namespacemlpack_1_1tree_1a2cc107a67c3011cc95797065a0867d7e" kindref="member">VPTree</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/tree/binary_space_tree/typedef.hpp" line="192" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/tree/binary_space_tree/typedef.hpp" bodystart="192" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacemlpack_1_1tree_1a78cd0a7cf4615cae990696f90aea84c4" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename MetricType</type>
          </param>
          <param>
            <type>typename StatisticType</type>
          </param>
          <param>
            <type>typename MatType</type>
          </param>
        </templateparamlist>
        <type><ref refid="classmlpack_1_1tree_1_1RectangleTree" kindref="compound">RectangleTree</ref>&lt; MetricType, StatisticType, MatType, <ref refid="classmlpack_1_1tree_1_1XTreeSplit" kindref="compound">XTreeSplit</ref>, <ref refid="classmlpack_1_1tree_1_1RTreeDescentHeuristic" kindref="compound">RTreeDescentHeuristic</ref>, <ref refid="classmlpack_1_1tree_1_1XTreeAuxiliaryInformation" kindref="compound">XTreeAuxiliaryInformation</ref> &gt;</type>
        <definition>using XTree =  RectangleTree&lt;MetricType, StatisticType, MatType, XTreeSplit, RTreeDescentHeuristic, XTreeAuxiliaryInformation&gt;</definition>
        <argsstring></argsstring>
        <name>XTree</name>
        <briefdescription>
<para>The X-tree, a variant of the R tree with supernodes. </para>
        </briefdescription>
        <detaileddescription>
<para>This template typedef satisfies the TreeType policy API.</para>
<para><programlisting><codeline><highlight class="normal">@inproceedings{berchtold1996r,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>title<sp/>=<sp/>{The<sp/>X-Tree:<sp/>An<sp/>Index<sp/>Structure<sp/>for<sp/>High--Dimensional<sp/>Data},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>author<sp/>=<sp/>{Berchtold,<sp/>Stefan<sp/>and<sp/>Keim,<sp/>Daniel<sp/>A.<sp/>and<sp/>Kriegel,<sp/>Hans-Peter},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>booktitle<sp/>=<sp/>{Proc.<sp/>22th<sp/>Int.<sp/>Conf.<sp/>on<sp/>Very<sp/>Large<sp/>Databases<sp/>(VLDB&apos;96),<sp/>Bombay,<sp/>India},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>editor<sp/>=<sp/>{Vijayaraman,<sp/>T.<sp/>and<sp/>Buchmann,<sp/>Alex<sp/>and<sp/>Mohan,<sp/>C.<sp/>and<sp/>Sarda,<sp/>N.},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pages<sp/>=<sp/>{28--39},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>year<sp/>=<sp/>{1996},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>publisher<sp/>=<sp/>{Morgan<sp/>Kaufmann}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para><simplesect kind="see"><para><ref refid="trees" kindref="compound">The TreeType policy in mlpack</ref>, <ref refid="namespacemlpack_1_1tree_1ae4af35641769744ba680cc934e1c1f0e" kindref="member">RTree</ref>, <ref refid="namespacemlpack_1_1tree_1a879db9c5c88d62f13f4a1667bc5adf5c" kindref="member">RStarTree</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/tree/rectangle_tree/typedef.hpp" line="96" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/tree/rectangle_tree/typedef.hpp" bodystart="101" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="var">
      <memberdef kind="variable" id="namespacemlpack_1_1tree_1a23057f6f52ed3b029f53aacbc1fcec85" prot="public" static="no" mutable="no">
        <type>const double</type>
        <definition>const double MAX_OVERLAP</definition>
        <argsstring></argsstring>
        <name>MAX_OVERLAP</name>
        <initializer>= 0.2</initializer>
        <briefdescription>
<para>The X-tree paper says that a maximum allowable overlap of 20% works well. </para>
        </briefdescription>
        <detaileddescription>
<para>This code should eventually be refactored so as to avoid polluting <ref refid="namespacemlpack_1_1tree" kindref="compound">mlpack::tree</ref> with this random double. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/tree/rectangle_tree/x_tree_split.hpp" line="29" column="14" bodyfile="/home/aakash/mlpack/src/mlpack/core/tree/rectangle_tree/x_tree_split.hpp" bodystart="29" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="namespacemlpack_1_1tree_1aebb06bf0ada277e56a77d80cd1985dbe" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>bool</type>
            <declname>UseWeights</declname>
            <defname>UseWeights</defname>
          </param>
          <param>
            <type>typename MatType</type>
          </param>
          <param>
            <type>typename LabelsType</type>
          </param>
          <param>
            <type>typename WeightsType</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void mlpack::tree::Bootstrap</definition>
        <argsstring>(const MatType &amp;dataset, const LabelsType &amp;labels, const WeightsType &amp;weights, MatType &amp;bootstrapDataset, LabelsType &amp;bootstrapLabels, WeightsType &amp;bootstrapWeights)</argsstring>
        <name>Bootstrap</name>
        <param>
          <type>const MatType &amp;</type>
          <declname>dataset</declname>
        </param>
        <param>
          <type>const LabelsType &amp;</type>
          <declname>labels</declname>
        </param>
        <param>
          <type>const WeightsType &amp;</type>
          <declname>weights</declname>
        </param>
        <param>
          <type>MatType &amp;</type>
          <declname>bootstrapDataset</declname>
        </param>
        <param>
          <type>LabelsType &amp;</type>
          <declname>bootstrapLabels</declname>
        </param>
        <param>
          <type>WeightsType &amp;</type>
          <declname>bootstrapWeights</declname>
        </param>
        <briefdescription>
<para>Given a dataset, create another dataset via bootstrap sampling, with labels. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/methods/random_forest/bootstrap.hpp" line="26" column="6" bodyfile="/home/aakash/mlpack/src/mlpack/methods/random_forest/bootstrap.hpp" bodystart="26" bodyend="45"/>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1tree_1abab37b0038f14ab4dcdf83c60468e923" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class TreeType</type>
          </param>
          <param>
            <type>class Walker</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void mlpack::tree::EnumerateTree</definition>
        <argsstring>(TreeType *tree, Walker &amp;walker)</argsstring>
        <name>EnumerateTree</name>
        <param>
          <type>TreeType *</type>
          <declname>tree</declname>
        </param>
        <param>
          <type>Walker &amp;</type>
          <declname>walker</declname>
        </param>
        <briefdescription>
<para>Traverses all nodes of the tree, including the inner ones. </para>
        </briefdescription>
        <detaileddescription>
<para>On each node two methods of the <computeroutput>enumer</computeroutput> are called:</para>
<para>Enter(TreeType* node, TreeType* parent); Leave(TreeType* node, TreeType* parent);</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tree</parametername>
</parameternamelist>
<parameterdescription>
<para>The tree to traverse. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>walker</parametername>
</parameternamelist>
<parameterdescription>
<para>An instance of custom class, receiver of the enumeration. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/tree/enumerate_tree.hpp" line="56" column="13" bodyfile="/home/aakash/mlpack/src/mlpack/core/tree/enumerate_tree.hpp" bodystart="56" bodyend="59"/>
        <references refid="namespacemlpack_1_1tree_1_1enumerate_1a3dd4930ca0f3b9f5779a4efe7e4703ad" compoundref="enumerate__tree_8hpp" startline="24" endline="40">mlpack::tree::enumerate::EnumerateTreeImpl</references>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Trees and tree-building procedures. </para>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="/home/aakash/mlpack/src/mlpack/core/tree/binary_space_tree/binary_space_tree.hpp" line="20" column="1"/>
  </compounddef>
</doxygen>
