.TH "HoeffdingTree< FitnessFunction, NumericSplitType, CategoricalSplitType >" 3 "Sun Jun 20 2021" "Version 3.4.2" "mlpack" \" -*- nroff -*-
.ad l
.nh
.SH NAME
HoeffdingTree< FitnessFunction, NumericSplitType, CategoricalSplitType > \- The \fBHoeffdingTree\fP object represents all of the necessary information for a Hoeffding-bound-based decision tree\&.  

.SH SYNOPSIS
.br
.PP
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef CategoricalSplitType< FitnessFunction > \fBCategoricalSplit\fP"
.br
.RI "Allow access to the categorical split type\&. "
.ti -1c
.RI "typedef NumericSplitType< FitnessFunction > \fBNumericSplit\fP"
.br
.RI "Allow access to the numeric split type\&. "
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBHoeffdingTree\fP ()"
.br
.RI "Construct a Hoeffding tree with no data and no information\&. "
.ti -1c
.RI "\fBHoeffdingTree\fP (const \fBdata::DatasetInfo\fP &datasetInfo, const size_t numClasses, const double successProbability=0\&.95, const size_t maxSamples=0, const size_t checkInterval=100, const size_t minSamples=100, const CategoricalSplitType< FitnessFunction > &categoricalSplitIn=CategoricalSplitType< FitnessFunction >(0, 0), const NumericSplitType< FitnessFunction > &numericSplitIn=NumericSplitType< FitnessFunction >(0), std::unordered_map< size_t, std::pair< size_t, size_t >> *dimensionMappings=NULL, const bool copyDatasetInfo=true)"
.br
.RI "Construct the Hoeffding tree with the given parameters, but training on no data\&. "
.ti -1c
.RI "\fBHoeffdingTree\fP (const \fBHoeffdingTree\fP &other)"
.br
.RI "Copy another tree (warning: this will duplicate the tree entirely, and may use a lot of memory\&. "
.ti -1c
.RI "template<typename MatType > \fBHoeffdingTree\fP (const MatType &data, const \fBdata::DatasetInfo\fP &datasetInfo, const arma::Row< size_t > &labels, const size_t numClasses, const bool batchTraining=true, const double successProbability=0\&.95, const size_t maxSamples=0, const size_t checkInterval=100, const size_t minSamples=100, const CategoricalSplitType< FitnessFunction > &categoricalSplitIn=CategoricalSplitType< FitnessFunction >(0, 0), const NumericSplitType< FitnessFunction > &numericSplitIn=NumericSplitType< FitnessFunction >(0))"
.br
.RI "Construct the Hoeffding tree with the given parameters and given training data\&. "
.ti -1c
.RI "\fBHoeffdingTree\fP (\fBHoeffdingTree\fP &&other)"
.br
.RI "Move another tree\&. "
.ti -1c
.RI "\fB~HoeffdingTree\fP ()"
.br
.RI "Clean up memory\&. "
.ti -1c
.RI "template<typename VecType > size_t \fBCalculateDirection\fP (const VecType &point) const"
.br
.RI "Given a point and that this node is not a leaf, calculate the index of the child node this point would go towards\&. "
.ti -1c
.RI "size_t \fBCheckInterval\fP () const"
.br
.RI "Get the number of samples before a split check is performed\&. "
.ti -1c
.RI "void \fBCheckInterval\fP (const size_t checkInterval)"
.br
.RI "Modify the number of samples before a split check is performed\&. "
.ti -1c
.RI "\fBHoeffdingTree\fP & \fBChild\fP (const size_t i)"
.br
.RI "Modify a child\&. "
.ti -1c
.RI "const \fBHoeffdingTree\fP & \fBChild\fP (const size_t i) const"
.br
.RI "Get a child\&. "
.ti -1c
.RI "template<typename MatType > void \fBClassify\fP (const MatType &data, arma::Row< size_t > &predictions) const"
.br
.RI "Classify the given points, using this node and the entire (sub)tree beneath it\&. "
.ti -1c
.RI "template<typename MatType > void \fBClassify\fP (const MatType &data, arma::Row< size_t > &predictions, arma::rowvec &probabilities) const"
.br
.RI "Classify the given points, using this node and the entire (sub)tree beneath it\&. "
.ti -1c
.RI "template<typename VecType > size_t \fBClassify\fP (const VecType &point) const"
.br
.RI "Classify the given point, using this node and the entire (sub)tree beneath it\&. "
.ti -1c
.RI "template<typename VecType > void \fBClassify\fP (const VecType &point, size_t &prediction, double &probability) const"
.br
.RI "Classify the given point and also return an estimate of the probability that the prediction is correct\&. "
.ti -1c
.RI "void \fBCreateChildren\fP ()"
.br
.RI "Given that this node should split, create the children\&. "
.ti -1c
.RI "size_t & \fBMajorityClass\fP ()"
.br
.RI "Modify the majority class\&. "
.ti -1c
.RI "size_t \fBMajorityClass\fP () const"
.br
.RI "Get the majority class\&. "
.ti -1c
.RI "double & \fBMajorityProbability\fP ()"
.br
.RI "Modify the probability of the majority class\&. "
.ti -1c
.RI "double \fBMajorityProbability\fP () const"
.br
.RI "Get the probability of the majority class (based on training samples)\&. "
.ti -1c
.RI "size_t \fBMaxSamples\fP () const"
.br
.RI "Get the maximum number of samples before a split is forced\&. "
.ti -1c
.RI "void \fBMaxSamples\fP (const size_t maxSamples)"
.br
.RI "Modify the maximum number of samples before a split is forced\&. "
.ti -1c
.RI "size_t \fBMinSamples\fP () const"
.br
.RI "Get the minimum number of samples for a split\&. "
.ti -1c
.RI "void \fBMinSamples\fP (const size_t minSamples)"
.br
.RI "Modify the minimum number of samples for a split\&. "
.ti -1c
.RI "size_t \fBNumChildren\fP () const"
.br
.RI "Get the number of children\&. "
.ti -1c
.RI "size_t \fBNumDescendants\fP () const"
.br
.RI "Get the size of the Hoeffding Tree\&. "
.ti -1c
.RI "\fBHoeffdingTree\fP & \fBoperator=\fP (const \fBHoeffdingTree\fP &other)"
.br
.RI "Copy assignment operator\&. "
.ti -1c
.RI "\fBHoeffdingTree\fP & \fBoperator=\fP (\fBHoeffdingTree\fP &&other)"
.br
.RI "Move assignment operator\&. "
.ti -1c
.RI "template<typename Archive > void \fBserialize\fP (Archive &ar, const uint32_t)"
.br
.RI "Serialize the split\&. "
.ti -1c
.RI "size_t \fBSplitCheck\fP ()"
.br
.RI "Check if a split would satisfy the conditions of the Hoeffding bound with the node's specified success probability\&. "
.ti -1c
.RI "size_t \fBSplitDimension\fP () const"
.br
.RI "Get the splitting dimension (size_t(-1) if no split)\&. "
.ti -1c
.RI "double \fBSuccessProbability\fP () const"
.br
.RI "Get the confidence required for a split\&. "
.ti -1c
.RI "void \fBSuccessProbability\fP (const double successProbability)"
.br
.RI "Modify the confidence required for a split\&. "
.ti -1c
.RI "template<typename MatType > void \fBTrain\fP (const MatType &data, const arma::Row< size_t > &labels, const bool batchTraining=true, const bool resetTree=false, const size_t numClasses=0)"
.br
.RI "Train on a set of points, either in streaming mode or in batch mode, with the given labels\&. "
.ti -1c
.RI "template<typename MatType > void \fBTrain\fP (const MatType &data, const \fBdata::DatasetInfo\fP &info, const arma::Row< size_t > &labels, const bool batchTraining=true, const size_t numClasses=0)"
.br
.RI "Train on a set of points, either in streaming mode or in batch mode, with the given labels and the given \fCDatasetInfo\fP\&. "
.ti -1c
.RI "template<typename VecType > void \fBTrain\fP (const VecType &point, const size_t label)"
.br
.RI "Train on a single point in streaming mode, with the given label\&. "
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename FitnessFunction = GiniImpurity, template< typename > class NumericSplitType = HoeffdingDoubleNumericSplit, template< typename > class CategoricalSplitType = HoeffdingCategoricalSplit>
.br
class mlpack::tree::HoeffdingTree< FitnessFunction, NumericSplitType, CategoricalSplitType >"
The \fBHoeffdingTree\fP object represents all of the necessary information for a Hoeffding-bound-based decision tree\&. 

This class is able to train on samples in streaming settings and batch settings, and perform splits based on the Hoeffding bound\&. The Hoeffding tree (also known as the 'very fast decision
tree' -- VFDT) is described in the following paper:
.PP
.PP
.nf
@inproceedings{domingos2000mining,
    title={{Mining High-Speed Data Streams}},
    author={Domingos, P\&. and Hulten, G\&.},
    year={2000},
    booktitle={Proceedings of the Sixth ACM SIGKDD International Conference
        on Knowledge Discovery and Data Mining (KDD '00)},
    pages={71--80}
}
.fi
.PP
.PP
The class is modular, and takes three template parameters\&. The first, FitnessFunction, is the fitness function that should be used to determine whether a split is beneficial; examples might be \fBGiniImpurity\fP or \fBHoeffdingInformationGain\fP\&. The NumericSplitType determines how numeric attributes are handled, and the CategoricalSplitType determines how categorical attributes are handled\&. As far as the actual splitting goes, the meat of the splitting procedure will be contained in those two classes\&.
.PP
\fBTemplate Parameters\fP
.RS 4
\fIFitnessFunction\fP Fitness function to use\&. 
.br
\fINumericSplitType\fP Technique for splitting numeric features\&. 
.br
\fICategoricalSplitType\fP Technique for splitting categorical features\&. 
.RE
.PP

.PP
Definition at line 61 of file hoeffding_tree\&.hpp\&.
.SH "Member Typedef Documentation"
.PP 
.SS "typedef CategoricalSplitType<FitnessFunction> \fBCategoricalSplit\fP"

.PP
Allow access to the categorical split type\&. 
.PP
Definition at line 67 of file hoeffding_tree\&.hpp\&.
.SS "typedef NumericSplitType<FitnessFunction> \fBNumericSplit\fP"

.PP
Allow access to the numeric split type\&. 
.PP
Definition at line 65 of file hoeffding_tree\&.hpp\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBHoeffdingTree\fP (const MatType & data, const \fBdata::DatasetInfo\fP & datasetInfo, const arma::Row< size_t > & labels, const size_t numClasses, const bool batchTraining = \fCtrue\fP, const double successProbability = \fC0\&.95\fP, const size_t maxSamples = \fC0\fP, const size_t checkInterval = \fC100\fP, const size_t minSamples = \fC100\fP, const CategoricalSplitType< FitnessFunction > & categoricalSplitIn = \fCCategoricalSplitType< FitnessFunction >(0, 0)\fP, const NumericSplitType< FitnessFunction > & numericSplitIn = \fCNumericSplitType< FitnessFunction >(0)\fP)"

.PP
Construct the Hoeffding tree with the given parameters and given training data\&. The tree may be trained either in batch mode (which looks at all points before splitting, and propagates these points to the created children for further training), or in streaming mode, where each point is only considered once\&. (In general, batch mode will give better-performing trees, but will have higher memory and runtime costs for the same dataset\&.)
.PP
\fBParameters\fP
.RS 4
\fIdata\fP Dataset to train on\&. 
.br
\fIdatasetInfo\fP Information on the dataset (types of each feature)\&. 
.br
\fIlabels\fP Labels of each point in the dataset\&. 
.br
\fInumClasses\fP Number of classes in the dataset\&. 
.br
\fIbatchTraining\fP Whether or not to train in batch\&. 
.br
\fIsuccessProbability\fP Probability of success required in Hoeffding bounds before a split can happen\&. 
.br
\fImaxSamples\fP Maximum number of samples before a split is forced (0 never forces a split); ignored in batch training mode\&. 
.br
\fIcheckInterval\fP Number of samples required before each split; ignored in batch training mode\&. 
.br
\fIminSamples\fP If the node has seen this many points or fewer, no split will be allowed\&. 
.br
\fIcategoricalSplitIn\fP Optional instantiated categorical split object\&. 
.br
\fInumericSplitIn\fP Optional instantiated numeric split object\&. 
.RE
.PP

.SS "\fBHoeffdingTree\fP (const \fBdata::DatasetInfo\fP & datasetInfo, const size_t numClasses, const double successProbability = \fC0\&.95\fP, const size_t maxSamples = \fC0\fP, const size_t checkInterval = \fC100\fP, const size_t minSamples = \fC100\fP, const CategoricalSplitType< FitnessFunction > & categoricalSplitIn = \fCCategoricalSplitType< FitnessFunction >(0, 0)\fP, const NumericSplitType< FitnessFunction > & numericSplitIn = \fCNumericSplitType< FitnessFunction >(0)\fP, std::unordered_map< size_t, std::pair< size_t, size_t >> * dimensionMappings = \fCNULL\fP, const bool copyDatasetInfo = \fCtrue\fP)"

.PP
Construct the Hoeffding tree with the given parameters, but training on no data\&. The dimensionMappings parameter is only used if it is desired that this node does not create its own dimensionMappings object (for instance, if this is a child of another node in the tree)\&.
.PP
\fBParameters\fP
.RS 4
\fInumClasses\fP Number of classes in the dataset\&. 
.br
\fIdatasetInfo\fP Information on the dataset (types of each feature)\&. 
.br
\fIsuccessProbability\fP Probability of success required in Hoeffding bound before a split can happen\&. 
.br
\fImaxSamples\fP Maximum number of samples before a split is forced\&. 
.br
\fIcheckInterval\fP Number of samples required before each split check\&. 
.br
\fIminSamples\fP If the node has seen this many points or fewer, no split will be allowed\&. 
.br
\fIdimensionMappings\fP Mappings from dimension indices to positions in numeric and categorical split vectors\&. If left NULL, a new one will be created\&. 
.br
\fIcopyDatasetInfo\fP If true, then a copy of the datasetInfo will be made\&. 
.br
\fIcategoricalSplitIn\fP Optional instantiated categorical split object\&. 
.br
\fInumericSplitIn\fP Optional instantiated numeric split object\&. 
.RE
.PP

.SS "\fBHoeffdingTree\fP ()"

.PP
Construct a Hoeffding tree with no data and no information\&. Be sure to call \fBTrain()\fP before trying to use the tree\&. 
.SS "\fBHoeffdingTree\fP (const \fBHoeffdingTree\fP< FitnessFunction, NumericSplitType, CategoricalSplitType > & other)"

.PP
Copy another tree (warning: this will duplicate the tree entirely, and may use a lot of memory\&. Make sure it's what you want before you do it)\&.
.PP
\fBParameters\fP
.RS 4
\fIother\fP Tree to copy\&. 
.RE
.PP

.SS "\fBHoeffdingTree\fP (\fBHoeffdingTree\fP< FitnessFunction, NumericSplitType, CategoricalSplitType > && other)"

.PP
Move another tree\&. 
.PP
\fBParameters\fP
.RS 4
\fIother\fP Tree to move\&. 
.RE
.PP

.SS "~\fBHoeffdingTree\fP ()"

.PP
Clean up memory\&. 
.SH "Member Function Documentation"
.PP 
.SS "size_t CalculateDirection (const VecType & point) const"

.PP
Given a point and that this node is not a leaf, calculate the index of the child node this point would go towards\&. This method is primarily used by the \fBClassify()\fP function, but it can be used in a standalone sense too\&.
.PP
\fBParameters\fP
.RS 4
\fIpoint\fP Point to classify\&. 
.RE
.PP

.SS "size_t CheckInterval () const\fC [inline]\fP"

.PP
Get the number of samples before a split check is performed\&. 
.PP
Definition at line 284 of file hoeffding_tree\&.hpp\&.
.SS "void CheckInterval (const size_t checkInterval)"

.PP
Modify the number of samples before a split check is performed\&. 
.SS "\fBHoeffdingTree\fP& Child (const size_t i)\fC [inline]\fP"

.PP
Modify a child\&. 
.PP
Definition at line 266 of file hoeffding_tree\&.hpp\&.
.SS "const \fBHoeffdingTree\fP& Child (const size_t i) const\fC [inline]\fP"

.PP
Get a child\&. 
.PP
Definition at line 264 of file hoeffding_tree\&.hpp\&.
.SS "void Classify (const MatType & data, arma::Row< size_t > & predictions) const"

.PP
Classify the given points, using this node and the entire (sub)tree beneath it\&. The predicted labels for each point are returned\&.
.PP
\fBParameters\fP
.RS 4
\fIdata\fP Points to classify\&. 
.br
\fIpredictions\fP Predicted labels for each point\&. 
.RE
.PP

.SS "void Classify (const MatType & data, arma::Row< size_t > & predictions, arma::rowvec & probabilities) const"

.PP
Classify the given points, using this node and the entire (sub)tree beneath it\&. The predicted labels for each point are returned, as well as an estimate of the probability that the prediction is correct for each point\&. This estimate is simply the \fBMajorityProbability()\fP for the leaf that each point bins to\&.
.PP
\fBParameters\fP
.RS 4
\fIdata\fP Points to classify\&. 
.br
\fIpredictions\fP Predicted labels for each point\&. 
.br
\fIprobabilities\fP Probability estimates for each predicted label\&. 
.RE
.PP

.SS "size_t Classify (const VecType & point) const"

.PP
Classify the given point, using this node and the entire (sub)tree beneath it\&. The predicted label is returned\&.
.PP
\fBParameters\fP
.RS 4
\fIpoint\fP Point to classify\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Predicted label of point\&. 
.RE
.PP

.SS "void Classify (const VecType & point, size_t & prediction, double & probability) const"

.PP
Classify the given point and also return an estimate of the probability that the prediction is correct\&. (This estimate is simply the probability that a training point was from the majority class in the leaf that this point binned to\&.)
.PP
\fBParameters\fP
.RS 4
\fIpoint\fP Point to classify\&. 
.br
\fIprediction\fP Predicted label of point\&. 
.br
\fIprobability\fP An estimate of the probability that the prediction is correct\&. 
.RE
.PP

.SS "void CreateChildren ()"

.PP
Given that this node should split, create the children\&. 
.SS "size_t& MajorityClass ()\fC [inline]\fP"

.PP
Modify the majority class\&. 
.PP
Definition at line 253 of file hoeffding_tree\&.hpp\&.
.SS "size_t MajorityClass () const\fC [inline]\fP"

.PP
Get the majority class\&. 
.PP
Definition at line 251 of file hoeffding_tree\&.hpp\&.
.SS "double& MajorityProbability ()\fC [inline]\fP"

.PP
Modify the probability of the majority class\&. 
.PP
Definition at line 258 of file hoeffding_tree\&.hpp\&.
.SS "double MajorityProbability () const\fC [inline]\fP"

.PP
Get the probability of the majority class (based on training samples)\&. 
.PP
Definition at line 256 of file hoeffding_tree\&.hpp\&.
.SS "size_t MaxSamples () const\fC [inline]\fP"

.PP
Get the maximum number of samples before a split is forced\&. 
.PP
Definition at line 279 of file hoeffding_tree\&.hpp\&.
.SS "void MaxSamples (const size_t maxSamples)"

.PP
Modify the maximum number of samples before a split is forced\&. 
.SS "size_t MinSamples () const\fC [inline]\fP"

.PP
Get the minimum number of samples for a split\&. 
.PP
Definition at line 274 of file hoeffding_tree\&.hpp\&.
.SS "void MinSamples (const size_t minSamples)"

.PP
Modify the minimum number of samples for a split\&. 
.SS "size_t NumChildren () const\fC [inline]\fP"

.PP
Get the number of children\&. 
.PP
Definition at line 261 of file hoeffding_tree\&.hpp\&.
.SS "size_t NumDescendants () const"

.PP
Get the size of the Hoeffding Tree\&. 
.SS "\fBHoeffdingTree\fP& operator= (const \fBHoeffdingTree\fP< FitnessFunction, NumericSplitType, CategoricalSplitType > & other)"

.PP
Copy assignment operator\&. 
.PP
\fBParameters\fP
.RS 4
\fIother\fP Tree to copy\&. 
.RE
.PP

.SS "\fBHoeffdingTree\fP& operator= (\fBHoeffdingTree\fP< FitnessFunction, NumericSplitType, CategoricalSplitType > && other)"

.PP
Move assignment operator\&. 
.PP
\fBParameters\fP
.RS 4
\fIother\fP Tree to move\&. 
.RE
.PP

.SS "void serialize (Archive & ar, const uint32_t)"

.PP
Serialize the split\&. 
.SS "size_t SplitCheck ()"

.PP
Check if a split would satisfy the conditions of the Hoeffding bound with the node's specified success probability\&. If so, the number of children that would be created is returned\&. If not, 0 is returned\&. 
.SS "size_t SplitDimension () const\fC [inline]\fP"

.PP
Get the splitting dimension (size_t(-1) if no split)\&. 
.PP
Definition at line 248 of file hoeffding_tree\&.hpp\&.
.SS "double SuccessProbability () const\fC [inline]\fP"

.PP
Get the confidence required for a split\&. 
.PP
Definition at line 269 of file hoeffding_tree\&.hpp\&.
.SS "void SuccessProbability (const double successProbability)"

.PP
Modify the confidence required for a split\&. 
.SS "void Train (const MatType & data, const arma::Row< size_t > & labels, const bool batchTraining = \fCtrue\fP, const bool resetTree = \fCfalse\fP, const size_t numClasses = \fC0\fP)"

.PP
Train on a set of points, either in streaming mode or in batch mode, with the given labels\&. If \fCresetTree\fP is set to \fCtrue\fP, then reset the state of the tree to an empty tree before training\&.
.PP
Note that the tree will be automatically reset if the dimensionality of \fCdata\fP does not match the dimensionality that the tree was currently trained with\&. The tree will also be reset if \fCnumClasses\fP is passed\&.
.PP
\fBParameters\fP
.RS 4
\fIdata\fP Data points to train on\&. 
.br
\fIlabels\fP Labels of data points\&. 
.br
\fIbatchTraining\fP If true, perform training in batch\&. 
.br
\fIresetTree\fP If true, reset the tree to an empty tree before training\&. 
.br
\fInumClasses\fP The number of classes in \fClabels\fP\&. Passing this will reset the tree\&. If not given and \fCresetTree\fP is \fCtrue\fP, then the number of classes will be computed from \fClabels\fP\&. 
.RE
.PP

.SS "void Train (const MatType & data, const \fBdata::DatasetInfo\fP & info, const arma::Row< size_t > & labels, const bool batchTraining = \fCtrue\fP, const size_t numClasses = \fC0\fP)"

.PP
Train on a set of points, either in streaming mode or in batch mode, with the given labels and the given \fCDatasetInfo\fP\&. This will reset the tree\&. This only needs to be called when the \fCDatasetInfo\fP has changed---if you are training incrementally but have already passed the DatasetInfo once, use the overload of \fC\fBTrain()\fP\fP that does not take a \fCDatasetInfo\fP and make sure \fCresetTree\fP is set to \fCfalse\fP\&.
.PP
\fBParameters\fP
.RS 4
\fIdata\fP Data points to train on\&. 
.br
\fIinfo\fP DatasetInfo object with information about each dimension\&. 
.br
\fIlabels\fP Labels of data points\&. 
.br
\fIbatchTraining\fP If true, perform training in batch\&. 
.br
\fInumClasses\fP Number of classes in \fClabels\fP\&. If not specified, it is computed from \fClabels\fP\&. 
.RE
.PP

.SS "void Train (const VecType & point, const size_t label)"

.PP
Train on a single point in streaming mode, with the given label\&. The tree will not be reset before training\&.
.PP
\fBParameters\fP
.RS 4
\fIpoint\fP Point to train on\&. 
.br
\fIlabel\fP Label of point to train on\&. 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for mlpack from the source code\&.
